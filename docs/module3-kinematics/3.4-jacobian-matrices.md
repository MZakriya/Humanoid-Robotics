# 3.4 Jacobian Matrices

## Overview

The Jacobian matrix is a fundamental mathematical tool in robotics that relates joint velocities to end-effector velocities. It provides the linear mapping between the joint space and Cartesian space, enabling the analysis of robot motion, force transmission, and singularity conditions. The Jacobian is essential for robot control, trajectory planning, and optimization of robotic systems.

## Mathematical Foundation

### Definition and Properties

The Jacobian matrix J(q) is defined as the matrix of partial derivatives that relates joint velocities θ̇ to end-effector velocities ẋ:

```
ẋ = J(q) · θ̇
```

Where:
- ẋ is the end-effector velocity vector (6×1 for spatial motion: linear + angular)
- J(q) is the Jacobian matrix (6×n for n-DOF robot)
- θ̇ is the joint velocity vector (n×1)

### Velocity Components

For a 6-DOF spatial mechanism, the end-effector velocity vector includes:

```
ẋ = [ ẋ ]  (linear velocity)
     [ ω ]  (angular velocity)
```

Where ẋ = [ẋ, ẏ, ż]ᵀ and ω = [ωₓ, ωᵧ, ωz]ᵀ.

## Types of Jacobians

### Geometric Jacobian

The geometric Jacobian is derived directly from the kinematic structure using the product of exponentials or DH parameters:

```python
import numpy as np

def geometric_jacobian(robot, joint_angles):
    """
    Calculate geometric Jacobian for a robot
    """
    n = len(joint_angles)
    J = np.zeros((6, n))  # 6 rows for spatial velocity, n columns for joints

    # Calculate transformation matrices for all frames
    T_all = [np.eye(4)]  # T_0^0
    T_current = np.eye(4)

    # Forward kinematics to get all frame positions
    for i, (theta_fixed, d_fixed, a, alpha, joint_type) in enumerate(robot.dh_table):
        if joint_type == 'R':
            theta = theta_fixed + joint_angles[i]
            d = d_fixed
        else:  # Prismatic
            theta = theta_fixed
            d = d_fixed + joint_angles[i]

        T_i = dh_transform(theta, d, a, alpha)
        T_current = T_current @ T_i
        T_all.append(T_current)

    # End-effector position
    o_n = T_all[-1][:3, 3]

    # Calculate Jacobian columns
    for i in range(n):
        T_i = T_all[i]
        o_i = T_i[:3, 3]  # Position of frame i
        z_i = T_i[:3, 2]  # z-axis of frame i

        if robot.dh_table[i][4] == 'R':  # Revolute joint
            # Linear velocity component: cross product of z-axis with position vector
            J[:3, i] = np.cross(z_i, o_n - o_i)
            # Angular velocity component: z-axis
            J[3:, i] = z_i
        else:  # Prismatic joint
            # Linear velocity component: z-axis
            J[:3, i] = z_i
            # Angular velocity component: zero
            J[3:, i] = np.zeros(3)

    return J
```

### Analytical Jacobian

The analytical Jacobian is derived by taking partial derivatives of the forward kinematics equations directly:

```python
def analytical_jacobian(robot, joint_angles):
    """
    Calculate analytical Jacobian by differentiating forward kinematics
    """
    n = len(joint_angles)
    J = np.zeros((6, n))

    # Small delta for numerical differentiation
    delta = 1e-6

    # Calculate base forward kinematics
    base_pose = forward_kinematics(robot, joint_angles)

    for i in range(n):
        # Perturb joint i
        perturbed_joints = joint_angles.copy()
        perturbed_joints[i] += delta

        # Calculate perturbed forward kinematics
        perturbed_pose = forward_kinematics(robot, perturbed_joints)

        # Calculate velocity as difference divided by delta
        linear_vel = (perturbed_pose[:3, 3] - base_pose[:3, 3]) / delta
        angular_vel = rotation_matrix_to_angular_velocity(
            base_pose[:3, :3],
            perturbed_pose[:3, :3]
        ) / delta

        # Store in Jacobian
        J[:3, i] = linear_vel
        J[3:, i] = angular_vel

    return J

def rotation_matrix_to_angular_velocity(R1, R2):
    """
    Convert rotation matrix difference to angular velocity
    """
    R_rel = R2 @ R1.T
    # Use matrix logarithm to get angular velocity
    # For small rotations: omega = 0.5 * [R - R^T] (skew-symmetric part)
    if np.allclose(R_rel, np.eye(3), atol=1e-3):
        # Small angle approximation
        skew = R_rel - R_rel.T
        return np.array([skew[2, 1], skew[0, 2], skew[1, 0]]) * 0.5
    else:
        # More general approach using logarithm
        # This is a simplified version - full implementation requires more complex math
        return np.array([0, 0, 0])
```

## Jacobian Calculation Methods

### Product of Exponentials (POE) Method

```python
def poe_jacobian(robot, joint_angles):
    """
    Calculate Jacobian using Product of Exponentials formulation
    """
    n = len(joint_angles)
    J = np.zeros((6, n))

    # Screw axes in body frame
    S_body = robot.screw_axes_body  # Predefined screw axes

    # Calculate Adjoint transformation from end-effector to each joint
    g_bt = forward_kinematics_body(robot, joint_angles)  # g_bt: end-effector pose in base frame

    for i in range(n):
        # Calculate g_si (pose from joint i to end-effector)
        g_st = forward_kinematics_body(robot, joint_angles[i:])
        g_it = g_st  # This is a simplification

        # Adjoint transformation
        Ad_g_it = adjoint_transform(g_it)

        # Body Jacobian column
        J_body_col = Ad_g_it @ S_body[i]

        # Convert to spatial Jacobian
        J[:, i] = J_body_col

    return J

def adjoint_transform(g):
    """
    Calculate Adjoint transformation matrix
    """
    R = g[:3, :3]
    p = g[:3, 3]

    # Create skew-symmetric matrix
    p_skew = np.array([
        [0, -p[2], p[1]],
        [p[2], 0, -p[0]],
        [-p[1], p[0], 0]
    ])

    Ad = np.zeros((6, 6))
    Ad[:3, :3] = R
    Ad[3:, 3:] = R
    Ad[3:, :3] = p_skew @ R

    return Ad
```

### Velocity Propagation Method

```python
def velocity_propagation_jacobian(robot, joint_angles):
    """
    Calculate Jacobian using velocity propagation method
    """
    n = len(joint_angles)
    J = np.zeros((6, n))

    # Initialize velocities at base (assumed stationary)
    v_base = np.zeros(3)  # Linear velocity
    w_base = np.zeros(3)  # Angular velocity

    # Forward velocity propagation
    v_current = v_base.copy()
    w_current = w_base.copy()

    # Calculate all transformation matrices first
    T_all = [np.eye(4)]
    T_current = np.eye(4)

    for i, (theta_fixed, d_fixed, a, alpha, joint_type) in enumerate(robot.dh_table):
        if joint_type == 'R':
            theta = theta_fixed + joint_angles[i]
            d = d_fixed
        else:
            theta = theta_fixed
            d = d_fixed + joint_angles[i]

        T_i = dh_transform(theta, d, a, alpha)
        T_current = T_current @ T_i
        T_all.append(T_current)

    # Calculate Jacobian columns
    for i in range(n):
        # Get transformation from base to frame i
        T_i = T_all[i]
        R_i = T_i[:3, :3]  # Rotation matrix
        p_i = T_i[:3, 3]   # Position vector

        # Get joint axis in base frame
        z_i_base = R_i @ np.array([0, 0, 1])  # z-axis of frame i in base frame

        if robot.dh_table[i][4] == 'R':  # Revolute joint
            # For revolute joint: v_contribution = z × r
            r_to_end = T_all[-1][:3, 3] - p_i  # Vector from joint i to end-effector
            J[:3, i] = np.cross(z_i_base, r_to_end)  # Linear velocity contribution
            J[3:, i] = z_i_base  # Angular velocity contribution
        else:  # Prismatic joint
            J[:3, i] = z_i_base  # Linear velocity contribution
            J[3:, i] = np.zeros(3)  # No angular velocity contribution

    return J
```

## Singularity Analysis

### Jacobian Rank and Singularities

Singularities occur when the Jacobian matrix loses rank, meaning the robot loses one or more degrees of freedom in Cartesian space:

```python
def analyze_singularities(J, threshold=1e-6):
    """
    Analyze Jacobian for singularities
    """
    # Calculate SVD
    U, s, Vt = np.linalg.svd(J)

    # Check condition number
    condition_number = s[0] / s[-1] if s[-1] != 0 else float('inf')

    # Check for singular values near zero
    singularities = s < threshold

    return {
        'condition_number': condition_number,
        'rank': np.sum(s > threshold),
        'is_singular': condition_number > 1/threshold,
        'singular_directions': Vt[np.where(singularities)[0]],
        'manipulability': np.sqrt(np.prod(s))  # Yoshikawa manipulability measure
    }

def find_singularity_types(robot, joint_angles):
    """
    Classify singularity types
    """
    J = geometric_jacobian(robot, joint_angles)

    # Check different types of singularities
    analysis = analyze_singularities(J)

    # Additional checks for specific singularity types
    # Wrist singularities (last 3 joints for 6-DOF robot)
    if robot.dof >= 6:
        J_wrist = J[3:, -3:]  # Angular part of last 3 joints
        wrist_analysis = analyze_singularities(J_wrist)

        # Shoulder/Elbow singularities
        J_arm = J[:, :3]  # First 3 joints for positioning
        arm_analysis = analyze_singularities(J_arm)

    return {
        'overall': analysis,
        'wrist': wrist_analysis if robot.dof >= 6 else None,
        'arm': arm_analysis if robot.dof >= 6 else None
    }
```

### Singularity Avoidance

```python
def singularity_robust_inverse(J, threshold=1e-6):
    """
    Compute singularity-robust inverse of Jacobian
    """
    U, s, Vt = np.linalg.svd(J)

    # Apply damping to small singular values (Damped Least Squares)
    s_damped = s / (s**2 + threshold**2)

    # Reconstruct inverse
    J_inv = Vt.T @ np.diag(s_damped) @ U.T

    return J_inv

def jacobian_condition_number(robot, joint_angles):
    """
    Calculate condition number as measure of dexterity
    """
    J = geometric_jacobian(robot, joint_angles)
    U, s, Vt = np.linalg.svd(J)

    if len(s) > 0 and s[-1] != 0:
        return s[0] / s[-1]  # Condition number
    else:
        return float('inf')
```

## Applications of Jacobians

### Velocity Control

```python
def cartesian_velocity_control(robot, joint_angles, desired_cartesian_velocity):
    """
    Control robot end-effector velocity using Jacobian inverse
    """
    J = geometric_jacobian(robot, joint_angles)

    # Check for singularities
    if np.linalg.cond(J) > 1e6:
        print("Warning: Robot near singularity")
        J_inv = singularity_robust_inverse(J)
    else:
        J_inv = np.linalg.pinv(J)

    # Calculate required joint velocities
    joint_velocities = J_inv @ desired_cartesian_velocity

    return joint_velocities

def force_control(robot, joint_angles, desired_end_effector_force):
    """
    Calculate joint torques from end-effector forces (statics)
    """
    J = geometric_jacobian(robot, joint_angles)

    # Relationship: τ = J^T × F
    joint_torques = J.T @ desired_end_effector_force

    return joint_torques
```

### Trajectory Planning

```python
def cartesian_trajectory_to_joint(robot, cartesian_trajectory, initial_joints):
    """
    Convert Cartesian trajectory to joint space using Jacobian
    """
    n_points = len(cartesian_trajectory)
    n_joints = len(initial_joints)

    joint_trajectory = np.zeros((n_points, n_joints))
    joint_trajectory[0] = initial_joints

    for i in range(1, n_points):
        # Calculate Cartesian velocity
        dx = cartesian_trajectory[i] - cartesian_trajectory[i-1]

        # Calculate Jacobian at current joint configuration
        J = geometric_jacobian(robot, joint_trajectory[i-1])

        # Calculate joint velocity
        if np.linalg.cond(J) < 1e6:
            dq = np.linalg.pinv(J) @ dx
        else:
            dq = singularity_robust_inverse(J) @ dx

        # Integrate to get new joint angles
        joint_trajectory[i] = joint_trajectory[i-1] + dq

    return joint_trajectory
```

### Redundancy Resolution

```python
def null_space_projection(robot, joint_angles, desired_motion, null_task=None):
    """
    Use null space for redundancy resolution
    """
    J = geometric_jacobian(robot, joint_angles)

    # Calculate primary motion (task space)
    if np.linalg.cond(J) < 1e6:
        J_inv = np.linalg.pinv(J)
    else:
        J_inv = singularity_robust_inverse(J)

    primary_motion = J_inv @ desired_motion

    # Calculate null space projector
    I = np.eye(len(joint_angles))
    null_projector = I - J_inv @ J

    # Add null space motion if provided
    if null_task is not None:
        total_motion = primary_motion + null_projector @ null_task
    else:
        total_motion = primary_motion

    return total_motion
```

## Advanced Jacobian Concepts

### Task-Space Jacobian

For specific tasks that don't require full 6-DOF control:

```python
def task_space_jacobian(robot, joint_angles, task_indices):
    """
    Extract Jacobian for specific task variables
    task_indices: list of indices for desired task coordinates
    (e.g., [0,1,2] for x,y,z position only)
    """
    J_full = geometric_jacobian(robot, joint_angles)
    return J_full[task_indices, :]
```

### Time Derivative of Jacobian

For dynamic analysis:

```python
def jacobian_derivative(robot, joint_angles, joint_velocities):
    """
    Calculate time derivative of Jacobian
    """
    n = len(joint_angles)
    J_dot = np.zeros((6, n))

    # This is a simplified approach - full derivation requires
    # differentiating the Jacobian expression with respect to time
    delta = 1e-6

    J_current = geometric_jacobian(robot, joint_angles)

    # Use numerical differentiation
    for i in range(n):
        # Perturb joint i by its velocity * delta
        perturbed_angles = joint_angles.copy()
        perturbed_angles[i] += joint_velocities[i] * delta

        J_perturbed = geometric_jacobian(robot, perturbed_angles)
        J_dot[:, i] = (J_perturbed[:, i] - J_current[:, i]) / delta

    return J_dot
```

## Implementation Considerations

### Computational Efficiency

```python
def efficient_jacobian_calculation(robot, joint_angles):
    """
    Optimize Jacobian calculation for real-time applications
    """
    n = len(joint_angles)
    J = np.zeros((6, n))

    # Pre-calculate common terms
    cos_thetas = np.cos(joint_angles)
    sin_thetas = np.sin(joint_angles)

    # Calculate transformation matrices efficiently
    T_current = np.eye(4)

    for i in range(n):
        # Use pre-calculated trig values
        ct = cos_thetas[i]
        st = sin_thetas[i]

        # Calculate DH transformation for this joint
        # (using optimized DH transform that reuses trig values)
        T_i = optimized_dh_transform(robot.dh_table[i], ct, st)
        T_current = T_current @ T_i

        # Calculate Jacobian column using current transformation
        # (optimized calculation that reuses transformation data)
        J[:, i] = calculate_jacobian_column_optimized(T_current, robot.dh_table[i], i)

    return J
```

### Numerical Stability

```python
def numerically_stable_jacobian(robot, joint_angles, method='svd'):
    """
    Calculate Jacobian with numerical stability considerations
    """
    J = geometric_jacobian(robot, joint_angles)

    if method == 'svd':
        # Use SVD for numerical stability
        U, s, Vt = np.linalg.svd(J, full_matrices=False)

        # Regularize small singular values
        threshold = 1e-12
        s_reg = np.where(s > threshold, s, threshold)

        # Reconstruct regularized Jacobian
        J_reg = U @ np.diag(s_reg) @ Vt

        return J_reg
    elif method == 'qr':
        # Use QR decomposition
        Q, R = np.linalg.qr(J)
        return Q @ np.clip(R, -1e10, 1e10)  # Clamp to prevent overflow
    else:
        return J
```

## Jacobian Applications in Humanoid Robotics

### Balance and Posture Control

```python
def balance_jacobian(com_position, zmp_reference, robot_state):
    """
    Calculate Jacobian for center of mass control in humanoid robots
    """
    # Calculate Jacobian relating joint velocities to COM velocity
    J_com = calculate_com_jacobian(robot_state)

    # Calculate desired COM velocity to maintain balance
    com_error = zmp_reference - com_position
    desired_com_velocity = balance_controller_gains @ com_error

    # Calculate required joint velocities
    joint_velocities = np.linalg.pinv(J_com) @ desired_com_velocity

    return joint_velocities
```

### Multi-Task Control

```python
def multi_task_jacobian_control(robot, tasks, priorities):
    """
    Handle multiple control tasks with different priorities
    """
    # Primary task (highest priority)
    J1 = tasks[0]['jacobian']
    dx1 = tasks[0]['desired_velocity']

    # Calculate primary joint motion
    dq1 = np.linalg.pinv(J1) @ dx1

    # For secondary tasks, project into null space of primary task
    for i in range(1, len(tasks)):
        # Calculate null space projector for all higher priority tasks
        J_current = np.vstack([tasks[j]['jacobian'] for j in range(i)])
        P_null = null_space_projector(J_current)

        # Calculate secondary task motion in null space
        J2 = tasks[i]['jacobian']
        dx2 = tasks[i]['desired_velocity']

        # Project secondary task into null space
        J2_null = J2 @ P_null
        dq2 = np.linalg.pinv(J2_null) @ (dx2 - J2 @ dq1)

        # Update total motion
        dq1 = dq1 + P_null @ dq2

    return dq1
```

## Summary

The Jacobian matrix is a critical tool in robotics that bridges joint space and Cartesian space. It enables sophisticated control strategies, singularity analysis, and redundancy resolution. Understanding Jacobian computation and properties is essential for developing advanced robotic systems, particularly in applications requiring precise motion control, force control, or multi-task coordination. Modern implementations must consider numerical stability, computational efficiency, and real-time constraints while maintaining accuracy for safe and effective robot operation.