# 3.2 Inverse Kinematics

## Overview

Inverse kinematics (IK) is the mathematical process of determining the joint angles required to achieve a desired end-effector position and orientation. Unlike forward kinematics, which computes end-effector pose from joint angles, inverse kinematics solves the more complex problem of finding joint configurations that result in a specified end-effector pose. This is fundamental for robot control, trajectory planning, and manipulation tasks.

## Mathematical Foundation

### Problem Definition

Given an end-effector pose (position and orientation), find the joint angles θ₁, θ₂, ..., θₙ such that:

T(θ₁, θ₂, ..., θₙ) = T_desired

Where T represents the forward kinematics transformation.

### Analytical vs. Numerical Solutions

**Analytical Solutions:**
- Closed-form mathematical expressions
- Exact solutions when available
- Computationally efficient
- Limited to specific robot geometries
- Common for 6-DOF robots with spherical wrist

**Numerical Solutions:**
- Iterative approximation methods
- Applicable to general robot configurations
- Handle redundant robots effectively
- Computationally more expensive
- May converge to local minima

## Analytical Inverse Kinematics

### Pieper's Solution

For robots with 6 DOF where the last three joint axes intersect (spherical wrist), Pieper's method provides a closed-form solution:

1. **Position Solution**: Solve for first three joints using end-effector position
2. **Orientation Solution**: Solve for last three joints using wrist orientation

### Geometric Approach

For simple manipulators, geometric relationships can yield analytical solutions:

```python
import numpy as np

def inverse_kinematics_2dof(x, y, l1, l2):
    """
    Analytical inverse kinematics for 2-DOF planar manipulator
    """
    # Calculate distance from origin to target
    r = np.sqrt(x**2 + y**2)

    # Check if target is reachable
    if r > l1 + l2:
        raise ValueError("Target is outside workspace")
    if r < abs(l1 - l2):
        raise ValueError("Target is inside workspace boundary")

    # Calculate joint angle 2
    cos_theta2 = (l1**2 + l2**2 - r**2) / (2 * l1 * l2)
    sin_theta2 = np.sqrt(1 - cos_theta2**2)
    theta2 = np.arctan2(sin_theta2, cos_theta2)

    # Calculate joint angle 1
    k1 = l1 + l2 * cos_theta2
    k2 = l2 * sin_theta2
    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)

    return theta1, theta2
```

## Numerical Inverse Kinematics

### Jacobian-Based Methods

The Jacobian matrix relates joint velocities to end-effector velocities:

```
ẋ = J(θ) · θ̇
```

Where:
- ẋ is the end-effector velocity vector
- J(θ) is the Jacobian matrix
- θ̇ is the joint velocity vector

### Jacobian Pseudoinverse Method

```python
def jacobian_inverse_kinematics(robot, target_pose, current_joints, max_iterations=100, tolerance=1e-6):
    """
    Inverse kinematics using Jacobian pseudoinverse
    """
    joints = current_joints.copy()

    for i in range(max_iterations):
        # Calculate current end-effector pose
        current_pose = forward_kinematics(robot, joints)

        # Calculate error
        error = calculate_pose_error(target_pose, current_pose)

        if np.linalg.norm(error) < tolerance:
            break

        # Calculate Jacobian
        J = calculate_jacobian(robot, joints)

        # Calculate joint updates using pseudoinverse
        J_pinv = np.linalg.pinv(J)
        joint_updates = J_pinv @ error

        # Update joint angles
        joints += joint_updates * 0.1  # Step size

    return joints
```

### Jacobian Transpose Method

For cases where the Jacobian is not square or is singular:

```python
def jacobian_transpose_ik(robot, target_pose, current_joints, max_iterations=100, alpha=0.01):
    """
    Inverse kinematics using Jacobian transpose
    """
    joints = current_joints.copy()

    for i in range(max_iterations):
        current_pose = forward_kinematics(robot, joints)
        error = calculate_pose_error(target_pose, current_pose)

        if np.linalg.norm(error) < 1e-6:
            break

        J = calculate_jacobian(robot, joints)
        joint_updates = alpha * J.T @ error
        joints += joint_updates

    return joints
```

## Advanced Numerical Methods

### Cyclic Coordinate Descent (CCD)

Iteratively adjusts one joint at a time to minimize end-effector error:

```python
def ccd_ik(end_effector_pos, target_pos, joint_positions, joint_axes):
    """
    Cyclic Coordinate Descent Inverse Kinematics
    """
    for i in range(len(joint_positions)-1, -1, -1):  # From end to base
        # Vector from current joint to end effector
        vec_to_ee = end_effector_pos - joint_positions[i]
        vec_to_target = target_pos - joint_positions[i]

        # Calculate rotation angle
        angle = np.arccos(
            np.clip(np.dot(vec_to_target, vec_to_ee) /
                   (np.linalg.norm(vec_to_target) * np.linalg.norm(vec_to_ee)), -1, 1)
        )

        # Calculate rotation axis
        rotation_axis = np.cross(vec_to_ee, vec_to_target)
        rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)

        # Apply rotation to all subsequent joints
        for j in range(i, len(joint_positions)):
            # Rotate joint position around axis
            joint_positions[j] = rotate_around_axis(
                joint_positions[j],
                joint_positions[i],
                rotation_axis,
                angle
            )
```

### Damped Least Squares (DLS)

Addresses Jacobian singularities by adding damping:

```python
def dls_ik(robot, target_pose, current_joints, lambda_damping=0.01):
    """
    Damped Least Squares Inverse Kinematics
    """
    joints = current_joints.copy()

    # Calculate Jacobian
    J = calculate_jacobian(robot, joints)

    # Damped pseudoinverse: J# = J^T * (J * J^T + λ² * I)^(-1)
    JJT = J @ J.T
    damping_matrix = lambda_damping**2 * np.eye(JJT.shape[0])
    J_pinv = J.T @ np.linalg.inv(JJT + damping_matrix)

    # Calculate joint updates
    error = calculate_pose_error(target_pose, forward_kinematics(robot, joints))
    joint_updates = J_pinv @ error

    return joints + joint_updates
```

## Singularity Handling

### Singularity Detection

```python
def detect_singularities(jacobian, threshold=1e-6):
    """
    Detect singularities using condition number
    """
    condition_number = np.linalg.cond(jacobian)
    return condition_number > 1/threshold

def detect_singularities_svd(jacobian, threshold=1e-6):
    """
    Detect singularities using SVD
    """
    U, s, Vt = np.linalg.svd(jacobian)
    return np.min(s) < threshold
```

### Singularity Avoidance

```python
def singularity_robust_ik(robot, target_pose, current_joints, threshold=1e-6):
    """
    Singularity-robust inverse kinematics
    """
    joints = current_joints.copy()
    J = calculate_jacobian(robot, joints)

    # Check for singularities
    if detect_singularities(J, threshold):
        # Use damped least squares near singularities
        return dls_ik(robot, target_pose, joints)
    else:
        # Use standard pseudoinverse
        J_pinv = np.linalg.pinv(J)
        error = calculate_pose_error(target_pose, forward_kinematics(robot, joints))
        return joints + 0.1 * J_pinv @ error
```

## Redundant Robot Considerations

### Null Space Motion

For robots with more DOF than required (redundant robots), additional objectives can be optimized:

```python
def redundancy_resolution_ik(robot, target_pose, current_joints,
                           joint_limits=None, obstacle_positions=None):
    """
    Inverse kinematics with redundancy resolution
    """
    joints = current_joints.copy()
    J = calculate_jacobian(robot, joints)

    # Calculate primary joint updates for task
    J_pinv = np.linalg.pinv(J)
    error = calculate_pose_error(target_pose, forward_kinematics(robot, joints))
    primary_updates = J_pinv @ error

    # Calculate null space projector
    I = np.eye(len(joints))
    N = I - J_pinv @ J  # Null space projector

    # Add secondary objective (e.g., joint limit avoidance)
    secondary_objective = np.zeros(len(joints))
    if joint_limits:
        secondary_objective = avoid_joint_limits(joints, joint_limits)

    # Combine primary and secondary objectives
    total_updates = primary_updates + N @ secondary_objective

    return joints + 0.1 * total_updates

def avoid_joint_limits(joints, limits, threshold=0.1):
    """
    Generate joint velocity to avoid joint limits
    """
    velocities = np.zeros_like(joints)

    for i, (joint, (min_limit, max_limit)) in enumerate(zip(joints, limits)):
        range_limit = max_limit - min_limit
        safety_margin = threshold * range_limit

        if joint < (min_limit + safety_margin):
            velocities[i] = 1.0  # Move away from lower limit
        elif joint > (max_limit - safety_margin):
            velocities[i] = -1.0  # Move away from upper limit

    return velocities
```

## Implementation Considerations

### Convergence Criteria

```python
def check_convergence(current_pose, target_pose, pos_tolerance=1e-3, rot_tolerance=1e-3):
    """
    Check if inverse kinematics has converged
    """
    pos_error = np.linalg.norm(current_pose[:3, 3] - target_pose[:3, 3])
    rot_error = rotation_matrix_distance(current_pose[:3, :3], target_pose[:3, :3])

    return pos_error < pos_tolerance and rot_error < rot_tolerance

def rotation_matrix_distance(R1, R2):
    """
    Calculate distance between two rotation matrices
    """
    R_rel = R1.T @ R2
    angle = np.arccos(np.clip((np.trace(R_rel) - 1) / 2, -1, 1))
    return abs(angle)
```

### Multiple Solution Handling

```python
def multi_solution_ik(robot, target_pose, current_joints):
    """
    Find multiple inverse kinematics solutions
    """
    solutions = []

    # Try different initial configurations
    initial_configs = generate_elbow_up_down_configs(target_pose)

    for config in initial_configs:
        try:
            solution = jacobian_inverse_kinematics(robot, target_pose, config)
            if check_convergence(
                forward_kinematics(robot, solution),
                target_pose
            ):
                solutions.append(solution)
        except:
            continue  # Skip failed attempts

    return solutions
```

## Applications

### Robot Control

- Real-time trajectory following
- Cartesian space motion planning
- Coordination of multiple end-effectors
- Humanoid robot posture control

### Simulation and Animation

- Character animation in games and movies
- Robot simulation and testing
- Virtual reality applications
- Digital twin systems

### Redundant Manipulation

- Obstacle avoidance
- Joint limit optimization
- Force/torque optimization
- Workspace optimization

## Challenges and Limitations

### Computational Complexity

- Iterative methods require multiple forward kinematics evaluations
- Real-time applications demand efficient algorithms
- Parallel processing can accelerate computations
- Approximation methods trade accuracy for speed

### Solution Quality

- Local minima in numerical methods
- Multiple valid solutions
- Joint limit violations
- Singularity issues

### Real-World Considerations

- Mechanical tolerances and backlash
- Sensor noise and calibration errors
- Dynamic effects at high speeds
- Actuator limitations

## Summary

Inverse kinematics is a fundamental problem in robotics that enables the control of robot manipulators in Cartesian space. While analytical solutions exist for specific robot geometries, numerical methods provide general solutions for arbitrary robot configurations. Modern implementations must address singularities, handle redundant systems, and operate efficiently for real-time applications. Understanding both analytical and numerical approaches is essential for developing robust robotic systems.