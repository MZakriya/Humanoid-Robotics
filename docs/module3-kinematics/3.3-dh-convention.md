# 3.3 Denavit-Hartenberg Convention

## Overview

The Denavit-Hartenberg (DH) convention is a systematic method for defining coordinate frames on the links of a serial manipulator. Developed by Jacques Denavit and Richard Hartenberg in 1955, this convention provides a standardized approach to describe the kinematic structure of robotic mechanisms. The DH parameters enable the mathematical representation of robot kinematics in a compact and consistent form.

## Historical Context and Development

The DH convention emerged from the need to standardize the description of kinematic chains in robotics and mechanical engineering. Before DH, different researchers used various ad-hoc methods to assign coordinate frames, leading to confusion and inconsistency. The convention provides a universal framework that has become the standard in robotics education and industry.

## DH Parameter Definition

The DH convention defines four parameters for each joint-link pair in a kinematic chain:

1. **aᵢ (link length)**: Distance along the xᵢ axis from zᵢ to zᵢ₊₁
2. **αᵢ (link twist)**: Angle from zᵢ to zᵢ₊₁ measured about xᵢ
3. **dᵢ (link offset)**: Distance along the zᵢ axis from xᵢ₋₁ to xᵢ
4. **θᵢ (joint angle)**: Angle from xᵢ₋₁ to xᵢ measured about zᵢ

These parameters completely describe the relative position and orientation between consecutive coordinate frames.

## DH Frame Assignment Rules

### Step-by-Step Assignment Process

1. **Establish the z-axis**: The zᵢ axis is aligned with the joint axis of motion (rotation or translation)

2. **Establish the x-axis**: The xᵢ axis is along the common normal from zᵢ to zᵢ₊₁, directed from zᵢ toward zᵢ₊₁

3. **Establish the y-axis**: The yᵢ axis completes the right-handed coordinate system: yᵢ = zᵢ × xᵢ

4. **Handle special cases**: When zᵢ and zᵢ₊₁ are parallel, xᵢ can be chosen as the vector perpendicular to both axes passing through the closest points

### Practical Assignment Guidelines

- For revolute joints: θᵢ is variable, other parameters are constant
- For prismatic joints: dᵢ is variable, other parameters are constant
- Joint 1 is typically the base joint, joint n is the end-effector
- Frame 0 is usually attached to the base of the robot
- Frame n is typically located at the end-effector

## DH Transformation Matrix

The homogeneous transformation matrix from frame i-1 to frame i is given by:

```
T_i^(i-1) = Rot(z, θᵢ) × Trans(z, dᵢ) × Trans(x, aᵢ) × Rot(x, αᵢ)
```

Which expands to:

```
     | cos(θᵢ)   -sin(θᵢ)cos(αᵢ)   sin(θᵢ)sin(αᵢ)   aᵢcos(θᵢ) |
T =  | sin(θᵢ)    cos(θᵢ)cos(αᵢ)  -cos(θᵢ)sin(αᵢ)   aᵢsin(θᵢ) |
     | 0          sin(αᵢ)          cos(αᵢ)          dᵢ       |
     | 0          0                0                1        |
```

## DH Parameter Tables

### Standard DH Parameter Table Format

| i | θᵢ    | dᵢ    | aᵢ    | αᵢ    | Type |
|---|-------|-------|-------|-------|------|
| 1 | θ₁    | d₁    | a₁    | α₁    | R/P  |
| 2 | θ₂    | d₂    | a₂    | α₂    | R/P  |
| 3 | θ₃    | d₃    | a₃    | α₃    | R/P  |

Where R = Revolute joint, P = Prismatic joint

### Example: PUMA 560 Robot

| i | θᵢ        | dᵢ    | aᵢ     | αᵢ     | Type |
|---|-----------|-------|--------|--------|------|
| 1 | θ₁        | 0     | 0      | -90°   | R    |
| 2 | θ₂        | 0     | a₂     | 0°     | R    |
| 3 | θ₃        | d₃    | 0      | 90°    | R    |
| 4 | θ₄        | d₄    | 0      | -90°   | R    |
| 5 | θ₅        | 0     | 0      | 90°    | R    |
| 6 | θ₆        | d₆    | 0      | 0°     | R    |

## Modified DH Convention

The modified DH convention, proposed by Craig, changes the frame assignment rules:

### Modified Assignment Rules

1. xᵢ is along the common normal from zᵢ to zᵢ₊₁
2. zᵢ is along the joint axis
3. Frame i is attached to joint i (not joint i+1)

### Modified Parameters

- **θᵢ**: Angle from xᵢ₋₁ to xᵢ about zᵢ₋₁
- **dᵢ**: Distance from origin of frame i-1 to intersection of xᵢ with zᵢ₋₁ along zᵢ₋₁
- **aᵢ**: Distance from intersection of xᵢ with zᵢ₋₁ to origin of frame i along xᵢ
- **αᵢ**: Angle from zᵢ₋₁ to zᵢ about xᵢ

## Implementation Examples

### Python Implementation for DH Parameter Processing

```python
import numpy as np

class DHParameters:
    def __init__(self, dh_table):
        """
        Initialize with DH parameter table
        dh_table: List of tuples (theta, d, a, alpha, joint_type)
        joint_type: 'R' for revolute, 'P' for prismatic
        """
        self.dh_table = dh_table

    def dh_transform(self, theta, d, a, alpha):
        """
        Calculate DH transformation matrix
        """
        ct = np.cos(theta)
        st = np.sin(theta)
        ca = np.cos(alpha)
        sa = np.sin(alpha)

        T = np.array([
            [ct, -st*ca, st*sa, a*ct],
            [st, ct*ca, -ct*sa, a*st],
            [0, sa, ca, d],
            [0, 0, 0, 1]
        ])
        return T

    def forward_kinematics(self, joint_angles):
        """
        Calculate forward kinematics using DH parameters
        """
        T_total = np.eye(4)

        for i, (theta_fixed, d_fixed, a, alpha, joint_type) in enumerate(self.dh_table):
            if joint_type == 'R':
                theta = theta_fixed + joint_angles[i]  # Add joint variable
                d = d_fixed
            elif joint_type == 'P':
                theta = theta_fixed
                d = d_fixed + joint_angles[i]  # Add joint variable
            else:
                raise ValueError(f"Invalid joint type: {joint_type}")

            T_i = self.dh_transform(theta, d, a, alpha)
            T_total = T_total @ T_i

        return T_total

    def jacobian(self, joint_angles):
        """
        Calculate geometric Jacobian using DH parameters
        """
        n = len(joint_angles)
        J = np.zeros((6, n))

        # Calculate all transformation matrices
        T_all = [np.eye(4)]  # T_0^0
        T_current = np.eye(4)

        for i, (theta_fixed, d_fixed, a, alpha, joint_type) in enumerate(self.dh_table):
            if joint_type == 'R':
                theta = theta_fixed + joint_angles[i]
                d = d_fixed
            else:  # Prismatic
                theta = theta_fixed
                d = d_fixed + joint_angles[i]

            T_i = self.dh_transform(theta, d, a, alpha)
            T_current = T_current @ T_i
            T_all.append(T_current)

        # End-effector position and orientation
        T_end = T_all[-1]
        o_n = T_end[:3, 3]  # End-effector position

        # Calculate Jacobian columns
        for i in range(n):
            T_i = T_all[i]
            o_i = T_i[:3, 3]  # Position of frame i

            if self.dh_table[i][4] == 'R':  # Revolute joint
                z_i = T_i[:3, 2]  # z-axis of frame i
                J[:3, i] = np.cross(z_i, o_n - o_i)  # Linear velocity
                J[3:, i] = z_i  # Angular velocity
            else:  # Prismatic joint
                z_i = T_i[:3, 2]  # z-axis of frame i
                J[:3, i] = z_i  # Linear velocity
                J[3:, i] = np.zeros(3)  # Angular velocity = 0

        return J

# Example usage for a 3-DOF planar manipulator
dh_table_planar = [
    (0, 0, 1, 0, 'R'),  # Link 1: a=1, revolute
    (0, 0, 1, 0, 'R'),  # Link 2: a=1, revolute
    (0, 0, 0.5, 0, 'R')  # Link 3: a=0.5, revolute
]

robot = DHParameters(dh_table_planar)
joint_angles = [np.pi/4, np.pi/6, -np.pi/3]
end_pose = robot.forward_kinematics(joint_angles)
jacobian = robot.jacobian(joint_angles)

print("End-effector pose:")
print(end_pose)
print("\nJacobian matrix:")
print(jacobian)
```

### C++ Implementation

```cpp
#include <vector>
#include <array>
#include <cmath>
#include <iostream>

class DHParameters {
public:
    struct JointParams {
        double theta;     // Joint angle (variable for revolute)
        double d;         // Link offset (variable for prismatic)
        double a;         // Link length
        double alpha;     // Link twist
        char joint_type;  // 'R' for revolute, 'P' for prismatic
    };

    DHParameters(const std::vector<JointParams>& dh_table)
        : dh_table_(dh_table) {}

    std::array<std::array<double, 4>, 4> dh_transform(double theta, double d, double a, double alpha) {
        double ct = cos(theta);
        double st = sin(theta);
        double ca = cos(alpha);
        double sa = sin(alpha);

        std::array<std::array<double, 4>, 4> T = {{
            {{ct, -st*ca, st*sa, a*ct}},
            {{st, ct*ca, -ct*sa, a*st}},
            {{0, sa, ca, d}},
            {{0, 0, 0, 1}}
        }};

        return T;
    }

    std::array<std::array<double, 4>, 4> forward_kinematics(const std::vector<double>& joint_angles) {
        std::array<std::array<double, 4>, 4> T_total = identity_matrix();

        for (size_t i = 0; i < dh_table_.size(); ++i) {
            double theta, d;
            if (dh_table_[i].joint_type == 'R') {
                theta = dh_table_[i].theta + joint_angles[i];
                d = dh_table_[i].d;
            } else { // Prismatic
                theta = dh_table_[i].theta;
                d = dh_table_[i].d + joint_angles[i];
            }

            auto T_i = dh_transform(theta, d, dh_table_[i].a, dh_table_[i].alpha);
            T_total = matrix_multiply(T_total, T_i);
        }

        return T_total;
    }

private:
    std::vector<JointParams> dh_table_;

    std::array<std::array<double, 4>, 4> identity_matrix() {
        std::array<std::array<double, 4>, 4> I = {};
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                I[i][j] = (i == j) ? 1.0 : 0.0;
            }
        }
        return I;
    }

    std::array<std::array<double, 4>, 4> matrix_multiply(
        const std::array<std::array<double, 4>, 4>& A,
        const std::array<std::array<double, 4>, 4>& B) {

        std::array<std::array<double, 4>, 4> C = {};
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                C[i][j] = 0;
                for (int k = 0; k < 4; ++k) {
                    C[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        return C;
    }
};
```

## Common DH Configurations

### 2-DOF Planar Manipulator

| i | θᵢ    | dᵢ | aᵢ | αᵢ | Type |
|---|-------|----|----|----|------|
| 1 | θ₁    | 0  | a₁ | 0° | R    |
| 2 | θ₂    | 0  | a₂ | 0° | R    |

### 3-DOF Cylindrical Robot

| i | θᵢ    | dᵢ    | aᵢ | αᵢ  | Type |
|---|-------|-------|----|-----|------|
| 1 | θ₁    | d₁    | 0  | 0°  | R/P  |
| 2 | 0     | d₂    | 0  | -90°| P    |
| 3 | 0     | d₃    | 0  | 0°  | P    |

### 6-DOF Articulated Robot (PUMA-like)

| i | θᵢ    | dᵢ    | aᵢ    | αᵢ     | Type |
|---|-------|-------|-------|--------|------|
| 1 | θ₁    | d₁    | 0     | -90°   | R    |
| 2 | θ₂    | 0     | a₂    | 0°     | R    |
| 3 | θ₃    | d₃    | 0     | 90°    | R    |
| 4 | θ₄    | d₄    | 0     | -90°   | R    |
| 5 | θ₅    | 0     | 0     | 90°    | R    |
| 6 | θ₆    | d₆    | 0     | 0°     | R    |

## Advantages and Limitations

### Advantages

- **Standardization**: Provides a consistent method for describing robot kinematics
- **Compact representation**: Uses only 4 parameters per joint-link pair
- **Systematic approach**: Well-defined procedure for frame assignment
- **Mathematical foundation**: Enables analytical solutions for kinematics
- **Software compatibility**: Widely supported in robotics software packages

### Limitations

- **Complexity for parallel mechanisms**: Not well-suited for closed-loop kinematic chains
- **Singular configurations**: Certain joint arrangements make frame assignment ambiguous
- **Non-unique solutions**: Multiple DH parameter sets can describe the same mechanism
- **Computational overhead**: Requires trigonometric calculations for each transformation

## Advanced Topics

### DH Parameters for Redundant Robots

For robots with more than 6 DOF, the DH convention scales naturally:

- Each additional joint adds one more row to the DH parameter table
- The transformation chain continues with additional matrices
- Inverse kinematics becomes more complex but remains systematically solvable

### DH Parameters for Mobile Robots

The DH convention can be extended to mobile robots by treating base motion as additional joints:

- Planar mobile base: 3 DOF (x, y, θ)
- Omnidirectional base: Additional DOF for wheel orientations
- Ackermann steering: Non-holonomic constraints require special treatment

## Troubleshooting Common Issues

### Frame Assignment Errors

**Problem**: Inconsistent frame orientations
**Solution**: Verify right-hand rule compliance and consistent z-axis alignment

**Problem**: Negative link lengths or twists
**Solution**: Check that x-axis points from zᵢ to zᵢ₊₁ along the common normal

### Singular Configuration Handling

**Problem**: Parallel or coincident joint axes
**Solution**: Use alternative frame assignment rules or switch to alternative parameterizations

## Practical Applications

### Robot Simulation

DH parameters enable accurate simulation of robot kinematics in software environments like Gazebo, V-REP, or custom simulators.

### Robot Control

Real-time control systems use DH parameters for:
- Forward kinematics computation
- Jacobian calculation
- Trajectory planning in joint space
- Singularity detection and avoidance

### Robot Design

DH parameters assist in:
- Kinematic structure optimization
- Workspace analysis
- Singularity-free zone identification
- Mechanical design validation

## Summary

The Denavit-Hartenberg convention provides a systematic and mathematically rigorous approach to describing the kinematic structure of serial manipulators. Despite some limitations, it remains the standard method for robot kinematics in both academic and industrial applications. Understanding DH parameters is essential for anyone working with robotic systems, as it forms the foundation for more advanced kinematic and dynamic analysis.