# 3.5 Kinematic Chains

## Overview

Kinematic chains form the structural foundation of robotic mechanisms, defining how rigid bodies (links) are interconnected through joints to create systems capable of controlled motion. Understanding kinematic chains is essential for robot design, analysis, and control. This chapter explores the mathematical representation, classification, and analysis of various kinematic chain configurations used in robotics.

## Basic Concepts and Terminology

### Definitions

- **Link**: A rigid body that connects joints in a kinematic chain
- **Joint**: A connection between two links that allows relative motion
- **Kinematic Chain**: An assembly of links connected by joints
- **End-Effector**: The terminal element of a kinematic chain that interacts with the environment
- **Base**: The fixed or grounded link that anchors the kinematic chain

### Joint Classification

**Revolute Joint (R)**: Allows rotation about a single axis
- Degrees of freedom: 1 (rotational)
- Variables: Joint angle θ
- Example: Elbow, shoulder joint

**Prismatic Joint (P)**: Allows linear translation along a single axis
- Degrees of freedom: 1 (translational)
- Variables: Joint displacement d
- Example: Linear actuator, telescoping mechanism

**Helical Joint (H)**: Combines rotation and translation
- Degrees of freedom: 1
- Relationship: Linear motion proportional to rotation
- Example: Screw mechanism

**Cylindrical Joint (C)**: Combines rotation and translation along same axis
- Degrees of freedom: 2
- Example: Adjustable-height chair mechanism

**Spherical Joint (S)**: Allows rotation about three intersecting axes
- Degrees of freedom: 3
- Example: Ball-and-socket joint

**Planar Joint**: Allows motion in a plane
- Degrees of freedom: 3 (2 translations + 1 rotation)
- Example: Slider-crank mechanisms

## Degrees of Freedom Analysis

### Grubler's Formula

For a mechanism in 3D space:
```
DOF = λ(n - j - 1) + Σ(fᵢ)
```

Where:
- λ = degrees of freedom of the space (6 for spatial, 3 for planar)
- n = number of links (including ground)
- j = number of joints
- fᵢ = degrees of freedom of joint i

### Kutzbach Criterion

For a planar mechanism:
```
DOF = 3(n - 1) - 2j₁ - j₂
```

Where:
- n = number of links
- j₁ = number of 1-DOF joints
- j₂ = number of 2-DOF joints

### Mobility Analysis

```python
def calculate_mobility(links, joints, joint_dof_list, space_dimension=6):
    """
    Calculate degrees of freedom using Grubler's formula
    """
    n = links  # number of links
    j = joints  # number of joints
    total_joint_dof = sum(joint_dof_list)  # sum of all joint DOFs

    dof = space_dimension * (n - j - 1) + total_joint_dof
    return dof

def planar_mobility(links, single_dof_joints, double_dof_joints):
    """
    Calculate mobility for planar mechanisms
    """
    return 3 * (links - 1) - 2 * single_dof_joints - double_dof_joints

# Example: 6-DOF manipulator
# 7 links (including base), 6 revolute joints
links_6dof = 7
joints_6dof = 6
joint_dofs = [1] * 6  # 6 revolute joints (1 DOF each)

dof_6dof = calculate_mobility(links_6dof, joints_6dof, joint_dofs)
print(f"6-DOF manipulator DOF: {dof_6dof}")  # Should be 6
```

## Kinematic Chain Classification

### Serial Chains

In serial kinematic chains, each link is connected to at most two other links, forming a single path from base to end-effector.

**Advantages:**
- Simple kinematic structure
- Large workspace
- Easy trajectory planning
- Lower cost and complexity

**Disadvantages:**
- Lower stiffness and load capacity
- Accumulation of errors along the chain
- Lower accuracy compared to parallel mechanisms

**Common Configurations:**

1. **Cartesian Robot**: PPP configuration
2. **Cylindrical Robot**: PPR or RPP configuration
3. **Spherical Robot**: RRP configuration
4. **Articulated Robot**: RRR configuration (with varying numbers of joints)

### Parallel Chains

In parallel kinematic chains, the end-effector is connected to the base through multiple independent kinematic chains.

**Advantages:**
- Higher stiffness and load capacity
- Better accuracy and precision
- Lower moving mass
- Better dynamic performance

**Disadvantages:**
- Complex kinematics
- Limited workspace
- Potential for singularities
- Higher cost and complexity

**Common Configurations:**

1. **Stewart Platform**: 6 legs with universal-spherical-universal joints
2. **Delta Robot**: 3 parallel arms with parallelograms
3. **Tripod**: 3 prismatic actuators

### Hybrid Chains

Combination of serial and parallel elements:
- Multiple parallel mechanisms connected in series
- Serial chains with parallel actuation
- Variable geometry structures

## Forward Kinematics of Kinematic Chains

### Product of Exponentials Formula

For a serial chain, the end-effector pose can be expressed as:

```
g_st(θ) = e^[ξ₁]θ₁ * g₁ * e^[ξ₂]θ₂ * g₂ * ... * e^[ξₙ]θₙ * gₙ
```

Where:
- g_st is the end-effector pose relative to the base
- e^[ξᵢ]θᵢ represents the exponential coordinates for joint i
- ξᵢ represents the screw axis for joint i
- gᵢ represents the initial pose of link i

### Implementation of Forward Kinematics

```python
import numpy as np

class KinematicChain:
    def __init__(self, dh_parameters):
        """
        Initialize kinematic chain with DH parameters
        dh_parameters: List of tuples (a, alpha, d, theta_offset, joint_type)
        joint_type: 'R' for revolute, 'P' for prismatic
        """
        self.dh_params = dh_parameters

    def dh_transform(self, a, alpha, d, theta):
        """Calculate DH transformation matrix"""
        ct, st = np.cos(theta), np.sin(theta)
        ca, sa = np.cos(alpha), np.sin(alpha)

        T = np.array([
            [ct, -st*ca, st*sa, a*ct],
            [st, ct*ca, -ct*sa, a*st],
            [0, sa, ca, d],
            [0, 0, 0, 1]
        ])
        return T

    def forward_kinematics(self, joint_angles):
        """Calculate forward kinematics for the entire chain"""
        T_total = np.eye(4)

        for i, (a, alpha, d, theta_offset, joint_type) in enumerate(self.dh_params):
            if joint_type == 'R':
                theta = theta_offset + joint_angles[i]
                d_eff = d
            else:  # Prismatic
                theta = theta_offset
                d_eff = d + joint_angles[i]

            T_i = self.dh_transform(a, alpha, d_eff, theta)
            T_total = T_total @ T_i

        return T_total

    def get_link_poses(self, joint_angles):
        """Get transformation matrices for all links"""
        poses = [np.eye(4)]  # Base frame
        T_current = np.eye(4)

        for i, (a, alpha, d, theta_offset, joint_type) in enumerate(self.dh_params):
            if joint_type == 'R':
                theta = theta_offset + joint_angles[i]
                d_eff = d
            else:
                theta = theta_offset
                d_eff = d + joint_angles[i]

            T_i = self.dh_transform(a, alpha, d_eff, theta)
            T_current = T_current @ T_i
            poses.append(T_current)

        return poses
```

## Inverse Kinematics of Kinematic Chains

### Closed-Form Solutions

For specific chain configurations, analytical inverse kinematics solutions exist:

```python
def inverse_kinematics_3dof_planar(x, y, l1, l2, l3):
    """
    Analytical inverse kinematics for 3-DOF planar manipulator
    """
    # Calculate position of joint 2
    target_dist = np.sqrt(x**2 + y**2)

    # Check workspace boundaries
    max_reach = l1 + l2 + l3
    min_reach = abs(l1 - l2) + l3 if abs(l1 - l2) > l3 else l3 - abs(l1 - l2)

    if target_dist > max_reach:
        raise ValueError("Target position is outside workspace")
    if target_dist < min_reach:
        raise ValueError("Target position is inside workspace boundary")

    # Calculate joint 2 angle using law of cosines
    cos_theta2 = (l1**2 + l2**2 - target_dist**2) / (2 * l1 * l2)
    cos_theta2 = np.clip(cos_theta2, -1, 1)  # Clamp to valid range
    theta2 = np.arccos(cos_theta2)

    # Calculate intermediate angles
    k1 = l1 + l2 * np.cos(theta2)
    k2 = l2 * np.sin(theta2)

    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)

    # For 3-DOF, theta3 can be used for orientation
    theta3 = 0  # Assuming no orientation requirement

    return np.array([theta1, theta2, theta3])

def inverse_kinematics_6dof_puma(x, y, z, nx, ny, nz, ox, oy, oz):
    """
    Analytical inverse kinematics for 6-DOF PUMA-like robot
    """
    # PUMA configuration: RRP RRR (spherical wrist)
    l1, l2, l3 = 1.0, 1.0, 0.5  # Example link lengths

    # Step 1: Position inverse kinematics (first 3 joints)
    # Calculate wrist center position
    wx = x - l3 * nx  # l3 offset along approach vector
    wy = y - l3 * ny
    wz = z - l3 * nz

    # Joint 1: θ1 = atan2(wy, wx) with two solutions
    theta1 = np.arctan2(wy, wx)

    # Calculate distance from joint 1 to wrist center
    r = np.sqrt(wx**2 + wy**2)
    d = wz - l1  # l1 is height of first joint

    # Calculate joint 2 and 3
    D = (r**2 + d**2 - l2**2 - l3**2) / (2 * l2 * l3)
    D = np.clip(D, -1, 1)
    theta3 = np.arctan2(np.sqrt(1 - D**2), D)  # Elbow up configuration

    # Calculate theta2
    theta2 = np.arctan2(d, r) - np.arctan2(l3 * np.sin(theta3),
                                          l2 + l3 * np.cos(theta3))

    # Step 2: Orientation inverse kinematics (last 3 joints)
    # Calculate transformation matrices for first 3 joints
    T01 = dh_transform(0, -np.pi/2, l1, theta1)
    T12 = dh_transform(l2, 0, 0, theta2)
    T23 = dh_transform(l3, 0, 0, theta3)

    T03 = T01 @ T12 @ T13

    # Calculate rotation matrix from 3rd frame to end-effector
    R36 = T03[:3, :3].T @ np.array([[nx, ox, ax], [ny, oy, ay], [nz, oz, az]])

    # Extract Euler angles (assuming ZYX Euler angles)
    theta4 = np.arctan2(R36[1, 2], R36[0, 2])
    theta5 = np.arctan2(np.sqrt(R36[0, 2]**2 + R36[1, 2]**2), R36[2, 2])
    theta6 = np.arctan2(R36[2, 1], -R36[2, 0])

    return np.array([theta1, theta2, theta3, theta4, theta5, theta6])
```

### Numerical Methods for General Chains

```python
def numerical_inverse_kinematics(chain, target_pose, initial_guess, max_iterations=100):
    """
    Numerical inverse kinematics using Newton-Raphson method
    """
    q = initial_guess.copy()

    for iteration in range(max_iterations):
        # Calculate current pose
        current_pose = chain.forward_kinematics(q)

        # Calculate pose error
        error = calculate_pose_error(current_pose, target_pose)

        # Check convergence
        if np.linalg.norm(error) < 1e-6:
            break

        # Calculate Jacobian
        J = calculate_jacobian_numerical(chain, q)

        # Update joint angles using pseudoinverse
        dq = np.linalg.pinv(J) @ error
        q = q + 0.1 * dq  # Step size to ensure stability

    return q

def calculate_pose_error(current_pose, target_pose):
    """
    Calculate pose error combining position and orientation
    """
    # Position error
    pos_error = target_pose[:3, 3] - current_pose[:3, 3]

    # Orientation error using rotation matrix difference
    R_current = current_pose[:3, :3]
    R_target = target_pose[:3, :3]

    # Calculate rotation error as skew-symmetric matrix
    R_error = R_target @ R_current.T
    if np.allclose(R_error, np.eye(3)):
        # For small rotations, use linear approximation
        rotation_error = np.array([
            R_error[2, 1] - R_error[1, 2],  # rx
            R_error[0, 2] - R_error[2, 0],  # ry
            R_error[1, 0] - R_error[0, 1]   # rz
        ]) * 0.5
    else:
        # More complex rotation error calculation
        trace = np.trace(R_error)
        angle = np.arccos(np.clip((trace - 1) / 2, -1, 1))
        if np.sin(angle) != 0:
            rotation_error = angle / (2 * np.sin(angle)) * np.array([
                R_error[2, 1] - R_error[1, 2],
                R_error[0, 2] - R_error[2, 0],
                R_error[1, 0] - R_error[0, 1]
            ])
        else:
            rotation_error = np.zeros(3)

    return np.concatenate([pos_error, rotation_error])
```

## Workspace Analysis

### Types of Workspace

**Reachable Workspace**: All points that the end-effector can reach, regardless of orientation

**Dexterous Workspace**: All points where the end-effector can reach with arbitrary orientation

**Orientation Workspace**: All orientations that can be achieved at a given position

### Workspace Computation

```python
def compute_workspace(chain, joint_limits, resolution=0.1):
    """
    Compute workspace using discretization method
    """
    from itertools import product

    # Generate joint angle combinations within limits
    joint_ranges = []
    for limits in joint_limits:
        range_values = np.arange(limits[0], limits[1], resolution)
        joint_ranges.append(range_values)

    workspace_points = []

    # Iterate through all joint combinations
    for joint_combo in product(*joint_ranges):
        joint_angles = np.array(joint_combo)
        try:
            pose = chain.forward_kinematics(joint_angles)
            position = pose[:3, 3]
            workspace_points.append(position)
        except:
            continue  # Skip invalid configurations

    return np.array(workspace_points)

def compute_workspace_sampling(chain, joint_limits, num_samples=10000):
    """
    Compute workspace using random sampling
    """
    workspace_points = []

    for _ in range(num_samples):
        # Generate random joint angles within limits
        joint_angles = np.array([
            np.random.uniform(limits[0], limits[1])
            for limits in joint_limits
        ])

        try:
            pose = chain.forward_kinematics(joint_angles)
            position = pose[:3, 3]
            workspace_points.append(position)
        except:
            continue

    return np.array(workspace_points)

def visualize_workspace(workspace_points):
    """
    Visualize workspace (would require matplotlib)
    """
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    ax.scatter(
        workspace_points[:, 0],
        workspace_points[:, 1],
        workspace_points[:, 2],
        alpha=0.6, s=1
    )

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title('Robot Workspace')

    plt.show()
```

## Special Chain Configurations

### Closed-Loop Chains

```python
class ClosedLoopChain:
    def __init__(self, open_chain, closure_constraints):
        """
        Kinematic chain with closed-loop constraints
        """
        self.open_chain = open_chain
        self.closure_constraints = closure_constraints

    def solve_closed_loop(self, actuated_joints):
        """
        Solve closed-loop kinematics using constraint equations
        """
        # This is a simplified approach - real implementation would use
        # numerical methods to solve constraint equations
        from scipy.optimize import fsolve

        def constraint_equations(closed_joints):
            # Calculate full chain configuration
            all_joints = self.assemble_joint_vector(actuated_joints, closed_joints)
            pose = self.open_chain.forward_kinematics(all_joints)

            # Return constraint violations
            return self.closure_constraints(pose)

        # Initial guess for closed joints
        initial_guess = np.zeros(self.num_closed_joints)

        # Solve for closed joint angles
        closed_joints = fsolve(constraint_equations, initial_guess)

        return self.assemble_joint_vector(actuated_joints, closed_joints)
```

### Cable-Driven Parallel Robots

```python
class CableDrivenRobot:
    def __init__(self, anchor_points, end_effector_points):
        """
        Cable-driven parallel robot model
        anchor_points: positions where cables attach to frame
        end_effector_points: positions where cables attach to end-effector
        """
        self.anchor_points = np.array(anchor_points)
        self.end_effector_points = np.array(end_effector_points)
        self.num_cables = len(anchor_points)

    def forward_kinematics(self, cable_lengths):
        """
        Forward kinematics for cable-driven robot
        This is a complex problem requiring numerical solution
        """
        # For cable robots, forward kinematics is highly non-linear
        # and typically requires numerical methods
        from scipy.optimize import minimize

        def position_error(xyzrpy):
            # Calculate cable lengths for given pose
            calculated_lengths = self.calculate_cable_lengths(xyzrpy)
            # Return error between calculated and actual lengths
            return np.sum((calculated_lengths - cable_lengths)**2)

        # Initial guess and optimization
        initial_guess = np.zeros(6)  # [x, y, z, roll, pitch, yaw]
        result = minimize(position_error, initial_guess)

        return result.x

    def calculate_cable_lengths(self, pose):
        """
        Calculate cable lengths for given end-effector pose
        """
        # This would involve applying the pose transformation to
        # end-effector attachment points and calculating distances
        # to frame anchor points
        pass
```

## Redundant Kinematic Chains

### Redundancy Resolution

```python
def resolve_redundancy(jacobian, desired_task, null_task=None, joint_limits=None):
    """
    Resolve redundancy in kinematic chains
    """
    # Primary task using pseudoinverse
    jacobian_pinv = np.linalg.pinv(jacobian)
    primary_solution = jacobian_pinv @ desired_task

    # Null space projector
    I = np.eye(jacobian.shape[1])
    null_projector = I - jacobian_pinv @ jacobian

    # Add null space task if provided
    if null_task is not None:
        redundant_solution = primary_solution + null_projector @ null_task
    else:
        # Minimize joint velocities by adding null space motion
        null_motion = np.zeros(jacobian.shape[1])

        # Example: joint limit avoidance in null space
        if joint_limits is not None:
            null_motion = avoid_joint_limits_in_null_space(
                null_projector, joint_limits
            )

        redundant_solution = primary_solution + null_projector @ null_motion

    return redundant_solution

def avoid_joint_limits_in_null_space(null_projector, joint_limits, current_joints):
    """
    Generate null space motion to avoid joint limits
    """
    joint_avoidance = np.zeros(len(current_joints))

    for i, (current, (lower, upper)) in enumerate(zip(current_joints, joint_limits)):
        # Calculate distance to limits
        dist_to_lower = current - lower
        dist_to_upper = upper - current

        # Generate motion away from close limits
        if dist_to_lower < 0.1:  # Close to lower limit
            joint_avoidance[i] = 1.0
        elif dist_to_upper < 0.1:  # Close to upper limit
            joint_avoidance[i] = -1.0

    return null_projector @ joint_avoidance
```

## Applications in Robotics

### Humanoid Robot Kinematic Chains

```python
class HumanoidRobot:
    def __init__(self):
        # Define kinematic chains for different body parts
        self.left_arm = KinematicChain(self.get_left_arm_dh_params())
        self.right_arm = KinematicChain(self.get_right_arm_dh_params())
        self.left_leg = KinematicChain(self.get_left_leg_dh_params())
        self.right_leg = KinematicChain(self.get_right_leg_dh_params())
        self.torso = KinematicChain(self.get_torso_dh_params())

    def full_body_forward_kinematics(self, joint_angles):
        """
        Calculate forward kinematics for entire humanoid robot
        """
        results = {}

        # Calculate for each chain
        results['left_arm'] = self.left_arm.forward_kinematics(
            joint_angles['left_arm']
        )
        results['right_arm'] = self.right_arm.forward_kinematics(
            joint_angles['right_arm']
        )
        results['left_leg'] = self.left_leg.forward_kinematics(
            joint_angles['left_leg']
        )
        results['right_leg'] = self.right_leg.forward_kinematics(
            joint_angles['right_leg']
        )
        results['torso'] = self.torso.forward_kinematics(
            joint_angles['torso']
        )

        return results

    def center_of_mass(self, joint_angles, link_masses):
        """
        Calculate center of mass of humanoid robot
        """
        # Calculate poses of all links
        all_poses = self.full_body_forward_kinematics(joint_angles)

        total_mass = sum(link_masses.values())
        weighted_sum = np.zeros(3)

        for chain_name, poses in all_poses.items():
            for i, pose in enumerate(poses):
                if f"{chain_name}_link_{i}" in link_masses:
                    mass = link_masses[f"{chain_name}_link_{i}"]
                    position = pose[:3, 3]  # Extract position
                    weighted_sum += mass * position

        center_of_mass = weighted_sum / total_mass
        return center_of_mass
```

### Parallel Manipulator Control

```python
class StewartPlatform:
    def __init__(self, base_points, platform_points):
        """
        Stewart Platform (6-DOF parallel manipulator)
        """
        self.base_points = np.array(base_points)  # Fixed base attachment points
        self.platform_points = np.array(platform_points)  # Moving platform attachment points
        self.num_legs = 6

    def inverse_kinematics(self, platform_pose):
        """
        Calculate leg lengths for desired platform pose
        """
        R = platform_pose[:3, :3]  # Rotation matrix
        p = platform_pose[:3, 3]   # Position vector

        # Transform platform attachment points to global frame
        global_platform_points = []
        for point in self.platform_points:
            global_point = R @ point + p
            global_platform_points.append(global_point)

        leg_lengths = []
        for i in range(self.num_legs):
            # Calculate length as distance between base and platform points
            length = np.linalg.norm(
                global_platform_points[i] - self.base_points[i]
            )
            leg_lengths.append(length)

        return np.array(leg_lengths)

    def forward_kinematics(self, leg_lengths):
        """
        Calculate platform pose from leg lengths (complex problem)
        """
        # This requires solving a system of nonlinear equations
        # Each leg length defines a sphere, and the platform pose
        # is where all spheres intersect appropriately
        from scipy.optimize import minimize

        def pose_error(pose_vector):
            # Extract position and rotation parameters
            pos = pose_vector[:3]
            angles = pose_vector[3:]

            # Convert to rotation matrix (simplified - would need proper conversion)
            R = euler_to_rotation_matrix(angles)

            # Calculate current leg lengths for this pose
            current_lengths = self.inverse_kinematics(
                np.hstack([np.hstack([R, pos.reshape(3,1)]), [[0, 0, 0, 1]]])
            )

            # Return error between desired and calculated lengths
            return np.sum((current_lengths - leg_lengths)**2)

        # Initial guess and optimization
        initial_guess = np.zeros(6)  # [x, y, z, rx, ry, rz]
        result = minimize(pose_error, initial_guess, method='BFGS')

        # Convert result back to pose matrix
        final_pos = result.x[:3]
        final_angles = result.x[3:]
        final_R = euler_to_rotation_matrix(final_angles)

        return np.hstack([np.hstack([final_R, final_pos.reshape(3,1)]), [[0, 0, 0, 1]]])
```

## Summary

Kinematic chains form the fundamental building blocks of robotic systems, determining their mobility, workspace, and capabilities. Understanding the mathematical representation, analysis methods, and solution techniques for both serial and parallel chains is essential for robotic system design and control. The choice of kinematic chain topology significantly impacts the robot's performance characteristics, and modern robotics often combines multiple chain types to achieve complex manipulation and locomotion capabilities.