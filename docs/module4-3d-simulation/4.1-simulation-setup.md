---
title: Simulation Setup
sidebar_label: Simulation Setup
description: Setting up 3D simulation environments for humanoid robotics development
---

# 4.1 Simulation Setup

## Overview

Simulation environments are critical for humanoid robotics development, providing safe, cost-effective, and repeatable testing platforms. This chapter covers the setup and configuration of 3D simulation environments, focusing on Gazebo and Unity for humanoid robot development. We'll explore the installation process, configuration requirements, and initial setup procedures.

## Simulation Environment Selection

### Gazebo vs Unity vs Other Platforms

When choosing a simulation environment for humanoid robotics, several factors must be considered:

**Gazebo:**
- **Pros:** Open-source, integrated with ROS/ROS2, physics-accurate, widely adopted in robotics research
- **Cons:** Limited visual fidelity, less intuitive for complex scenarios
- **Best for:** Research, algorithm testing, ROS-based development

**Unity:**
- **Pros:** High visual fidelity, intuitive interface, extensive asset library, cross-platform
- **Cons:** Commercial license required, less integrated with robotics frameworks
- **Best for:** Visualization, human-in-the-loop testing, game-like scenarios

**Other Options:**
- **Webots:** Open-source, beginner-friendly, good documentation
- **Mujoco:** High-fidelity physics, commercial license required
- **PyBullet:** Python-friendly, good for deep learning applications

## Gazebo Setup

### Installation Requirements

```bash
# Ubuntu/Debian installation
sudo apt update
sudo apt install gazebo libgazebo-dev

# For ROS2 integration
sudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-plugins
```

### Basic Configuration

```xml
<!-- Example .sdf file for a simple humanoid robot -->
<?xml version="1.0" ?>
<sdf version="1.7">
  <model name="simple_humanoid">
    <link name="base_link">
      <pose>0 0 1.0 0 0 0</pose>
      <inertial>
        <mass>10.0</mass>
        <inertia>
          <ixx>0.4</ixx>
          <ixy>0.0</ixy>
          <ixz>0.0</ixz>
          <iyy>0.4</iyy>
          <iyz>0.0</iyz>
          <izz>0.2</izz>
        </inertia>
      </inertial>
      <visual name="visual">
        <geometry>
          <box>
            <size>0.5 0.5 0.5</size>
          </box>
        </geometry>
      </visual>
      <collision name="collision">
        <geometry>
          <box>
            <size>0.5 0.5 0.5</size>
          </box>
        </geometry>
      </collision>
    </link>
  </model>
</sdf>
```

### Environment Variables

```bash
# Add to ~/.bashrc for persistent setup
export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:~/humanoid_robotics/models
export GAZEBO_RESOURCE_PATH=$GAZEBO_RESOURCE_PATH:~/humanoid_robotics/worlds
export GAZEBO_PLUGIN_PATH=$GAZEBO_PLUGIN_PATH:~/humanoid_robotics/plugins
```

## Unity Setup for Robotics

### Installation and Configuration

1. **Install Unity Hub:**
   - Download from Unity's official website
   - Install Unity version 2021.3 LTS or later

2. **Install Robotics Packages:**
   - Open Unity Hub and create a new 3D project
   - Go to Window â†’ Package Manager
   - Install "Unity Robotics Hub" and related packages

3. **ROS Integration:**
   - Install Unity Robotics Package (com.unity.robotics.ros-tcp-connector)
   - This enables communication between Unity and ROS/ROS2

### Basic Unity Scene Setup

```csharp
// Example Unity script for robot control
using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using RosMessageTypes.Std;

public class RobotController : MonoBehaviour
{
    private ROSConnection ros;
    private string robotTopic = "robot_command";

    void Start()
    {
        ros = ROSConnection.GetOrCreateInstance();
        ros.RegisterPublisher<UInt8Msg>(robotTopic);
    }

    void Update()
    {
        // Send robot commands based on simulation state
        if (Input.GetKeyDown(KeyCode.Space))
        {
            var command = new UInt8Msg((byte)1);
            ros.Publish(robotTopic, command);
        }
    }
}
```

## Simulation Environment Configuration

### Physics Engine Setup

```python
# Python example for configuring physics parameters
class PhysicsConfiguration:
    def __init__(self):
        self.gravity = [0, 0, -9.81]  # m/s^2
        self.time_step = 0.001  # seconds
        self.max_step_size = 0.01
        self.real_time_update_rate = 1000
        self.max_contacts = 20

    def configure_gazebo(self):
        """Configure Gazebo physics parameters"""
        physics_config = f"""
        <physics type='ode'>
            <max_step_size>{self.max_step_size}</max_step_size>
            <real_time_update_rate>{self.real_time_update_rate}</real_time_update_rate>
            <gravity>{self.gravity[0]} {self.gravity[1]} {self.gravity[2]}</gravity>
        </physics>
        """
        return physics_config

    def configure_unity(self):
        """Configure Unity physics parameters"""
        # In Unity, physics settings are configured via Physics Manager
        # Time.fixedDeltaTime = self.time_step
        # Physics.gravity = new Vector3(0, -9.81f, 0)
        pass
```

### World Setup and Environment Design

```xml
<!-- Example world file with humanoid-specific environment -->
<sdf version="1.7">
  <world name="humanoid_environment">
    <!-- Configure physics -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Add ground plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Add lighting -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Add humanoid robot -->
    <include>
      <uri>model://simple_humanoid</uri>
      <pose>0 0 1 0 0 0</pose>
    </include>

    <!-- Add obstacles for testing -->
    <model name="obstacle_1">
      <pose>2 0 0.5 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry><box><size>0.5 0.5 1.0</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.5 0.5 1.0</size></box></geometry>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

## Sensor Integration in Simulation

### Camera Sensors

```xml
<!-- Example camera sensor configuration -->
<sensor name="camera" type="camera">
  <camera name="head_camera">
    <horizontal_fov>1.047</horizontal_fov>
    <image>
      <width>640</width>
      <height>480</height>
      <format>R8G8B8</format>
    </image>
    <clip>
      <near>0.1</near>
      <far>10.0</far>
    </clip>
  </camera>
  <always_on>1</always_on>
  <update_rate>30</update_rate>
  <visualize>true</visualize>
</sensor>
```

### IMU and Force Sensors

```xml
<!-- IMU sensor configuration -->
<sensor name="imu_sensor" type="imu">
  <always_on>1</always_on>
  <update_rate>100</update_rate>
  <imu>
    <angular_velocity>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.001</stddev>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.001</stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.001</stddev>
        </noise>
      </z>
    </angular_velocity>
    <linear_acceleration>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.017</stddev>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.017</stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.017</stddev>
        </noise>
      </z>
    </linear_acceleration>
  </imu>
</sensor>
```

## Initial Testing and Validation

### Basic Simulation Test

```python
#!/usr/bin/env python3
"""
Basic simulation test to verify setup
"""
import rospy
from sensor_msgs.msg import JointState
from std_msgs.msg import Header

def test_simulation():
    rospy.init_node('simulation_test', anonymous=True)
    pub = rospy.Publisher('/joint_states', JointState, queue_size=10)

    rate = rospy.Rate(10)  # 10 Hz
    joint_names = ['hip_joint', 'knee_joint', 'ankle_joint']

    while not rospy.is_shutdown():
        msg = JointState()
        msg.header = Header()
        msg.header.stamp = rospy.Time.now()
        msg.name = joint_names
        msg.position = [0.0, 0.0, 0.0]  # Initial positions
        msg.velocity = [0.0, 0.0, 0.0]
        msg.effort = [0.0, 0.0, 0.0]

        pub.publish(msg)
        rate.sleep()

if __name__ == '__main__':
    try:
        test_simulation()
    except rospy.ROSInterruptException:
        pass
```

### Verification Checklist

- [ ] Simulation environment installed and running
- [ ] Robot model loads correctly in simulation
- [ ] Basic sensors are publishing data
- [ ] Joint controllers are responding to commands
- [ ] Physics simulation is stable
- [ ] Visualization is working properly

## Performance Optimization

### Simulation Performance Settings

```bash
# Gazebo performance optimization settings
export OGRE_RESOURCE_PATH=/usr/lib/x86_64-linux-gnu/OGRE-1.9.0
export SVGA_VGPU10=0  # Disable hardware acceleration if needed

# For headless operation
export DISPLAY=:0
```

### Multi-threading Configuration

```xml
<!-- Configure Gazebo for multi-threading -->
<world name="multi_threaded_world">
  <physics type="ode">
    <thread_count>4</thread_count>
  </physics>
  <!-- Other world elements -->
</world>
```

## Troubleshooting Common Issues

### Installation Issues

1. **Gazebo won't start:**
   - Check graphics drivers and X11 forwarding
   - Verify OpenGL support: `glxinfo | grep "direct rendering"`
   - Try running with software rendering: `export LIBGL_ALWAYS_SOFTWARE=1`

2. **ROS communication fails:**
   - Verify ROS_MASTER_URI is set correctly
   - Check network connectivity between ROS nodes
   - Ensure correct package paths are set

3. **Physics instability:**
   - Reduce time step size
   - Adjust solver parameters
   - Check mass and inertia values

### Performance Issues

- **Slow simulation:** Reduce visual complexity, increase time step
- **Jittery motion:** Decrease time step, improve controller frequency
- **Memory issues:** Reduce model complexity, optimize collision meshes

## Summary

Setting up a 3D simulation environment for humanoid robotics requires careful configuration of physics parameters, sensor integration, and performance optimization. Whether using Gazebo for research applications or Unity for visualization, proper setup is essential for effective robot development and testing. The next chapter will cover Gazebo integration in detail, including model creation and plugin development.