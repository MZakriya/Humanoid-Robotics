---
title: Gazebo Integration
sidebar_label: Gazebo Integration
description: Integrating humanoid robots with Gazebo simulation environment for advanced robotics development
---

# 4.2 Gazebo Integration

## Overview

Gazebo integration is fundamental for humanoid robotics development, providing a physics-accurate simulation environment with extensive ROS/ROS2 support. This chapter covers the complete integration process, from model creation to plugin development, with a focus on humanoid-specific requirements such as balance simulation, sensor integration, and control interfaces.

## Gazebo Model Structure for Humanoid Robots

### URDF to SDF Conversion

Humanoid robots are typically designed using URDF (Unified Robot Description Format) and then converted or adapted for Gazebo simulation:

```xml
<!-- Example humanoid URDF with Gazebo-specific elements -->
<?xml version="1.0"?>
<robot name="simple_humanoid" xmlns:xacro="http://www.ros.org/wiki/xacro">
  <!-- Links definition -->
  <link name="base_link">
    <inertial>
      <mass value="10.0"/>
      <origin xyz="0 0 0.25" rpy="0 0 0"/>
      <inertia ixx="0.4" ixy="0" ixz="0" iyy="0.4" iyz="0" izz="0.2"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0.25" rpy="0 0 0"/>
      <geometry>
        <box size="0.5 0.5 0.5"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0.25" rpy="0 0 0"/>
      <geometry>
        <box size="0.5 0.5 0.5"/>
      </geometry>
    </collision>
  </link>

  <!-- Hip joint and link -->
  <joint name="hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="hip_link"/>
    <origin xyz="0 0 0.5" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>
  </joint>

  <link name="hip_link">
    <inertial>
      <mass value="2.0"/>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.005"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <geometry>
        <cylinder length="0.2" radius="0.05"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <geometry>
        <cylinder length="0.2" radius="0.05"/>
      </geometry>
    </collision>
  </link>

  <!-- Gazebo-specific elements -->
  <gazebo reference="base_link">
    <material>Gazebo/Blue</material>
    <mu1>0.2</mu1>
    <mu2>0.2</mu2>
  </gazebo>

  <gazebo reference="hip_link">
    <material>Gazebo/Red</material>
    <mu1>0.2</mu1>
    <mu2>0.2</mu2>
  </gazebo>

  <!-- Transmission for ROS control -->
  <transmission name="tran_hip_joint">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="hip_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
    <actuator name="motor_hip_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>
</robot>
```

### Model Directory Structure

```
models/
├── simple_humanoid/
│   ├── model.config
│   └── model.sdf
├── humanoid_world/
│   ├── world.world
│   └── models/
│       ├── ground_plane/
│       └── sun/
```

## Gazebo Plugin Development

### Joint Control Plugin

```cpp
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/transport/transport.hh>
#include <gazebo/msgs/msgs.hh>
#include <thread>

namespace gazebo
{
  class HumanoidJointController : public ModelPlugin
  {
    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
    {
      this->model = _model;

      // Get joints by name
      this->hipJoint = _model->GetJoint("hip_joint");
      this->kneeJoint = _model->GetJoint("knee_joint");
      this->ankleJoint = _model->GetJoint("ankle_joint");

      // Initialize ROS node if available
      if (!ros::isInitialized())
      {
        int argc = 0;
        char **argv = NULL;
        ros::init(argc, argv, "gazebo_client",
                  ros::init_options::NoSigintHandler);
      }

      this->rosNode.reset(new ros::NodeHandle("gazebo_client"));

      // Subscribe to joint commands
      this->rosSub = this->rosNode->subscribe("/joint_commands",
                                             1000,
                                             &HumanoidJointController::OnRosMsg,
                                             this);

      // Listen to the update event
      this->updateConnection = event::Events::ConnectWorldUpdateBegin(
          std::bind(&HumanoidJointController::OnUpdate, this));
    }

    public: void OnRosMsg(const sensor_msgs::JointState::ConstPtr &_msg)
    {
      std::lock_guard<std::mutex> lock(this->mutex);
      for (size_t i = 0; i < _msg->name.size(); ++i)
      {
        this->jointPositions[_msg->name[i]] = _msg->position[i];
      }
    }

    private: void OnUpdate()
    {
      std::lock_guard<std::mutex> lock(this->mutex);

      // Apply joint positions using PID control
      if (this->hipJoint)
        this->hipJoint->SetPosition(0, this->jointPositions["hip_joint"]);
      if (this->kneeJoint)
        this->kneeJoint->SetPosition(0, this->jointPositions["knee_joint"]);
      if (this->ankleJoint)
        this->ankleJoint->SetPosition(0, this->jointPositions["ankle_joint"]);
    }

    private: physics::ModelPtr model;
    private: physics::JointPtr hipJoint, kneeJoint, ankleJoint;
    private: std::unique_ptr<ros::NodeHandle> rosNode;
    private: ros::Subscriber rosSub;
    private: event::ConnectionPtr updateConnection;
    private: std::mutex mutex;
    private: std::map<std::string, double> jointPositions;
  };

  GZ_REGISTER_MODEL_PLUGIN(HumanoidJointController)
}
```

### Sensor Plugin for IMU

```cpp
#include <gazebo/gazebo.hh>
#include <gazebo/sensors/sensors.hh>
#include <gazebo/physics/physics.hh>
#include <ros/ros.h>
#include <sensor_msgs/Imu.h>

namespace gazebo
{
  class HumanoidIMUSensor : public SensorPlugin
  {
    public: virtual void Load(sensors::SensorPtr _sensor, sdf::ElementPtr _sdf)
    {
      // Get the IMU sensor
      this->imuSensor = std::dynamic_pointer_cast<sensors::ImuSensor>(_sensor);
      if (!this->imuSensor)
      {
        gzerr << "HumanoidIMUSensor requires a IMU sensor\n";
        return;
      }

      // Initialize ROS
      if (!ros::isInitialized())
      {
        int argc = 0;
        char **argv = NULL;
        ros::init(argc, argv, "gazebo_imu",
                  ros::init_options::NoSigintHandler);
      }

      this->rosNode.reset(new ros::NodeHandle("gazebo_imu"));
      this->imuPub = this->rosNode->advertise<sensor_msgs::Imu>("/imu/data", 1000);

      // Connect to sensor update event
      this->updateConnection = this->imuSensor->ConnectUpdated(
          std::bind(&HumanoidIMUSensor::OnUpdate, this));

      // Make sure the sensor is active
      this->imuSensor->SetActive(true);
    }

    private: void OnUpdate()
    {
      // Get sensor data
      ignition::math::Vector3d linearAccel = this->imuSensor->LinearAcceleration();
      ignition::math::Vector3d angularVel = this->imuSensor->AngularVelocity();
      ignition::math::Quaterniond orientation = this->imuSensor->Orientation();

      // Create and publish ROS message
      sensor_msgs::Imu imuMsg;
      imuMsg.header.stamp = ros::Time::now();
      imuMsg.header.frame_id = "imu_link";

      imuMsg.linear_acceleration.x = linearAccel.X();
      imuMsg.linear_acceleration.y = linearAccel.Y();
      imuMsg.linear_acceleration.z = linearAccel.Z();

      imuMsg.angular_velocity.x = angularVel.X();
      imuMsg.angular_velocity.y = angularVel.Y();
      imuMsg.angular_velocity.z = angularVel.Z();

      imuMsg.orientation.w = orientation.W();
      imuMsg.orientation.x = orientation.X();
      imuMsg.orientation.y = orientation.Y();
      imuMsg.orientation.z = orientation.Z();

      this->imuPub.publish(imuMsg);
    }

    private: sensors::ImuSensorPtr imuSensor;
    private: std::unique_ptr<ros::NodeHandle> rosNode;
    private: ros::Publisher imuPub;
    private: event::ConnectionPtr updateConnection;
  };

  GZ_REGISTER_SENSOR_PLUGIN(HumanoidIMUSensor)
}
```

## ROS2 Integration

### Creating a ROS2 Gazebo Package

```python
# setup.py for ROS2 package
from setuptools import setup

package_name = 'humanoid_gazebo'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        ('share/' + package_name + '/launch', ['launch/humanoid_gazebo.launch.py']),
        ('share/' + package_name + '/worlds', ['worlds/humanoid_world.world']),
        ('share/' + package_name + '/models', ['models/simple_humanoid.urdf']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Robotics Team',
    maintainer_email='robotics@example.com',
    description='Gazebo integration for humanoid robot simulation',
    license='Apache License 2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
        ],
    },
)
```

### Launch File for Gazebo Integration

```python
# launch/humanoid_gazebo.launch.py
import os
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
from launch.actions import ExecuteProcess
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    package_dir = get_package_share_directory('humanoid_gazebo')

    # Start Gazebo with a world file
    start_gazebo_cmd = ExecuteProcess(
        cmd=['gazebo', '--verbose', '-s', 'libgazebo_ros_factory.so',
             os.path.join(package_dir, 'worlds', 'humanoid_world.world')],
        output='screen'
    )

    # Spawn the robot in Gazebo
    spawn_entity_cmd = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-entity', 'simple_humanoid',
            '-file', os.path.join(package_dir, 'models', 'simple_humanoid.urdf'),
            '-x', '0', '-y', '0', '-z', '1.0'
        ],
        output='screen'
    )

    # Robot state publisher
    robot_state_publisher_cmd = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{
            'robot_description': open(os.path.join(package_dir, 'models', 'simple_humanoid.urdf')).read()
        }]
    )

    # Joint state publisher
    joint_state_publisher_cmd = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        parameters=[{
            'use_sim_time': True
        }]
    )

    ld = LaunchDescription()

    ld.add_action(start_gazebo_cmd)
    ld.add_action(spawn_entity_cmd)
    ld.add_action(robot_state_publisher_cmd)
    ld.add_action(joint_state_publisher_cmd)

    return ld
```

## Control Interface Integration

### Joint Position Controller

```yaml
# config/joint_controllers.yaml
simple_humanoid:
  # Joint State Controller
  joint_state_controller:
    type: joint_state_controller/JointStateController
    publish_rate: 50

  # Position Controllers
  hip_joint_position_controller:
    type: position_controllers/JointPositionController
    joint: hip_joint
    pid: {p: 100.0, i: 0.01, d: 10.0}

  knee_joint_position_controller:
    type: position_controllers/JointPositionController
    joint: knee_joint
    pid: {p: 100.0, i: 0.01, d: 10.0}

  ankle_joint_position_controller:
    type: position_controllers/JointPositionController
    joint: ankle_joint
    pid: {p: 100.0, i: 0.01, d: 10.0}
```

### Balance Controller for Humanoid Robots

```python
#!/usr/bin/env python3
"""
Balance controller for humanoid robot in Gazebo simulation
"""
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu, JointState
from geometry_msgs.msg import Vector3
from std_msgs.msg import Float64MultiArray
import numpy as np
from scipy.spatial.transform import Rotation as R

class BalanceController(Node):
    def __init__(self):
        super().__init__('balance_controller')

        # Subscriptions
        self.imu_sub = self.create_subscription(
            Imu, '/imu/data', self.imu_callback, 10)
        self.joint_state_sub = self.create_subscription(
            JointState, '/joint_states', self.joint_state_callback, 10)

        # Publishers
        self.joint_cmd_pub = self.create_publisher(
            Float64MultiArray, '/joint_commands', 10)

        # Controller parameters
        self.kp = 50.0  # Proportional gain
        self.kd = 10.0  # Derivative gain
        self.target_roll = 0.0
        self.target_pitch = 0.0

        # State variables
        self.current_roll = 0.0
        self.current_pitch = 0.0
        self.roll_velocity = 0.0
        self.pitch_velocity = 0.0
        self.last_orientation = None
        self.last_time = self.get_clock().now()

        # Timer for control loop
        self.timer = self.create_timer(0.01, self.control_loop)  # 100Hz

        self.get_logger().info('Balance controller initialized')

    def imu_callback(self, msg):
        """Process IMU data to extract orientation"""
        # Convert quaternion to roll/pitch/yaw
        quat = [msg.orientation.x, msg.orientation.y,
                msg.orientation.z, msg.orientation.w]

        r = R.from_quat(quat)
        roll, pitch, yaw = r.as_euler('xyz')

        # Calculate velocities
        current_time = self.get_clock().now()
        dt = (current_time - self.last_time).nanoseconds / 1e9
        self.last_time = current_time

        if dt > 0:
            self.roll_velocity = (roll - self.current_roll) / dt
            self.pitch_velocity = (pitch - self.current_pitch) / dt

        self.current_roll = roll
        self.current_pitch = pitch

    def joint_state_callback(self, msg):
        """Process joint state messages"""
        # Store current joint positions if needed
        pass

    def control_loop(self):
        """Main balance control loop"""
        # Calculate orientation errors
        roll_error = self.target_roll - self.current_roll
        pitch_error = self.target_pitch - self.current_pitch

        # Calculate control outputs (simplified for single joint example)
        roll_control = self.kp * roll_error - self.kd * self.roll_velocity
        pitch_control = self.kp * pitch_error - self.kd * self.pitch_velocity

        # Generate joint commands for balance
        joint_commands = Float64MultiArray()
        joint_commands.data = [
            roll_control,  # hip joint adjustment
            pitch_control, # knee joint adjustment
            0.0           # ankle joint adjustment
        ]

        self.joint_cmd_pub.publish(joint_commands)

def main(args=None):
    rclpy.init(args=args)
    controller = BalanceController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Advanced Simulation Features

### Contact Sensor for Foot Detection

```xml
<!-- Add contact sensors to feet for ground contact detection -->
<gazebo reference="left_foot">
  <sensor name="left_foot_contact" type="contact">
    <always_on>1</always_on>
    <update_rate>100</update_rate>
    <contact>
      <collision>left_foot_collision</collision>
    </contact>
    <plugin name="left_foot_contact_plugin" filename="libgazebo_ros_bumper.so">
      <alwaysOn>true</alwaysOn>
      <updateRate>100.0</updateRate>
      <bumperTopicName>left_foot_bumper</bumperTopicName>
      <frameName>left_foot</frameName>
    </plugin>
  </sensor>
</gazebo>
```

### Terrain and Environment Setup

```xml
<!-- Custom terrain world file -->
<sdf version="1.7">
  <world name="humanoid_terrain">
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Ground plane with texture -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Add sun -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Add simple terrain -->
    <model name="uneven_terrain">
      <pose>0 0 0 0 0 0</pose>
      <link name="terrain_link">
        <collision name="collision">
          <geometry>
            <heightmap>
              <uri>model://uneven_terrain/heightmap.png</uri>
              <size>20 20 2</size>
              <pos>0 0 0</pos>
            </heightmap>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <heightmap>
              <uri>model://uneven_terrain/heightmap.png</uri>
              <size>20 20 2</size>
              <pos>0 0 0</pos>
            </heightmap>
          </geometry>
        </visual>
      </link>
    </model>

    <!-- Add humanoid robot -->
    <include>
      <uri>model://simple_humanoid</uri>
      <pose>0 0 1.0 0 0 0</pose>
    </include>
  </world>
</sdf>
```

## Performance Optimization

### Multi-Threaded Physics

```xml
<!-- Optimized physics configuration -->
<physics type="ode">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1</real_time_factor>
  <real_time_update_rate>1000</real_time_update_rate>
  <thread_count>4</thread_count>
  <solver>
    <type>quick</type>
    <iters>20</iters>
    <sor>1.3</sor>
  </solver>
  <constraints>
    <cfm>0.000001</cfm>
    <erp>0.2</erp>
    <contact_max_correcting_vel>100</contact_max_correcting_vel>
    <contact_surface_layer>0.001</contact_surface_layer>
  </constraints>
</physics>
```

### Visual Optimization

```bash
# Environment variables for performance
export GAZEBO_RENDER_STAGES=1  # Reduce rendering complexity
export OGRE_RESOURCE_PATH=/usr/lib/x86_64-linux-gnu/OGRE/Media/
export GAZEBO_MODEL_DATABASE_URI=""  # Skip online model database if not needed
```

## Debugging and Visualization

### Gazebo Topics and Services

```bash
# Useful Gazebo ROS topics to monitor
rostopic echo /gazebo/model_states
rostopic echo /gazebo/link_states
rostopic echo /joint_states
rostopic echo /imu/data

# Gazebo services
rosservice call /gazebo/reset_simulation
rosservice call /gazebo/pause_physics
rosservice call /gazebo/unpause_physics
```

### RViz Configuration for Gazebo

```yaml
# rviz config for humanoid gazebo visualization
Panels:
  - Class: rviz_common/Displays
    Help Height: 78
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Global Options1
        - /Status1
        - /RobotModel1
        - /TF1
      Splitter Ratio: 0.5
    Tree Height: 617
Visualization Manager:
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz_default_plugins/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.029999999329447746
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 10
      Reference Frame: <Fixed Frame>
      Value: true
    - Alpha: 1
      Class: rviz_default_plugins/RobotModel
      Collision Enabled: false
      Enabled: true
      Links:
        All Links Enabled: true
        Expand Joint Details: false
        Expand Link Details: false
        Expand Tree: false
        Link Tree Style: Links in Alphabetic Order
      Name: RobotModel
      TF Prefix: ""
      Update Interval: 0
      Value: true
      Visual Enabled: true
    - Class: rviz_default_plugins/TF
      Enabled: true
      Frame Timeout: 15
      Frames:
        All Enabled: true
      Marker Scale: 1
      Name: TF
      Show Arrows: true
      Show Axes: true
      Show Names: true
      Tree:
        {}
      Update Interval: 0
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Fixed Frame: base_link
    Frame Rate: 30
  Name: root
  Tools:
    - Class: rviz_default_plugins/Interact
      Hide Inactive Objects: true
    - Class: rviz_default_plugins/MoveCamera
    - Class: rviz_default_plugins/Select
    - Class: rviz_default_plugins/FocusCamera
  Transformation:
    Current:
      Class: rviz_default_plugins/TF
  Value: true
  Views:
    Current:
      Class: rviz_default_plugins/Orbit
      Distance: 10
      Enable Stereo Rendering:
        Stereo Eye Separation: 0.05999999865889549
        Stereo Focal Distance: 1
        Swap Stereo Eyes: false
        Value: false
      Focal Point:
        X: 0
        Y: 0
        Z: 0
      Focal Shape Fixed Size: true
      Focal Shape Size: 0.05000000074505806
      Invert Z Axis: false
      Name: Current View
      Near Clip Distance: 0.009999999776482582
      Pitch: 0.5
      Target Frame: base_link
      Value: Orbit (rviz)
      Yaw: 0.5
    Saved: ~
Window Geometry:
  Displays:
    collapsed: false
  Height: 846
  Width: 1200
```

## Troubleshooting Common Issues

### Physics Instability

```bash
# Common fixes for physics instability in humanoid models
# 1. Reduce time step
export GAZEBO_MAX_STEP_SIZE=0.001

# 2. Increase solver iterations
# Adjust in world file: <iters>50</iters>

# 3. Adjust constraint parameters
# Lower ERP (Error Reduction Parameter) for more stability
```

### Sensor Noise and Accuracy

```xml
<!-- Proper sensor noise configuration -->
<sensor name="imu_sensor" type="imu">
  <always_on>1</always_on>
  <update_rate>100</update_rate>
  <imu>
    <angular_velocity>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.01</stddev>  <!-- Reduce noise for better control -->
        </noise>
      </x>
      <!-- Similar for y and z axes -->
    </angular_velocity>
  </imu>
</sensor>
```

## Summary

Gazebo integration provides a powerful simulation environment for humanoid robotics development. By properly configuring models, plugins, and control interfaces, developers can create realistic simulation scenarios that closely match real-world behavior. The integration with ROS/ROS2 enables seamless transfer of algorithms between simulation and physical robots. Proper optimization and debugging techniques ensure stable and accurate simulation results for effective humanoid robot development and testing.