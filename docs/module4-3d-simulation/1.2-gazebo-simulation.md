---
id: module4-3d-simulation-1.2-gazebo-simulation
title: "Gazebo Simulation"
slug: /module4-3d-simulation-1.2-gazebo-simulation
---

# 4.2 Gazebo Simulation

## Overview

Gazebo is one of the most widely adopted physics simulation environments in robotics, particularly within the ROS (Robot Operating System) ecosystem. Originally developed by the Open Source Robotics Foundation (OSRF), Gazebo provides high-fidelity simulation capabilities for robot development, testing, and validation. With its transition to Ignition Gazebo (now called Ignition), the platform continues to evolve with enhanced performance and features.

## Architecture and Core Components

### Physics Engine Integration

Gazebo leverages multiple physics engines to provide accurate simulation:

- **ODE (Open Dynamics Engine)**: The original physics engine, suitable for most robotics applications
- **Bullet Physics**: Provides improved collision detection and more stable contact simulation
- **DART (Dynamic Animation and Robotics Toolkit)**: Advanced physics engine with better articulated body handling
- **Simbody**: Stanford Multi-Body Simulator for complex mechanical systems

### Simulation Architecture

```
Gazebo Server ←→ Gazebo Client
     ↓              ↓
Physics Engine ←→ Rendering Engine
     ↓              ↓
Sensor Plugins ←→ GUI Components
```

### Plugin System

Gazebo's plugin architecture enables extensibility:

- **Model Plugins**: Extend robot model behavior (controllers, sensors)
- **World Plugins**: Add functionality to the entire simulation world
- **Sensor Plugins**: Implement custom sensor models
- **GUI Plugins**: Extend the graphical user interface

## Installation and Setup

### Installing Gazebo Classic

```bash
# Ubuntu/Debian installation
sudo apt update
sudo apt install gazebo libgazebo-dev

# For ROS Noetic
sudo apt install ros-noetic-gazebo-ros-pkgs ros-noetic-gazebo-ros-control
```

### Installing Ignition Gazebo (Recommended)

```bash
# Add OSRF APT repository
sudo sh -c 'echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main" > /etc/apt/sources.list.d/gazebo-stable.list'
curl -s https://packages.osrfoundation.org/gazebo.key | sudo apt-key add -
sudo apt update

# Install Ignition Fortress (or latest version)
sudo apt install ignition-fortress
```

## Robot Model Integration

### URDF to SDF Conversion

Gazebo uses SDF (Simulation Description Format) for model descriptions, but can work with URDF:

```xml
<!-- Example SDF robot model -->
<sdf version="1.7">
  <model name="my_robot">
    <pose>0 0 0.5 0 0 0</pose>

    <!-- Links -->
    <link name="base_link">
      <inertial>
        <mass>1.0</mass>
        <inertia>
          <ixx>0.01</ixx>
          <ixy>0.0</ixy>
          <ixz>0.0</ixz>
          <iyy>0.01</iyy>
          <iyz>0.0</iyz>
          <izz>0.01</izz>
        </inertia>
      </inertial>

      <collision name="collision">
        <geometry>
          <box>
            <size>0.5 0.5 0.2</size>
          </box>
        </geometry>
      </collision>

      <visual name="visual">
        <geometry>
          <box>
            <size>0.5 0.5 0.2</size>
          </box>
        </geometry>
      </visual>
    </link>

    <!-- Joint -->
    <joint name="joint1" type="revolute">
      <parent>base_link</parent>
      <child>link1</child>
      <axis>
        <xyz>0 0 1</xyz>
        <limit>
          <lower>-1.57</lower>
          <upper>1.57</upper>
          <effort>10.0</effort>
          <velocity>1.0</velocity>
        </limit>
      </axis>
    </joint>
  </model>
</sdf>
```

### URDF with Gazebo Extensions

```xml
<!-- URDF with Gazebo-specific elements -->
<robot name="my_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.5 0.5 0.2"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <box size="0.5 0.5 0.2"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>
    </inertial>
  </link>

  <!-- Gazebo-specific extensions -->
  <gazebo reference="base_link">
    <material>Gazebo/Blue</material>
    <mu1>0.2</mu1>
    <mu2>0.2</mu2>
  </gazebo>

  <!-- Transmission for ROS control -->
  <transmission name="tran1">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="joint1">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
    <actuator name="motor1">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>
</robot>
```

## Sensor Simulation

### Camera Simulation

```xml
<gazebo reference="camera_link">
  <sensor type="camera" name="camera1">
    <update_rate>30.0</update_rate>
    <camera name="head">
      <horizontal_fov>1.3962634</horizontal_fov>
      <image>
        <width>800</width>
        <height>600</height>
        <format>R8G8B8</format>
      </image>
      <clip>
        <near>0.1</near>
        <far>100</far>
      </clip>
    </camera>
    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
      <alwaysOn>true</alwaysOn>
      <updateRate>0.0</updateRate>
      <cameraName>camera1</cameraName>
      <imageTopicName>image_raw</imageTopicName>
      <cameraInfoTopicName>camera_info</cameraInfoTopicName>
      <frameName>camera_link</frameName>
    </plugin>
  </sensor>
</gazebo>
```

### LIDAR Simulation

```xml
<gazebo reference="hokuyo_link">
  <sensor type="ray" name="head_hokuyo_sensor">
    <pose>0 0 0 0 0 0</pose>
    <visualize>false</visualize>
    <update_rate>40</update_rate>
    <ray>
      <scan>
        <horizontal>
          <samples>720</samples>
          <resolution>1</resolution>
          <min_angle>-1.570796</min_angle>
          <max_angle>1.570796</max_angle>
        </horizontal>
      </scan>
      <range>
        <min>0.10</min>
        <max>30.0</max>
        <resolution>0.01</resolution>
      </range>
    </ray>
    <plugin name="gazebo_ros_head_hokuyo_controller"
            filename="libgazebo_ros_laser.so">
      <topicName>/scan</topicName>
      <frameName>hokuyo_link</frameName>
    </plugin>
  </sensor>
</gazebo>
```

### IMU Simulation

```xml
<gazebo reference="imu_link">
  <sensor type="imu" name="imu_sensor">
    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <visualize>false</visualize>
    <imu>
      <angular_velocity>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
          </noise>
        </z>
      </angular_velocity>
      <linear_acceleration>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
          </noise>
        </z>
      </linear_acceleration>
    </imu>
    <plugin name="gazebo_ros_imu" filename="libgazebo_ros_imu.so">
      <bodyName>imu_link</bodyName>
      <topicName>imu/data</topicName>
      <serviceName>imu/service</serviceName>
      <gaussianNoise>0.0</gaussianNoise>
      <updateRate>100.0</updateRate>
    </plugin>
  </sensor>
</gazebo>
```

## World Design and Environment Modeling

### Creating Custom Worlds

```xml
<!-- Example world file -->
<sdf version="1.7">
  <world name="small_room">
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.1 0.1 -1</direction>
    </light>

    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>1.0</mu>
                <mu2>1.0</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <!-- Add obstacles -->
    <model name="table">
      <pose>2 0 0 0 0 0</pose>
      <link name="table_link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1 0.8 0.8</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1 0.8 0.8</size>
            </box>
          </geometry>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

### Procedural Environment Generation

```python
#!/usr/bin/env python3

import xml.etree.ElementTree as ET
import math

class WorldGenerator:
    def __init__(self):
        self.root = ET.Element("sdf", version="1.7")
        self.world = ET.SubElement(self.root, "world", name="generated_world")

        # Add default light
        self.add_sun_light()
        # Add ground plane
        self.add_ground_plane()

    def add_sun_light(self):
        light = ET.SubElement(self.world, "light", name="sun", type="directional")
        ET.SubElement(light, "cast_shadows").text = "true"
        ET.SubElement(light, "pose").text = "0 0 10 0 0 0"

        diffuse = ET.SubElement(light, "diffuse")
        diffuse.text = "0.8 0.8 0.8 1"

        direction = ET.SubElement(light, "direction")
        direction.text = "-0.1 0.1 -1"

    def add_ground_plane(self):
        model = ET.SubElement(self.world, "model", name="ground_plane")
        ET.SubElement(model, "static").text = "true"

        link = ET.SubElement(model, "link", name="link")

        # Collision
        collision = ET.SubElement(link, "collision", name="collision")
        geom_collision = ET.SubElement(collision, "geometry")
        plane_collision = ET.SubElement(geom_collision, "plane")
        normal_collision = ET.SubElement(plane_collision, "normal")
        normal_collision.text = "0 0 1"
        size_collision = ET.SubElement(plane_collision, "size")
        size_collision.text = "100 100"

        # Visual
        visual = ET.SubElement(link, "visual", name="visual")
        geom_visual = ET.SubElement(visual, "geometry")
        plane_visual = ET.SubElement(geom_visual, "plane")
        normal_visual = ET.SubElement(plane_visual, "normal")
        normal_visual.text = "0 0 1"
        size_visual = ET.SubElement(plane_visual, "size")
        size_visual.text = "100 100"

    def add_random_obstacles(self, num_obstacles=10):
        for i in range(num_obstacles):
            x = (i % 5) - 2  # Distribute in grid
            y = (i // 5) - 2
            z = 0.5

            self.add_box_obstacle(f"obstacle_{i}", x, y, z)

    def add_box_obstacle(self, name, x, y, z):
        model = ET.SubElement(self.world, "model", name=name)
        pose = ET.SubElement(model, "pose")
        pose.text = f"{x} {y} {z} 0 0 0"

        link = ET.SubElement(model, "link", name=f"{name}_link")

        # Collision
        collision = ET.SubElement(link, "collision", name="collision")
        geom = ET.SubElement(collision, "geometry")
        box = ET.SubElement(geom, "box")
        size = ET.SubElement(box, "size")
        size.text = "0.5 0.5 1.0"

        # Visual
        visual = ET.SubElement(link, "visual", name="visual")
        geom_visual = ET.SubElement(visual, "geometry")
        box_visual = ET.SubElement(geom_visual, "box")
        size_visual = ET.SubElement(box_visual, "size")
        size_visual.text = "0.5 0.5 1.0"

    def save_world(self, filename):
        tree = ET.ElementTree(self.root)
        tree.write(filename, encoding="unicode", xml_declaration=True)

        # Add proper XML declaration manually
        with open(filename, 'r') as f:
            content = f.read()

        with open(filename, 'w') as f:
            f.write('<?xml version="1.0"?>\n')
            f.write(content)

# Generate world
generator = WorldGenerator()
generator.add_random_obstacles(20)
generator.save_world("generated_world.world")
```

## ROS Integration

### Launch Files for Simulation

```xml
<!-- robot_simulator.launch -->
<launch>
  <!-- Start Gazebo server and GUI -->
  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find my_robot_description)/worlds/my_world.world"/>
    <arg name="paused" value="false"/>
    <arg name="use_sim_time" value="true"/>
    <arg name="gui" value="true"/>
    <arg name="headless" value="false"/>
    <arg name="debug" value="false"/>
  </include>

  <!-- Spawn robot in Gazebo -->
  <param name="robot_description"
         command="$(find xacro)/xacro --inorder '$(find my_robot_description)/urdf/my_robot.xacro'" />

  <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model"
        args="-param robot_description -urdf -model my_robot -x 0 -y 0 -z 0.5"
        respawn="false" output="screen"/>

  <!-- Robot state publisher -->
  <node name="robot_state_publisher" pkg="robot_state_publisher"
        type="robot_state_publisher" respawn="false" output="screen"/>

  <!-- Joint state publisher -->
  <node name="joint_state_publisher" pkg="joint_state_publisher"
        type="joint_state_publisher" respawn="false">
    <param name="use_gui" value="false"/>
  </node>
</launch>
```

### Controller Configuration

```yaml
# controllers.yaml
my_robot_controller:
  # Joint trajectory controller
  joint_trajectory_controller:
    type: position_controllers/JointTrajectoryController
    joints:
      - joint1
      - joint2
      - joint3
    gains:
      joint1: {p: 100.0, i: 0.01, d: 10.0}
      joint2: {p: 100.0, i: 0.01, d: 10.0}
      joint3: {p: 100.0, i: 0.01, d: 10.0}

  # Joint position controllers
  joint1_position_controller:
    type: position_controllers/JointPositionController
    joint: joint1
    pid: {p: 100.0, i: 0.01, d: 10.0}

  joint2_position_controller:
    type: position_controllers/JointPositionController
    joint: joint2
    pid: {p: 100.0, i: 0.01, d: 10.0}
```

## Advanced Simulation Features

### Dynamic Reconfigure for Parameters

```cpp
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <ignition/math/Pose3.hh>

namespace gazebo
{
  class DynamicObstaclePlugin : public ModelPlugin
  {
    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
    {
      this->model = _model;
      this->world = _model->GetWorld();

      // Get parameters from SDF
      if (_sdf->HasElement("amplitude"))
        this->amplitude = _sdf->Get<double>("amplitude");
      else
        this->amplitude = 1.0;

      if (_sdf->HasElement("frequency"))
        this->frequency = _sdf->Get<double>("frequency");
      else
        this->frequency = 1.0;

      // Connect to world update event
      this->updateConnection = event::Events::ConnectWorldUpdateBegin(
          std::bind(&DynamicObstaclePlugin::OnUpdate, this));
    }

    public: void OnUpdate()
    {
      // Update obstacle position with sinusoidal motion
      common::Time curTime = this->world->SimTime();
      double seconds = curTime.Double();

      double x = this->initialPose.Pos().X();
      double y = this->initialPose.Pos().Y() +
                 this->amplitude * sin(this->frequency * seconds);
      double z = this->initialPose.Pos().Z();

      ignition::math::Pose3d newPose(x, y, z, 0, 0, 0);
      this->model->SetWorldPose(newPose);
    }

    private: physics::ModelPtr model;
    private: physics::WorldPtr world;
    private: ignition::math::Pose3d initialPose;
    private: double amplitude;
    private: double frequency;
    private: event::ConnectionPtr updateConnection;
  };

  GZ_REGISTER_MODEL_PLUGIN(DynamicObstaclePlugin)
}
```

### Custom Physics Properties

```cpp
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>

namespace gazebo
{
  class CustomPhysicsPlugin : public WorldPlugin
  {
    public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
    {
      this->world = _world;

      // Modify global physics parameters
      physics::PhysicsEnginePtr physics = this->world->Physics();

      if (_sdf->HasElement("real_time_update_rate"))
        physics->SetRealTimeUpdateRate(
          _sdf->Get<double>("real_time_update_rate"));

      if (_sdf->HasElement("max_step_size"))
        physics->SetMaxStepSize(_sdf->Get<double>("max_step_size"));

      if (_sdf->HasElement("real_time_factor"))
        physics->SetRealTimeFactor(_sdf->Get<double>("real_time_factor"));

      // Connect to pre-update event
      this->preUpdateConnection = event::Events::ConnectPreUpdate(
          std::bind(&CustomPhysicsPlugin::OnPreUpdate, this));
    }

    public: void OnPreUpdate()
    {
      // Custom physics logic before each simulation step
      // Example: Apply custom forces or modify physics parameters
    }

    private: physics::WorldPtr world;
    private: event::ConnectionPtr preUpdateConnection;
  };

  GZ_REGISTER_WORLD_PLUGIN(CustomPhysicsPlugin)
}
```

## Performance Optimization

### Multi-Threaded Simulation

```cpp
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <thread>
#include <mutex>

namespace gazebo
{
  class MultiThreadedPlugin : public WorldPlugin
  {
    public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
    {
      this->world = _world;

      // Configure for multi-threading
      this->updateConnection = event::Events::ConnectWorldUpdateBegin(
          std::bind(&MultiThreadedPlugin::OnUpdate, this));
    }

    public: void OnUpdate()
    {
      // Parallel processing of independent simulation elements
      std::vector<std::thread> threads;

      // Process different aspects of simulation in parallel
      threads.emplace_back(&MultiThreadedPlugin::UpdateSensors, this);
      threads.emplace_back(&MultiThreadedPlugin::UpdatePhysics, this);
      threads.emplace_back(&MultiThreadedPlugin::UpdateRendering, this);

      // Wait for all threads to complete
      for (auto& thread : threads) {
        thread.join();
      }
    }

    private: void UpdateSensors() {
      // Update sensor models
    }

    private: void UpdatePhysics() {
      // Update physics calculations
    }

    private: void UpdateRendering() {
      // Update rendering (if applicable)
    }

    private: physics::WorldPtr world;
    private: event::ConnectionPtr updateConnection;
    private: std::mutex updateMutex;
  };
}
```

### Level of Detail (LOD) Management

```xml
<!-- Model with multiple LOD levels -->
<sdf version="1.7">
  <model name="complex_robot">
    <!-- High detail model for close-up simulation -->
    <link name="base_link_high_detail">
      <visual name="visual_high">
        <geometry>
          <mesh>
            <uri>model://complex_robot/meshes/base_high.dae</uri>
          </mesh>
        </geometry>
      </visual>
      <collision name="collision_high">
        <geometry>
          <mesh>
            <uri>model://complex_robot/meshes/base_collision.dae</uri>
          </mesh>
        </geometry>
      </collision>
    </link>

    <!-- Simplified model for distant simulation -->
    <link name="base_link_low_detail">
      <visual name="visual_low">
        <geometry>
          <box>
            <size>0.5 0.5 0.3</size>
          </box>
        </geometry>
      </visual>
      <collision name="collision_low">
        <geometry>
          <box>
            <size>0.5 0.5 0.3</size>
          </box>
        </geometry>
      </collision>
    </link>
  </model>
</sdf>
```

## Best Practices and Troubleshooting

### Common Issues and Solutions

**Performance Issues:**
- Reduce physics update rate for less critical simulations
- Use simplified collision geometry
- Limit the number of active sensors
- Implement view frustum culling for rendering

**Stability Issues:**
- Adjust solver parameters (ERP, CFM)
- Use appropriate time step sizes
- Verify mass and inertia properties
- Check joint limits and constraints

**Synchronization Issues:**
- Ensure consistent use of simulation time
- Synchronize ROS time with Gazebo time
- Handle message queue sizes appropriately

### Debugging Techniques

```bash
# Debug Gazebo with verbose output
gzserver --verbose my_world.world

# Monitor simulation performance
gz stats

# Debug ROS-Gazebo integration
rostopic echo /gazebo/model_states
rostopic echo /joint_states
```

## Integration with Modern Workflows

### Docker-based Simulation

```dockerfile
FROM osrf/ros:noetic-desktop-full

# Install Gazebo
RUN apt-get update && apt-get install -y \
    gazebo11 \
    libgazebo11-dev \
    ros-noetic-gazebo-ros-pkgs \
    ros-noetic-gazebo-ros-control \
    && rm -rf /var/lib/apt/lists/*

# Copy robot models and worlds
COPY models/ /root/.gazebo/models/
COPY worlds/ /worlds/

# Set environment variables
ENV GAZEBO_MODEL_PATH=/root/.gazebo/models
ENV GAZEBO_WORLD_PATH=/worlds

# Default command
CMD ["bash"]
```

### CI/CD Integration

```yaml
# .github/workflows/simulation_tests.yml
name: Simulation Tests
on: [push, pull_request]

jobs:
  simulation-test:
    runs-on: ubuntu-20.04
    steps:
    - uses: actions/checkout@v2

    - name: Setup ROS
      uses: ros-tooling/setup-ros@v0.2
      with:
        required-ros-distributions: noetic

    - name: Install Gazebo
      run: |
        sudo apt-get update
        sudo apt-get install -y gazebo11 libgazebo11-dev

    - name: Build workspace
      uses: ros-tooling/action-ros-ci@v0.2
      with:
        package-name: my_robot_simulation
        target-ros1-distro: noetic

    - name: Run simulation tests
      run: |
        source /opt/ros/noetic/setup.bash
        roslaunch my_robot_simulation test_simulation.launch
```

Gazebo remains a powerful and flexible simulation environment for robotics development, providing the necessary tools for comprehensive robot testing and validation. Its integration with ROS/ROS2 ecosystems makes it an essential component of modern robotics workflows, particularly for humanoid robot development where safety and efficiency in testing are paramount.
