---
id: module6-motion-planning-6.2-configuration-space
title: "Configuration Space"
slug: /module6-motion-planning-6.2-configuration-space
---

# Configuration Space

The configuration space (C-space) is a fundamental concept in robotics that represents all possible configurations of a robot. A configuration is a complete specification of the position of every point on the robot. Understanding and effectively representing the configuration space is crucial for motion planning, as it provides the mathematical framework for describing robot poses and planning feasible paths.

## Definition and Fundamentals

The configuration space of a robot is the space of all possible configurations of that robot. For a system with n degrees of freedom, the configuration space is an n-dimensional space where each point represents a unique configuration of the robot. A configuration q can be represented as:

q = [q₁, q₂, ..., qₙ]

where each qᵢ represents one degree of freedom of the robot.

The configuration space is typically denoted as C, and can be decomposed into:
- Free space (C_free): configurations where the robot does not collide with obstacles
- Obstacle space (C_obs): configurations where the robot collides with obstacles
- C = C_free ∪ C_obs, with C_free ∩ C_obs = ∅

## Degrees of Freedom (DOF)

The degrees of freedom of a robot determine the dimensionality of its configuration space:

- **Planar rigid body**: 3 DOF (x, y, θ)
- **Spatial rigid body**: 6 DOF (x, y, z, roll, pitch, yaw)
- **N-link planar manipulator**: N DOF (one per joint angle)
- **Humanoid robot**: 30+ DOF (depending on complexity)

### Configuration Space Topology

The topology of the configuration space depends on the joint types and robot structure:

- **Revolute joints**: Create circular topology (S¹) for the corresponding dimension
- **Prismatic joints**: Create linear topology (R¹) for the corresponding dimension
- **Floating base**: Creates complex topology combining translation and rotation

For example, a 2-link planar manipulator has configuration space S¹ × S¹ (a torus), while a 6-DOF spatial manipulator with all revolute joints has configuration space (S¹)^6.

## Configuration Space Obstacles

Configuration space obstacles (C-obstacles) represent all configurations where the robot intersects with environmental obstacles. Computing C-obstacles analytically is often intractable, so they are typically computed implicitly during planning.

### Minkowski Sum Approach

For a point robot and polygonal obstacles, the C-obstacle is computed using the Minkowski sum:

C_obs = ⋃ᵢ (Oᵢ ⊕ (-R))

where Oᵢ is the i-th obstacle, R is the robot shape, and ⊕ denotes the Minkowski sum.

### Sampling-based Approximation

In practice, C-obstacles are often handled through collision detection during the planning process rather than explicit computation:

```python
import numpy as np
from typing import Tuple, List
from scipy.spatial.distance import cdist

class ConfigurationSpace:
    def __init__(self, robot_geometry: dict, workspace_bounds: Tuple[Tuple[float, float], Tuple[float, float]]):
        """
        Initialize configuration space representation
        Args:
            robot_geometry: Dictionary describing robot geometry and kinematics
            workspace_bounds: ((min_x, max_x), (min_y, max_y))
        """
        self.robot_geometry = robot_geometry
        self.workspace_bounds = workspace_bounds
        self.obstacles = []  # List of obstacle representations

    def add_obstacle(self, obstacle_shape: dict):
        """Add an obstacle to the environment"""
        self.obstacles.append(obstacle_shape)

    def is_collision_free(self, configuration: np.ndarray) -> bool:
        """
        Check if a configuration is collision-free
        Args:
            configuration: Robot configuration vector
        Returns:
            True if configuration is collision-free, False otherwise
        """
        # Forward kinematics to get robot link positions
        link_positions = self.forward_kinematics(configuration)

        # Check collision with each obstacle
        for obstacle in self.obstacles:
            if self.check_robot_collision(link_positions, obstacle):
                return False

        # Check workspace bounds
        for i, (min_bound, max_bound) in enumerate(self.workspace_bounds):
            if not (min_bound <= configuration[i] <= max_bound):
                return False

        return True

    def forward_kinematics(self, configuration: np.ndarray) -> List[np.ndarray]:
        """
        Compute forward kinematics to get positions of all robot links
        Args:
            configuration: Joint configuration vector
        Returns:
            List of link positions/orientations
        """
        # This is a simplified example - actual implementation depends on robot structure
        # For a 2R manipulator:
        if len(configuration) == 2:
            theta1, theta2 = configuration
            l1, l2 = self.robot_geometry['link_lengths']

            # Compute end-effector position
            x1 = l1 * np.cos(theta1)
            y1 = l1 * np.sin(theta1)
            x2 = x1 + l2 * np.cos(theta1 + theta2)
            y2 = y1 + l2 * np.sin(theta1 + theta2)

            return [np.array([0, 0]), np.array([x1, y1]), np.array([x2, y2])]

        # For more complex robots, implement appropriate kinematics
        return []

    def check_robot_collision(self, link_positions: List[np.ndarray],
                            obstacle: dict) -> bool:
        """
        Check if robot collides with a specific obstacle
        Args:
            link_positions: Positions of robot links
            obstacle: Obstacle representation
        Returns:
            True if collision detected, False otherwise
        """
        # This is a simplified collision check
        # For complex geometries, use proper collision detection libraries
        if obstacle['type'] == 'circle':
            obs_center = obstacle['center']
            obs_radius = obstacle['radius']

            for pos in link_positions:
                dist = np.linalg.norm(pos - obs_center)
                if dist <= obs_radius + self.robot_geometry['link_radius']:
                    return True

        elif obstacle['type'] == 'rectangle':
            # Check if any link is inside the rectangle
            rect_min = obstacle['min_corner']
            rect_max = obstacle['max_corner']

            for pos in link_positions:
                if (rect_min[0] - self.robot_geometry['link_radius'] <= pos[0] <= rect_max[0] + self.robot_geometry['link_radius'] and
                    rect_min[1] - self.robot_geometry['link_radius'] <= pos[1] <= rect_max[1] + self.robot_geometry['link_radius']):
                    return True

        return False

    def sample_configuration(self) -> np.ndarray:
        """Sample a random configuration within joint limits"""
        config = np.zeros(len(self.robot_geometry['joint_limits']))
        for i, (min_limit, max_limit) in enumerate(self.robot_geometry['joint_limits']):
            config[i] = np.random.uniform(min_limit, max_limit)
        return config

# Example usage
def example_cspace():
    # Define robot geometry (2R planar manipulator)
    robot_geom = {
        'link_lengths': [1.0, 1.0],
        'link_radius': 0.1,  # Collision radius for links
        'joint_limits': [(-np.pi, np.pi), (-np.pi, np.pi)]  # Joint limits in radians
    }

    # Define workspace bounds
    workspace = ((-3, 3), (-3, 3))

    # Create configuration space
    cspace = ConfigurationSpace(robot_geom, workspace)

    # Add obstacles
    cspace.add_obstacle({
        'type': 'circle',
        'center': np.array([1.5, 1.5]),
        'radius': 0.5
    })

    cspace.add_obstacle({
        'type': 'rectangle',
        'min_corner': np.array([0.5, -0.5]),
        'max_corner': np.array([1.5, 0.5])
    })

    # Test collision checking
    test_config = np.array([0.5, 0.3])  # Joint angles
    is_free = cspace.is_collision_free(test_config)
    print(f"Configuration {test_config} is collision-free: {is_free}")

    return cspace

if __name__ == "__main__":
    cspace = example_cspace()
```

## High-dimensional Configuration Spaces

For complex robots like humanoid systems, the configuration space can be extremely high-dimensional:

- **Humanoid robot**: 30+ DOF (legs, arms, torso, head)
- **Multi-fingered hand**: 15+ DOF
- **Mobile manipulator**: Base DOF + manipulator DOF

### Challenges in High-dimensional Spaces

1. **Curse of dimensionality**: Volume of space grows exponentially
2. **Sampling complexity**: Need exponentially more samples to cover space
3. **Collision detection**: Computational cost increases with complexity
4. **Path planning**: Finding connected components becomes difficult

## Configuration Space Representation Techniques

### Grid-based Representation

Discretize the configuration space into a grid for planning:

```python
import numpy as np
from typing import Tuple, Optional

class GridBasedCspace:
    def __init__(self, bounds: List[Tuple[float, float]], grid_resolution: List[float]):
        """
        Initialize grid-based configuration space
        Args:
            bounds: List of (min, max) bounds for each DOF
            grid_resolution: Resolution for each DOF dimension
        """
        self.bounds = bounds
        self.grid_resolution = grid_resolution
        self.dimensions = len(bounds)

        # Calculate grid size for each dimension
        self.grid_sizes = []
        for i in range(self.dimensions):
            size = int(np.ceil((bounds[i][1] - bounds[i][0]) / grid_resolution[i]))
            self.grid_sizes.append(size)

        # Initialize occupancy grid (0 = free, 1 = occupied)
        self.grid = np.zeros(self.grid_sizes, dtype=np.uint8)

        # Store the actual bounds and resolutions for conversion
        self.bounds = bounds
        self.grid_resolution = grid_resolution

    def config_to_grid(self, config: np.ndarray) -> Tuple[int, ...]:
        """Convert continuous configuration to grid coordinates"""
        grid_coords = []
        for i, val in enumerate(config):
            # Clamp to bounds
            val = max(self.bounds[i][0], min(self.bounds[i][1], val))
            # Convert to grid index
            idx = int((val - self.bounds[i][0]) / self.grid_resolution[i])
            idx = min(idx, self.grid_sizes[i] - 1)  # Ensure within bounds
            grid_coords.append(idx)
        return tuple(grid_coords)

    def grid_to_config(self, grid_coords: Tuple[int, ...]) -> np.ndarray:
        """Convert grid coordinates to continuous configuration"""
        config = np.zeros(self.dimensions)
        for i, idx in enumerate(grid_coords):
            config[i] = self.bounds[i][0] + (idx + 0.5) * self.grid_resolution[i]
        return config

    def is_occupied(self, config: np.ndarray) -> bool:
        """Check if configuration is occupied in grid"""
        grid_coords = self.config_to_grid(config)
        return bool(self.grid[grid_coords])

    def set_occupied(self, config: np.ndarray, occupied: bool = True):
        """Set occupancy status for a configuration"""
        grid_coords = self.config_to_grid(config)
        self.grid[grid_coords] = 1 if occupied else 0

    def get_neighbors(self, config: np.ndarray) -> List[np.ndarray]:
        """Get neighboring configurations in grid"""
        grid_coords = self.config_to_grid(config)
        neighbors = []

        # Generate all possible neighbor indices
        for i in range(self.dimensions):
            for offset in [-1, 1]:
                new_coords = list(grid_coords)
                new_coords[i] = grid_coords[i] + offset

                # Check bounds
                if 0 <= new_coords[i] < self.grid_sizes[i]:
                    neighbor_config = self.grid_to_config(tuple(new_coords))
                    neighbors.append(neighbor_config)

        return neighbors

# Example usage
def example_grid_cspace():
    # 2DOF robot with joint limits
    bounds = [(-np.pi, np.pi), (-np.pi, np.pi)]  # Both joints from -π to π
    resolution = [0.1, 0.1]  # 0.1 radian resolution

    grid_cspace = GridBasedCspace(bounds, resolution)

    # Mark some configurations as occupied (simulating obstacles)
    for theta1 in np.linspace(-1, 1, 5):
        for theta2 in np.linspace(-1, 1, 5):
            config = np.array([theta1, theta2])
            grid_cspace.set_occupied(config)

    # Test configuration
    test_config = np.array([0.5, 0.3])
    print(f"Configuration {test_config} is occupied: {grid_cspace.is_occupied(test_config)}")

    # Get neighbors
    neighbors = grid_cspace.get_neighbors(test_config)
    print(f"Number of neighbors: {len(neighbors)}")

    return grid_cspace
```

### Topological Representations

For complex configuration spaces with non-trivial topology, specialized representations are needed:

- **Tangent space**: Linear approximation around a configuration
- **Retraction maps**: Map from tangent space back to manifold
- **Chart-based representations**: Local coordinate patches

## Configuration Space Planning Approaches

### Visibility-based Methods

Construct visibility graphs in the configuration space:

```python
import numpy as np
from typing import List, Tuple, Optional
import math

class VisibilityGraph:
    def __init__(self, cspace: ConfigurationSpace):
        self.cspace = cspace
        self.vertices = []  # List of configurations
        self.edges = {}     # adjacency list: vertex_idx -> [connected_vertex_indices]

    def add_vertex(self, config: np.ndarray) -> int:
        """Add a vertex (configuration) to the graph"""
        idx = len(self.vertices)
        self.vertices.append(config)
        self.edges[idx] = []
        return idx

    def is_edge_collision_free(self, config1: np.ndarray,
                              config2: np.ndarray,
                              num_samples: int = 10) -> bool:
        """Check if straight line path between configs is collision-free"""
        for i in range(num_samples + 1):
            t = i / num_samples
            intermediate_config = (1 - t) * config1 + t * config2
            if not self.cspace.is_collision_free(intermediate_config):
                return False
        return True

    def build_visibility_graph(self, samples: List[np.ndarray]):
        """Build visibility graph from samples"""
        # Add all samples as vertices
        for sample in samples:
            self.add_vertex(sample)

        # Connect visible vertices
        for i in range(len(self.vertices)):
            for j in range(i + 1, len(self.vertices)):
                if self.is_edge_collision_free(self.vertices[i], self.vertices[j]):
                    self.edges[i].append(j)
                    self.edges[j].append(i)

    def find_path(self, start_config: np.ndarray,
                  goal_config: np.ndarray) -> Optional[List[np.ndarray]]:
        """Find path using graph search"""
        # Add start and goal as vertices
        start_idx = self.add_vertex(start_config)
        goal_idx = self.add_vertex(goal_config)

        # Temporarily connect start and goal to visible vertices
        for i in range(len(self.vertices) - 2):  # Exclude newly added start/goal
            if self.is_edge_collision_free(start_config, self.vertices[i]):
                self.edges[start_idx].append(i)
                self.edges[i].append(start_idx)

            if self.is_edge_collision_free(goal_config, self.vertices[i]):
                self.edges[goal_idx].append(i)
                self.edges[i].append(goal_idx)

        # Use Dijkstra's algorithm to find shortest path
        distances = {i: float('inf') for i in range(len(self.vertices))}
        previous = {i: None for i in range(len(self.vertices))}
        distances[start_idx] = 0
        unvisited = set(range(len(self.vertices)))

        while unvisited:
            current = min(unvisited, key=lambda x: distances[x])
            unvisited.remove(current)

            if current == goal_idx:
                break

            for neighbor in self.edges[current]:
                if neighbor in unvisited:
                    # For simplicity, assume unit edge weight
                    alt = distances[current] + 1
                    if alt < distances[neighbor]:
                        distances[neighbor] = alt
                        previous[neighbor] = current

        # Reconstruct path
        if distances[goal_idx] == float('inf'):
            return None  # No path found

        path = []
        current = goal_idx
        while current is not None:
            path.append(self.vertices[current].copy())
            current = previous[current]

        return path[::-1]
```

## Practical Considerations

### Collision Detection Optimization

Efficient collision detection is crucial for configuration space operations:

1. **Bounding Volume Hierarchies (BVH)**: Use bounding boxes/spheres to quickly eliminate non-colliding parts
2. **Spatial hashing**: Hash occupied regions for O(1) lookup
3. **Incremental collision checking**: Only check changed parts of robot

### Configuration Space Visualization

For high-dimensional spaces, visualization techniques include:

- **Projection**: Project high-D space to 2D/3D for visualization
- **Slices**: Fix some DOF and visualize remaining dimensions
- **Animation**: Show evolution of configuration over time

## Advanced Topics

### Kinodynamic Planning

Incorporate dynamics constraints into configuration space planning:

- **State space**: Extend configuration space with velocity/acceleration
- **Differential constraints**: Non-holonomic constraints on motion
- **Time-parameterized paths**: Consider temporal aspects of motion

### Uncertainty in Configuration Space

Account for uncertainty in configuration space planning:

- **Probabilistic C-space**: Represent uncertainty in robot configuration
- **Robust planning**: Plan paths that are robust to uncertainty
- **Information gathering**: Plan motions to reduce uncertainty

## Conclusion

Configuration space provides the mathematical foundation for motion planning in robotics. Understanding its properties, representation, and computational challenges is essential for developing effective motion planning algorithms. The choice of representation and planning approach depends on the specific characteristics of the robot and environment, with trade-offs between completeness, optimality, and computational efficiency.
