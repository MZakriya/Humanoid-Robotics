---
id: module6-motion-planning-6.3-sampling-based
title: "Sampling-Based Planning"
slug: /module6-motion-planning-6.3-sampling-based
---

# Sampling-Based Motion Planning

Sampling-based motion planning algorithms represent a paradigm shift from traditional grid-based or graph-based approaches. Instead of discretizing the entire configuration space, these methods explore the space by sampling configurations and connecting them to form a roadmap or tree structure. This approach is particularly effective for high-dimensional configuration spaces where complete discretization is computationally infeasible.

## Overview and Motivation

Traditional motion planning approaches struggle with the curse of dimensionality - as the number of degrees of freedom increases, the computational complexity grows exponentially. Sampling-based methods address this challenge by:

1. **Focusing exploration**: Only sample configurations that are likely to lead to a solution
2. **Probabilistic completeness**: Guarantee finding a solution if one exists as the number of samples approaches infinity
3. **Scalability**: Handle high-dimensional spaces more effectively than complete methods
4. **Anytime behavior**: Provide feasible solutions at any point during execution

The fundamental principle is to sample the configuration space efficiently and build a connectivity graph that captures the essential topology of the free space.

## Probabilistic Roadmap Method (PRM)

The Probabilistic Roadmap Method (PRM) is a multi-query approach that precomputes a roadmap of the environment, making it efficient for scenarios where multiple paths need to be planned in the same environment.

### Algorithm Structure

The PRM algorithm consists of two phases:

1. **Roadmap Construction Phase**: Sample configurations and connect them to form a roadmap
2. **Query Phase**: Connect start and goal configurations to the roadmap and find a path

```python
import numpy as np
from scipy.spatial import KDTree
from typing import List, Tuple, Optional, Callable, Dict
import heapq

class PRMPlanner:
    def __init__(self,
                 sample_free_space: Callable[[], Optional[np.ndarray]],
                 is_collision_free: Callable[[np.ndarray, np.ndarray], bool],
                 distance_func: Callable[[np.ndarray, np.ndarray], float],
                 max_samples: int = 1000,
                 k_nearest: int = 10,
                 connection_radius: Optional[float] = None):
        """
        Initialize PRM planner
        Args:
            sample_free_space: Function to sample free configuration space
            is_collision_free: Function to check if path between two configs is collision-free
            distance_func: Function to compute distance between configurations
            max_samples: Maximum number of samples to generate
            k_nearest: Number of nearest neighbors to connect (if connection_radius is None)
            connection_radius: Maximum distance to connect configurations
        """
        self.sample_free_space = sample_free_space
        self.is_collision_free = is_collision_free
        self.distance_func = distance_func
        self.max_samples = max_samples
        self.k_nearest = k_nearest
        self.connection_radius = connection_radius

        # Roadmap data structures
        self.vertices: List[np.ndarray] = []
        self.edges: Dict[int, List[Tuple[int, float]]] = {}  # vertex_idx -> [(neighbor_idx, distance)]

        # KDTree for nearest neighbor queries
        self.kdtree: Optional[KDTree] = None

    def build_roadmap(self):
        """Build the probabilistic roadmap"""
        # Phase 1: Sample configurations
        for _ in range(self.max_samples):
            config = self.sample_free_space()
            if config is not None:
                self.vertices.append(config)

        if len(self.vertices) == 0:
            return

        # Build KDTree for efficient nearest neighbor queries
        vertex_array = np.array(self.vertices)
        self.kdtree = KDTree(vertex_array)

        # Phase 2: Connect configurations
        for i, vertex in enumerate(self.vertices):
            if self.connection_radius is not None:
                # Connect within radius
                neighbor_indices = self.kdtree.query_ball_point(vertex, self.connection_radius)
                for j in neighbor_indices:
                    if i != j:  # Don't connect to itself
                        dist = self.distance_func(vertex, self.vertices[j])
                        if (self.is_collision_free(vertex, self.vertices[j]) and
                            j not in self.edges.get(i, [])):
                            # Add bidirectional connection
                            if i not in self.edges:
                                self.edges[i] = []
                            if j not in self.edges:
                                self.edges[j] = []
                            self.edges[i].append((j, dist))
                            self.edges[j].append((i, dist))
            else:
                # Connect to k nearest neighbors
                distances, indices = self.kdtree.query(vertex, k=min(self.k_nearest + 1, len(self.vertices)))

                for dist, j in zip(distances, indices):
                    if i != j and dist > 0:  # Don't connect to itself
                        if (self.is_collision_free(vertex, self.vertices[j]) and
                            j not in self.edges.get(i, [])):
                            # Add bidirectional connection
                            if i not in self.edges:
                                self.edges[i] = []
                            if j not in self.edges:
                                self.edges[j] = []
                            self.edges[i].append((j, dist))
                            self.edges[j].append((i, dist))

    def find_nearest_vertex(self, config: np.ndarray) -> Optional[int]:
        """Find the nearest vertex in the roadmap to a given configuration"""
        if self.kdtree is None or len(self.vertices) == 0:
            return None

        _, nearest_idx = self.kdtree.query(config)
        return nearest_idx

    def connect_query_config(self, config: np.ndarray,
                           max_connection_dist: float) -> List[int]:
        """Connect a query configuration (start/goal) to nearby roadmap vertices"""
        if self.kdtree is None:
            return []

        # Find nearby vertices within connection distance
        nearby_indices = self.kdtree.query_ball_point(config, max_connection_dist)

        connected_vertices = []
        for idx in nearby_indices:
            if self.is_collision_free(config, self.vertices[idx]):
                connected_vertices.append(idx)

        return connected_vertices

    def dijkstra_path(self, start_idx: int, goal_idx: int) -> Tuple[List[int], float]:
        """Find shortest path using Dijkstra's algorithm"""
        if start_idx not in self.edges or goal_idx not in self.edges:
            return [], float('inf')

        # Priority queue: (distance, vertex_idx)
        pq = [(0.0, start_idx)]

        # Distance dictionary
        distances = {start_idx: 0.0}

        # Predecessor dictionary for path reconstruction
        predecessors = {start_idx: None}

        while pq:
            current_dist, current_idx = heapq.heappop(pq)

            if current_idx == goal_idx:
                # Reconstruct path
                path = []
                current = goal_idx
                while current is not None:
                    path.append(current)
                    current = predecessors[current]
                return path[::-1], current_dist

            if current_dist > distances.get(current_idx, float('inf')):
                continue

            # Explore neighbors
            for neighbor_idx, edge_dist in self.edges.get(current_idx, []):
                new_dist = current_dist + edge_dist

                if neighbor_idx not in distances or new_dist < distances[neighbor_idx]:
                    distances[neighbor_idx] = new_dist
                    predecessors[neighbor_idx] = current_idx
                    heapq.heappush(pq, (new_dist, neighbor_idx))

        return [], float('inf')  # No path found

    def plan_path(self, start: np.ndarray, goal: np.ndarray,
                  max_connection_dist: float = 1.0) -> Optional[List[np.ndarray]]:
        """
        Plan path from start to goal using PRM
        Args:
            start: Start configuration
            goal: Goal configuration
            max_connection_dist: Maximum distance to connect start/goal to roadmap
        Returns:
            List of configurations forming the path, or None if no path exists
        """
        # Ensure roadmap is built
        if len(self.vertices) == 0:
            self.build_roadmap()

        # Connect start and goal to roadmap
        start_connections = self.connect_query_config(start, max_connection_dist)
        goal_connections = self.connect_query_config(goal, max_connection_dist)

        if not start_connections or not goal_connections:
            return None  # Cannot connect start or goal to roadmap

        # Add temporary connections for start and goal
        temp_edges = {}
        start_vertex_idx = len(self.vertices)  # Virtual start vertex
        goal_vertex_idx = len(self.vertices) + 1  # Virtual goal vertex

        # Store original edges to restore later
        original_edges = self.edges.copy()

        # Add start connections
        temp_edges[start_vertex_idx] = []
        for conn_idx in start_connections:
            dist = self.distance_func(start, self.vertices[conn_idx])
            temp_edges[start_vertex_idx].append((conn_idx, dist))
            # Add reverse connection if it doesn't exist
            if conn_idx not in temp_edges:
                temp_edges[conn_idx] = original_edges.get(conn_idx, []).copy()
            temp_edges[conn_idx].append((start_vertex_idx, dist))

        # Add goal connections
        temp_edges[goal_vertex_idx] = []
        for conn_idx in goal_connections:
            dist = self.distance_func(goal, self.vertices[conn_idx])
            temp_edges[goal_vertex_idx].append((conn_idx, dist))
            # Add reverse connection if it doesn't exist
            if conn_idx not in temp_edges:
                temp_edges[conn_idx] = original_edges.get(conn_idx, []).copy()
            temp_edges[conn_idx].append((goal_vertex_idx, dist))

        # Update edges with temporary connections
        self.edges.update(temp_edges)

        # Find path using Dijkstra
        path_indices, _ = self.dijkstra_path(start_vertex_idx, goal_vertex_idx)

        # Restore original edges
        self.edges = original_edges

        if not path_indices:
            return None

        # Convert indices to configurations
        path_configs = []
        for idx in path_indices:
            if idx == start_vertex_idx:
                path_configs.append(start.copy())
            elif idx == goal_vertex_idx:
                path_configs.append(goal.copy())
            else:
                path_configs.append(self.vertices[idx].copy())

        return path_configs

# Example usage with a simple 2D environment
def create_2d_example():
    """Create a PRM planner example for 2D configuration space"""
    # Define workspace bounds
    workspace_bounds = np.array([[-5, 5], [-5, 5]])

    # Define obstacles as rectangles: [min_x, min_y, max_x, max_y]
    obstacles = [
        [-2, -2, -1, 2],  # Vertical obstacle
        [1, -1, 3, 1]     # Horizontal obstacle
    ]

    def sample_free_space():
        """Sample a configuration in free space"""
        for _ in range(100):  # Try up to 100 times
            config = np.random.uniform(workspace_bounds[:, 0], workspace_bounds[:, 1])

            # Check collision with obstacles
            in_collision = False
            for obs in obstacles:
                if (obs[0] <= config[0] <= obs[2] and obs[1] <= config[1] <= obs[3]):
                    in_collision = True
                    break

            if not in_collision:
                return config

        return None  # Failed to find free space

    def is_collision_free(config1, config2, num_samples=10):
        """Check if path between two configurations is collision-free"""
        for i in range(num_samples + 1):
            t = i / num_samples
            intermediate = (1 - t) * config1 + t * config2

            # Check collision with obstacles
            for obs in obstacles:
                if (obs[0] <= intermediate[0] <= obs[2] and obs[1] <= intermediate[1] <= obs[3]):
                    return False

        return True

    def distance_func(config1, config2):
        """Euclidean distance between configurations"""
        return np.linalg.norm(config1 - config2)

    # Create PRM planner
    prm = PRMPlanner(
        sample_free_space=sample_free_space,
        is_collision_free=is_collision_free,
        distance_func=distance_func,
        max_samples=500,
        k_nearest=10
    )

    # Plan path
    start = np.array([-4, -4])
    goal = np.array([4, 4])

    path = prm.plan_path(start, goal)

    if path:
        print(f"PRM found path with {len(path)} waypoints")
        print(f"Start: {start}, Goal: {goal}")
        print(f"Path length: {sum(np.linalg.norm(path[i+1] - path[i]) for i in range(len(path)-1)):.2f}")
    else:
        print("No path found")

    return prm

if __name__ == "__main__":
    prm_example = create_2d_example()
```

### PRM Variants and Optimizations

Several variants of PRM have been developed to improve performance:

#### PRM* (Probabilistic Roadmap Star)
PRM* extends PRM with asymptotic optimality by rewiring the roadmap to improve path quality over time.

#### Lazy-PRM
In Lazy-PRM, collision checking is deferred until path computation, reducing the number of expensive collision checks.

```python
class LazyPRMPlanner:
    def __init__(self,
                 sample_free_space: Callable[[], Optional[np.ndarray]],
                 distance_func: Callable[[np.ndarray, np.ndarray], float],
                 max_samples: int = 1000,
                 k_nearest: int = 10):
        """
        Lazy PRM planner - collision checking is done lazily during path planning
        """
        self.sample_free_space = sample_free_space
        self.distance_func = distance_func
        self.max_samples = max_samples
        self.k_nearest = k_nearest

        # Store all vertices and potential edges
        self.vertices: List[np.ndarray] = []
        self.potential_edges: Dict[int, List[Tuple[int, float]]] = {}

        # KDTree for nearest neighbor queries
        self.kdtree: Optional[KDTree] = None

    def build_roadmap(self):
        """Build roadmap without collision checking"""
        # Sample configurations
        for _ in range(self.max_samples):
            config = self.sample_free_space()
            if config is not None:
                self.vertices.append(config)

        if len(self.vertices) == 0:
            return

        # Build KDTree for efficient nearest neighbor queries
        vertex_array = np.array(self.vertices)
        self.kdtree = KDTree(vertex_array)

        # Connect to k nearest neighbors without collision checking
        for i, vertex in enumerate(self.vertices):
            distances, indices = self.kdtree.query(vertex, k=min(self.k_nearest + 1, len(self.vertices)))

            self.potential_edges[i] = []
            for dist, j in zip(distances, indices):
                if i != j and dist > 0:  # Don't connect to itself
                    self.potential_edges[i].append((j, dist))

    def is_collision_free(self, config1: np.ndarray, config2: np.ndarray,
                         num_samples: int = 10) -> bool:
        """Override this with specific collision checking for your environment"""
        # This is a placeholder - implement based on your specific environment
        return True

    def lazy_dijkstra_path(self, start_idx: int, goal_idx: int) -> Tuple[List[int], float]:
        """Lazy Dijkstra - check collisions only for edges on potential paths"""
        if start_idx not in self.potential_edges or goal_idx not in self.potential_edges:
            return [], float('inf')

        # Priority queue: (distance, vertex_idx)
        pq = [(0.0, start_idx)]

        # Distance dictionary
        distances = {start_idx: 0.0}

        # Predecessor dictionary for path reconstruction
        predecessors = {start_idx: None}

        while pq:
            current_dist, current_idx = heapq.heappop(pq)

            if current_idx == goal_idx:
                # Reconstruct path
                path = []
                current = goal_idx
                while current is not None:
                    path.append(current)
                    current = predecessors[current]
                return path[::-1], current_dist

            if current_dist > distances.get(current_idx, float('inf')):
                continue

            # Check neighbors and their collisions lazily
            for neighbor_idx, edge_dist in self.potential_edges.get(current_idx, []):
                # Check collision for this edge
                if not self.is_collision_free(self.vertices[current_idx],
                                            self.vertices[neighbor_idx]):
                    continue  # Skip this edge - it's in collision

                new_dist = current_dist + edge_dist

                if neighbor_idx not in distances or new_dist < distances[neighbor_idx]:
                    distances[neighbor_idx] = new_dist
                    predecessors[neighbor_idx] = current_idx
                    heapq.heappush(pq, (new_dist, neighbor_idx))

        return [], float('inf')
```

## Rapidly-exploring Random Trees (RRT)

RRT algorithms build a tree structure by incrementally growing from an initial configuration toward randomly sampled points in the configuration space. Unlike PRM, RRT is typically used for single-query scenarios.

### Basic RRT Algorithm

```python
import numpy as np
from typing import List, Tuple, Optional, Callable
import math

class RRTNode:
    def __init__(self, config: np.ndarray, parent: Optional['RRTNode'] = None,
                 cost: float = 0.0):
        self.config = config
        self.parent = parent
        self.cost = cost  # Cost from root to this node

class RRTPlanner:
    def __init__(self,
                 start_config: np.ndarray,
                 sample_free_space: Callable[[], Optional[np.ndarray]],
                 is_collision_free: Callable[[np.ndarray, np.ndarray], bool],
                 distance_func: Callable[[np.ndarray, np.ndarray], float],
                 step_size: float = 0.1,
                 max_iterations: int = 10000):
        """
        Initialize RRT planner
        Args:
            start_config: Starting configuration
            sample_free_space: Function to sample free configuration space
            is_collision_free: Function to check if path between configs is collision-free
            distance_func: Function to compute distance between configurations
            step_size: Maximum distance to extend tree in each iteration
            max_iterations: Maximum number of iterations
        """
        self.start_config = start_config
        self.sample_free_space = sample_free_space
        self.is_collision_free = is_collision_free
        self.distance_func = distance_func
        self.step_size = step_size
        self.max_iterations = max_iterations

        # Initialize tree with start node
        self.root = RRTNode(start_config)
        self.tree: List[RRTNode] = [self.root]

        # For efficient nearest neighbor search
        self.tree_configs = np.array([start_config])

    def nearest_node(self, target_config: np.ndarray) -> RRTNode:
        """Find the nearest node in the tree to the target configuration"""
        if len(self.tree) == 1:
            return self.root

        # Calculate distances to all nodes
        distances = [self.distance_func(node.config, target_config)
                    for node in self.tree]
        nearest_idx = np.argmin(distances)
        return self.tree[nearest_idx]

    def steer(self, from_config: np.ndarray,
              to_config: np.ndarray) -> np.ndarray:
        """Steer from from_config toward to_config by step_size"""
        dist = self.distance_func(from_config, to_config)

        if dist <= self.step_size:
            return to_config

        # Calculate direction vector and normalize
        direction = (to_config - from_config) / dist
        new_config = from_config + direction * self.step_size

        return new_config

    def plan_path(self, goal_config: np.ndarray,
                  goal_radius: float = 0.1) -> Optional[List[np.ndarray]]:
        """
        Plan path to goal configuration
        Args:
            goal_config: Goal configuration
            goal_radius: Distance threshold to consider goal reached
        Returns:
            List of configurations forming the path, or None if no path found
        """
        for iteration in range(self.max_iterations):
            # Sample random configuration (with occasional bias toward goal)
            if iteration % 10 == 0:  # Bias toward goal every 10th iteration
                random_config = goal_config
            else:
                random_config = self.sample_free_space()
                if random_config is None:
                    continue

            # Find nearest node in tree
            nearest = self.nearest_node(random_config)

            # Steer toward random configuration
            new_config = self.steer(nearest.config, random_config)

            # Check if path from nearest to new_config is collision-free
            if self.is_collision_free(nearest.config, new_config):
                # Calculate cost for new node
                cost = nearest.cost + self.distance_func(nearest.config, new_config)

                # Add new node to tree
                new_node = RRTNode(new_config, nearest, cost)
                self.tree.append(new_node)

                # Check if we're close enough to goal
                if self.distance_func(new_config, goal_config) <= goal_radius:
                    # Reconstruct path
                    path = []
                    current = new_node
                    while current is not None:
                        path.append(current.config.copy())
                        current = current.parent

                    return path[::-1]  # Reverse to get path from start to goal

        return None  # Failed to find path

# Example usage
def create_rrt_2d_example():
    """Create an RRT planner example for 2D configuration space"""
    # Define start configuration
    start = np.array([-4.0, -4.0])

    # Define workspace bounds
    workspace_bounds = np.array([[-5, 5], [-5, 5]])

    # Define obstacles as rectangles: [min_x, min_y, max_x, max_y]
    obstacles = [
        [-2, -2, -1, 2],  # Vertical obstacle
        [1, -1, 3, 1]     # Horizontal obstacle
    ]

    def sample_free_space():
        """Sample a configuration in free space"""
        for _ in range(100):  # Try up to 100 times
            config = np.random.uniform(workspace_bounds[:, 0], workspace_bounds[:, 1])

            # Check collision with obstacles
            in_collision = False
            for obs in obstacles:
                if (obs[0] <= config[0] <= obs[2] and obs[1] <= config[1] <= obs[3]):
                    in_collision = True
                    break

            if not in_collision:
                return config

        return None  # Failed to find free space

    def is_collision_free(config1, config2, num_samples=10):
        """Check if path between two configurations is collision-free"""
        for i in range(num_samples + 1):
            t = i / num_samples
            intermediate = (1 - t) * config1 + t * config2

            # Check collision with obstacles
            for obs in obstacles:
                if (obs[0] <= intermediate[0] <= obs[2] and obs[1] <= intermediate[1] <= obs[3]):
                    return False

        return True

    def distance_func(config1, config2):
        """Euclidean distance between configurations"""
        return np.linalg.norm(config1 - config2)

    # Create RRT planner
    rrt = RRTPlanner(
        start_config=start,
        sample_free_space=sample_free_space,
        is_collision_free=is_collision_free,
        distance_func=distance_func,
        step_size=0.5,
        max_iterations=5000
    )

    # Plan path to goal
    goal = np.array([4.0, 4.0])
    path = rrt.plan_path(goal, goal_radius=0.5)

    if path:
        print(f"RRT found path with {len(path)} waypoints")
        print(f"Start: {start}, Goal: {goal}")
        print(f"Path length: {sum(np.linalg.norm(path[i+1] - path[i]) for i in range(len(path)-1)):.2f}")
    else:
        print("No path found")

    return rrt

if __name__ == "__main__":
    rrt_example = create_rrt_2d_example()
```

### RRT* (Optimal RRT)

RRT* extends RRT to provide asymptotic optimality by rewiring the tree to find better paths over time.

```python
import numpy as np
from scipy.spatial import KDTree
from typing import List, Tuple, Optional, Callable
import math
import heapq

class RRTStarNode:
    def __init__(self, config: np.ndarray, parent: Optional['RRTStarNode'] = None,
                 cost: float = 0.0):
        self.config = config
        self.parent = parent
        self.cost = cost  # Cost from root to this node
        self.children: List[RRTStarNode] = []

class RRTStarPlanner:
    def __init__(self,
                 start_config: np.ndarray,
                 sample_free_space: Callable[[], Optional[np.ndarray]],
                 is_collision_free: Callable[[np.ndarray, np.ndarray], bool],
                 distance_func: Callable[[np.ndarray, np.ndarray], float],
                 step_size: float = 0.1,
                 max_iterations: int = 10000,
                 gamma: float = 1.0):
        """
        Initialize RRT* planner
        Args:
            start_config: Starting configuration
            sample_free_space: Function to sample free configuration space
            is_collision_free: Function to check if path between configs is collision-free
            distance_func: Function to compute distance between configurations
            step_size: Maximum distance to extend tree in each iteration
            max_iterations: Maximum number of iterations
            gamma: Parameter for rewiring radius calculation
        """
        self.start_config = start_config
        self.sample_free_space = sample_free_space
        self.is_collision_free = is_collision_free
        self.distance_func = distance_func
        self.step_size = step_size
        self.max_iterations = max_iterations
        self.gamma = gamma  # Rewiring parameter

        # Initialize tree with start node
        self.root = RRTStarNode(start_config)
        self.tree: List[RRTStarNode] = [self.root]

        # For efficient nearest neighbor search
        self.kdtree = KDTree([start_config])

    def steer(self, from_config: np.ndarray,
              to_config: np.ndarray) -> np.ndarray:
        """Steer from from_config toward to_config by step_size"""
        dist = self.distance_func(from_config, to_config)

        if dist <= self.step_size:
            return to_config

        # Calculate direction vector and normalize
        direction = (to_config - from_config) / dist
        new_config = from_config + direction * self.step_size

        return new_config

    def find_near_nodes(self, new_config: np.ndarray) -> List[RRTStarNode]:
        """Find nodes within rewiring radius of new_config"""
        n = len(self.tree)
        if n == 0:
            return []

        # Calculate rewiring radius based on RRT* theory
        unit_ball_volume = math.pi  # Volume of unit ball in 2D (adjust for higher dimensions)
        dim = len(new_config)  # Configuration space dimension
        volume_free = 1.0  # Approximate free space volume (simplified)

        # RRT* rewiring radius formula
        radius = self.gamma * ((math.log(n) / n) ** (1.0 / dim))

        # Find all nodes within radius
        indices = self.kdtree.query_ball_point(new_config, radius)
        return [self.tree[i] for i in indices]

    def plan_path(self, goal_config: np.ndarray,
                  goal_radius: float = 0.1) -> Optional[List[np.ndarray]]:
        """
        Plan path to goal configuration using RRT*
        Args:
            goal_config: Goal configuration
            goal_radius: Distance threshold to consider goal reached
        Returns:
            List of configurations forming the path, or None if no path found
        """
        best_goal_node = None
        best_cost = float('inf')

        for iteration in range(self.max_iterations):
            # Sample random configuration (with occasional bias toward goal)
            if iteration % 10 == 0:  # Bias toward goal every 10th iteration
                random_config = goal_config
            else:
                random_config = self.sample_free_space()
                if random_config is None:
                    continue

            # Find nearest node in tree
            distances, indices = self.kdtree.query(random_config, k=1)
            nearest = self.tree[indices]

            # Steer toward random configuration
            new_config = self.steer(nearest.config, random_config)

            # Check if path from nearest to new_config is collision-free
            if self.is_collision_free(nearest.config, new_config):
                # Find near nodes to potentially connect to
                near_nodes = self.find_near_nodes(new_config)

                # Find best parent among near nodes
                best_parent = nearest
                min_cost = nearest.cost + self.distance_func(nearest.config, new_config)

                for near_node in near_nodes:
                    cost_to_new = near_node.cost + self.distance_func(near_node.config, new_config)
                    if (cost_to_new < min_cost and
                        self.is_collision_free(near_node.config, new_config)):
                        min_cost = cost_to_new
                        best_parent = near_node

                # Add new node to tree with best parent
                new_node = RRTStarNode(new_config, best_parent, min_cost)
                self.tree.append(new_node)

                # Update parent's children list
                best_parent.children.append(new_node)

                # Update KDTree with new configuration
                self.kdtree = KDTree([node.config for node in self.tree])

                # Rewire: check if new node provides better path to near nodes
                for near_node in near_nodes:
                    if near_node == best_parent:
                        continue  # Skip the parent

                    cost_via_new = new_node.cost + self.distance_func(new_node.config, near_node.config)
                    if (cost_via_new < near_node.cost and
                        self.is_collision_free(new_node.config, near_node.config)):
                        # Update parent and cost
                        if near_node.parent:
                            # Remove from old parent's children
                            if near_node in near_node.parent.children:
                                near_node.parent.children.remove(near_node)
                        near_node.parent = new_node
                        near_node.cost = cost_via_new
                        new_node.children.append(near_node)

                # Check if we're close enough to goal and if it's the best path so far
                if self.distance_func(new_config, goal_config) <= goal_radius:
                    if min_cost < best_cost:
                        best_cost = min_cost
                        best_goal_node = new_node

        # If we found a path to goal, reconstruct it
        if best_goal_node is not None:
            path = []
            current = best_goal_node
            while current is not None:
                path.append(current.config.copy())
                current = current.parent

            return path[::-1]  # Reverse to get path from start to goal

        return None  # Failed to find path

# Example usage
def create_rrtstar_2d_example():
    """Create an RRT* planner example for 2D configuration space"""
    # Define start configuration
    start = np.array([-4.0, -4.0])

    # Define workspace bounds
    workspace_bounds = np.array([[-5, 5], [-5, 5]])

    # Define obstacles as rectangles: [min_x, min_y, max_x, max_y]
    obstacles = [
        [-2, -2, -1, 2],  # Vertical obstacle
        [1, -1, 3, 1]     # Horizontal obstacle
    ]

    def sample_free_space():
        """Sample a configuration in free space"""
        for _ in range(100):  # Try up to 100 times
            config = np.random.uniform(workspace_bounds[:, 0], workspace_bounds[:, 1])

            # Check collision with obstacles
            in_collision = False
            for obs in obstacles:
                if (obs[0] <= config[0] <= obs[2] and obs[1] <= config[1] <= obs[3]):
                    in_collision = True
                    break

            if not in_collision:
                return config

        return None  # Failed to find free space

    def is_collision_free(config1, config2, num_samples=10):
        """Check if path between two configurations is collision-free"""
        for i in range(num_samples + 1):
            t = i / num_samples
            intermediate = (1 - t) * config1 + t * config2

            # Check collision with obstacles
            for obs in obstacles:
                if (obs[0] <= intermediate[0] <= obs[2] and obs[1] <= intermediate[1] <= obs[3]):
                    return False

        return True

    def distance_func(config1, config2):
        """Euclidean distance between configurations"""
        return np.linalg.norm(config1 - config2)

    # Create RRT* planner
    rrtstar = RRTStarPlanner(
        start_config=start,
        sample_free_space=sample_free_space,
        is_collision_free=is_collision_free,
        distance_func=distance_func,
        step_size=0.5,
        max_iterations=5000,
        gamma=2.0  # Rewiring parameter
    )

    # Plan path to goal
    goal = np.array([4.0, 4.0])
    path = rrtstar.plan_path(goal, goal_radius=0.5)

    if path:
        print(f"RRT* found path with {len(path)} waypoints")
        print(f"Start: {start}, Goal: {goal}")
        path_length = sum(np.linalg.norm(path[i+1] - path[i]) for i in range(len(path)-1))
        print(f"Path length: {path_length:.2f}")
    else:
        print("No path found")

    return rrtstar

if __name__ == "__main__":
    rrtstar_example = create_rrtstar_2d_example()
```

## Advanced Sampling-Based Methods

### RRT-Connect

RRT-Connect uses two trees (one from start, one from goal) that grow toward each other, typically finding solutions faster than single-tree RRT.

```python
class RRTConnectPlanner:
    def __init__(self,
                 start_config: np.ndarray,
                 goal_config: np.ndarray,
                 sample_free_space: Callable[[], Optional[np.ndarray]],
                 is_collision_free: Callable[[np.ndarray, np.ndarray], bool],
                 distance_func: Callable[[np.ndarray, np.ndarray], float],
                 step_size: float = 0.1,
                 max_iterations: int = 10000):
        """
        Initialize RRT-Connect planner
        """
        self.start_config = start_config
        self.goal_config = goal_config
        self.sample_free_space = sample_free_space
        self.is_collision_free = is_collision_free
        self.distance_func = distance_func
        self.step_size = step_size
        self.max_iterations = max_iterations

        # Initialize start tree
        self.start_tree = [RRTNode(start_config)]
        self.goal_tree = [RRTNode(goal_config)]

        # For efficient nearest neighbor search
        self.start_tree_configs = np.array([start_config])
        self.goal_tree_configs = np.array([goal_config])

    def nearest_node(self, tree: List[RRTNode], tree_configs: np.ndarray,
                     target_config: np.ndarray) -> RRTNode:
        """Find the nearest node in the specified tree to the target configuration"""
        if len(tree) == 1:
            return tree[0]

        # Calculate distances to all nodes in the tree
        distances = [self.distance_func(config, target_config)
                    for config in tree_configs]
        nearest_idx = np.argmin(distances)
        return tree[nearest_idx]

    def steer(self, from_config: np.ndarray,
              to_config: np.ndarray) -> np.ndarray:
        """Steer from from_config toward to_config by step_size"""
        dist = self.distance_func(from_config, to_config)

        if dist <= self.step_size:
            return to_config

        # Calculate direction vector and normalize
        direction = (to_config - from_config) / dist
        new_config = from_config + direction * self.step_size

        return new_config

    def plan_path(self) -> Optional[List[np.ndarray]]:
        """
        Plan path using RRT-Connect
        Returns:
            List of configurations forming the path, or None if no path found
        """
        start_tree_root = self.start_tree[0]
        goal_tree_root = self.goal_tree[0]

        for iteration in range(self.max_iterations):
            # Alternate between growing start and goal trees
            if iteration % 2 == 0:
                # Grow start tree toward random sample or goal
                if iteration % 20 == 0:  # Occasionally sample goal
                    random_config = self.goal_config
                else:
                    random_config = self.sample_free_space()
                    if random_config is None:
                        continue

                # Find nearest in start tree
                nearest_start = self.nearest_node(self.start_tree,
                                                self.start_tree_configs,
                                                random_config)

                # Steer toward random config
                new_config = self.steer(nearest_start.config, random_config)

                if self.is_collision_free(nearest_start.config, new_config):
                    # Add to start tree
                    new_node = RRTNode(new_config, nearest_start)
                    self.start_tree.append(new_node)
                    self.start_tree_configs = np.vstack([self.start_tree_configs,
                                                        new_config.reshape(1, -1)])

                    # Try to connect to goal tree
                    nearest_goal = self.nearest_node(self.goal_tree,
                                                   self.goal_tree_configs,
                                                   new_config)

                    if self.distance_func(new_config, nearest_goal.config) <= self.step_size:
                        # Connect the trees
                        connection_config = self.steer(new_config, nearest_goal.config)
                        if self.is_collision_free(new_config, connection_config):
                            # Create connection node
                            connection_node = RRTNode(connection_config, new_node)

                            # Build path from start to goal
                            path = []
                            # Add path from start to connection
                            current = connection_node
                            while current is not None:
                                path.append(current.config.copy())
                                current = current.parent
                            path = path[::-1]  # Reverse to get start->connection order

                            # Add path from connection to goal
                            current = nearest_goal
                            while current != goal_tree_root:
                                path.append(current.config.copy())
                                current = current.parent
                            path.append(goal_tree_root.config.copy())

                            return path
            else:
                # Grow goal tree toward start tree
                nearest_goal = self.nearest_node(self.goal_tree,
                                               self.goal_tree_configs,
                                               self.start_tree[-1].config)

                new_config = self.steer(nearest_goal.config, self.start_tree[-1].config)

                if self.is_collision_free(nearest_goal.config, new_config):
                    # Add to goal tree
                    new_node = RRTNode(new_config, nearest_goal)
                    self.goal_tree.append(new_node)
                    self.goal_tree_configs = np.vstack([self.goal_tree_configs,
                                                       new_config.reshape(1, -1)])

        return None  # Failed to find path
```

## Sampling Strategies

The effectiveness of sampling-based planners heavily depends on the sampling strategy:

### Uniform Sampling
Simple random sampling across the entire configuration space.

### Gaussian Sampling
Focus sampling around obstacles or specific regions of interest.

### Bridge Sampling
For narrow passage problems, sample midpoints between collision configurations.

### Adaptive Sampling
Adjust sampling distribution based on planning progress.

## Theoretical Properties

### Probabilistic Completeness
Sampling-based planners are probabilistically complete, meaning that as the number of samples approaches infinity, the probability of finding a solution (if one exists) approaches 1.

### Asymptotic Optimality
Algorithms like PRM* and RRT* are asymptotically optimal, meaning they converge to the optimal solution as the number of samples increases.

## Practical Considerations

### Dimensionality Effects
Performance degrades significantly with increasing dimensionality due to the curse of dimensionality.

### Narrow Passage Problems
Sampling-based methods can struggle with narrow passages where the probability of sampling a configuration in the passage is low.

### Anytime Behavior
These algorithms can return intermediate solutions, making them suitable for real-time applications.

## Implementation Challenges

### Collision Detection
Efficient collision detection is crucial for performance. Techniques include:
- Bounding volume hierarchies (BVH)
- Spatial partitioning
- Incremental collision checking

### Nearest Neighbor Search
Efficient nearest neighbor search is essential. KD-trees, ball trees, or specialized libraries are commonly used.

### Memory Management
For large trees/roadmaps, memory usage can become a limiting factor.

## Applications

Sampling-based planners are widely used in:
- Mobile robot navigation
- Manipulator motion planning
- Multi-robot coordination
- Humanoid robot planning
- Aerospace applications

## Conclusion

Sampling-based motion planning algorithms provide a powerful approach to motion planning in high-dimensional spaces. Their probabilistic completeness and anytime behavior make them suitable for a wide range of applications. The choice between different sampling-based methods (PRM, RRT, RRT*, etc.) depends on the specific requirements of the application, including whether multi-query or single-query planning is needed, whether optimality is important, and the characteristics of the environment.
