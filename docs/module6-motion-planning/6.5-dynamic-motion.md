---
id: module6-motion-planning-6.5-dynamic-motion
title: "Dynamic Motion Planning"
slug: /module6-motion-planning-6.5-dynamic-motion
---

# Dynamic Motion Planning

Dynamic motion planning addresses the challenge of navigating in environments where obstacles, goals, or other elements change over time. Unlike static motion planning, where the environment is assumed fixed during planning, dynamic motion planning must account for temporal variations in the scene and adapt the robot's motion accordingly.

## Overview and Challenges

Dynamic motion planning involves planning trajectories for systems where the environment changes over time. Key challenges include:

1. **Temporal dimension**: The configuration space becomes spatiotemporal (x, y, z, t)
2. **Uncertainty**: Future states of dynamic obstacles may be uncertain
3. **Reactivity**: Need to adapt quickly to environmental changes
4. **Prediction**: Estimating future states of moving obstacles
5. **Computation**: Real-time requirements for replanning

The fundamental problem can be formulated as finding a time-parameterized path τ(t) such that:
- τ(t) ∈ C_free(t) for all t ∈ [t_start, t_goal]
- τ(t_start) = q_start, τ(t_goal) = q_goal
- ||τ̇(t)|| ≤ v_max (velocity constraints)

## Time-Space Planning Approaches

### 4D Configuration Space (Configuration-Time Space)

The most direct approach extends the configuration space to include time as an additional dimension, creating a 4D space (x, y, θ, t) for a planar robot.

```python
import numpy as np
from scipy.spatial import cKDTree
from typing import List, Tuple, Optional
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

class TimeSpacePlanner:
    def __init__(self, workspace_bounds: Tuple[Tuple[float, float], Tuple[float, float]],
                 time_horizon: float = 10.0, max_velocity: float = 1.0):
        """
        Time-space motion planner
        Args:
            workspace_bounds: ((min_x, max_x), (min_y, max_y))
            time_horizon: Maximum time to plan ahead
            max_velocity: Maximum robot velocity
        """
        self.workspace_bounds = workspace_bounds
        self.time_horizon = time_horizon
        self.max_velocity = max_velocity

        # Dynamic obstacles: list of [start_pos, velocity, appearance_time, disappearance_time]
        self.dynamic_obstacles = []

    def add_dynamic_obstacle(self, start_pos: np.ndarray, velocity: np.ndarray,
                           appearance_time: float, disappearance_time: float):
        """Add a dynamic obstacle that moves linearly"""
        self.dynamic_obstacles.append({
            'start_pos': start_pos,
            'velocity': velocity,
            'appearance': appearance_time,
            'disappearance': disappearance_time
        })

    def is_collision_free(self, config_time: np.ndarray) -> bool:
        """
        Check if configuration at time is collision-free
        Args:
            config_time: [x, y, t] - position and time
        """
        x, y, t = config_time

        # Check workspace bounds
        if not (self.workspace_bounds[0][0] <= x <= self.workspace_bounds[0][1] and
                self.workspace_bounds[1][0] <= y <= self.workspace_bounds[1][1]):
            return False

        # Check dynamic obstacles
        for obs in self.dynamic_obstacles:
            if obs['appearance'] <= t <= obs['disappearance']:
                # Calculate obstacle position at time t
                obs_pos = obs['start_pos'] + obs['velocity'] * t
                dist = np.linalg.norm([x - obs_pos[0], y - obs_pos[1]])

                # Assume circular obstacle with radius 0.2
                if dist < 0.2:
                    return False

        return True

    def get_obstacle_positions_at_time(self, t: float) -> List[np.ndarray]:
        """Get positions of all active obstacles at time t"""
        active_obstacles = []
        for obs in self.dynamic_obstacles:
            if obs['appearance'] <= t <= obs['disappearance']:
                pos = obs['start_pos'] + obs['velocity'] * t
                active_obstacles.append(pos)
        return active_obstacles

class RRTTimeSpace:
    def __init__(self, time_space_planner: TimeSpacePlanner, step_size: float = 0.1):
        """
        RRT in time-space
        """
        self.planner = time_space_planner
        self.step_size = step_size

        # Time dimension step size (dt)
        self.dt = 0.1  # Time resolution

        # Nodes: each node is [x, y, t]
        self.nodes = []
        self.edges = {}  # node_idx -> list of connected node indices

    def distance(self, config1: np.ndarray, config2: np.ndarray) -> float:
        """Distance in space-time (weighted)"""
        space_dist = np.linalg.norm(config1[:2] - config2[:2])
        time_dist = abs(config1[2] - config2[2])
        # Weight time and space dimensions appropriately
        return np.sqrt(space_dist**2 + (time_dist * self.planner.max_velocity)**2)

    def nearest_node(self, target: np.ndarray) -> int:
        """Find nearest node in tree"""
        if not self.nodes:
            return -1

        distances = [self.distance(node, target) for node in self.nodes]
        return np.argmin(distances)

    def steer(self, from_node: np.ndarray, to_node: np.ndarray) -> np.ndarray:
        """Steer from one node toward another"""
        dist = self.distance(from_node, to_node)

        if dist <= self.step_size:
            return to_node

        # Calculate direction vector
        direction = (to_node - from_node) / dist

        # Limit step size
        new_node = from_node + direction * self.step_size

        # Ensure time only moves forward
        new_node[2] = max(from_node[2], new_node[2])

        return new_node

    def plan(self, start_pos: np.ndarray, goal_pos: np.ndarray,
             start_time: float = 0.0, goal_time: float = None) -> Optional[List[np.ndarray]]:
        """
        Plan trajectory in time-space
        """
        if goal_time is None:
            # Estimate goal time based on distance
            dist = np.linalg.norm(goal_pos - start_pos)
            goal_time = start_time + dist / self.planner.max_velocity + 5.0  # Add buffer

        # Initialize tree with start node
        start_node = np.array([start_pos[0], start_pos[1], start_time])
        self.nodes = [start_node]
        self.edges[0] = []

        goal_region_radius = 0.3  # Acceptable distance to goal position
        goal_time_tolerance = 1.0  # Acceptable time difference

        for iteration in range(5000):  # Max iterations
            # Sample random configuration in time-space
            if iteration % 10 == 0:  # Bias toward goal
                # Sample near goal in both space and time
                goal_sample = np.array([
                    goal_pos[0] + np.random.uniform(-0.5, 0.5),
                    goal_pos[1] + np.random.uniform(-0.5, 0.5),
                    goal_time + np.random.uniform(-0.5, 0.5)
                ])
            else:
                # Sample in entire space-time volume
                goal_sample = np.array([
                    np.random.uniform(self.planner.workspace_bounds[0][0],
                                    self.planner.workspace_bounds[0][1]),
                    np.random.uniform(self.planner.workspace_bounds[1][0],
                                    self.planner.workspace_bounds[1][1]),
                    np.random.uniform(start_time, goal_time)
                ])

            # Find nearest node in tree
            nearest_idx = self.nearest_node(goal_sample)
            nearest_node = self.nodes[nearest_idx]

            # Steer toward random sample
            new_node = self.steer(nearest_node, goal_sample)

            # Check if path from nearest to new_node is collision-free
            # Use linear interpolation to check intermediate points
            num_checks = 5
            is_free = True
            for i in range(1, num_checks + 1):
                t_param = i / num_checks
                check_node = nearest_node + t_param * (new_node - nearest_node)
                if not self.planner.is_collision_free(check_node):
                    is_free = False
                    break

            if is_free:
                # Add new node to tree
                new_idx = len(self.nodes)
                self.nodes.append(new_node)
                self.edges[new_idx] = []
                self.edges[nearest_idx].append(new_idx)

                # Check if we're near the goal
                pos_dist = np.linalg.norm(new_node[:2] - goal_pos)
                time_dist = abs(new_node[2] - goal_time)

                if pos_dist <= goal_region_radius and time_dist <= goal_time_tolerance:
                    # Reconstruct path
                    path = self._reconstruct_path(new_idx)
                    return path

        return None  # Failed to find path

    def _reconstruct_path(self, goal_node_idx: int) -> List[np.ndarray]:
        """Reconstruct path from goal node back to start"""
        path = []
        current_idx = goal_node_idx

        # Build parent dictionary from edges
        parent_dict = {}
        for parent, children in self.edges.items():
            for child in children:
                parent_dict[child] = parent

        while current_idx is not None:
            path.append(self.nodes[current_idx])
            current_idx = parent_dict.get(current_idx)

        return path[::-1]

# Example usage
def example_time_space_planning():
    # Define workspace
    workspace = ((-5, 5), (-5, 5))

    # Create time-space planner
    tsp = TimeSpacePlanner(workspace, time_horizon=20.0, max_velocity=1.0)

    # Add dynamic obstacles
    tsp.add_dynamic_obstacle(
        start_pos=np.array([-2.0, 0.0]),
        velocity=np.array([0.5, 0.0]),  # Moving right
        appearance_time=2.0,
        disappearance_time=15.0
    )

    tsp.add_dynamic_obstacle(
        start_pos=np.array([0.0, -3.0]),
        velocity=np.array([0.0, 0.4]),  # Moving up
        appearance_time=5.0,
        disappearance_time=18.0
    )

    # Create RRT in time-space
    rrt_ts = RRTTimeSpace(tsp)

    # Define start and goal
    start_pos = np.array([-4.0, -4.0])
    goal_pos = np.array([4.0, 4.0])

    # Plan trajectory
    path = rrt_ts.plan(start_pos, goal_pos, start_time=0.0, goal_time=15.0)

    if path:
        print(f"Found path with {len(path)} waypoints")

        # Extract x, y, t components
        path_array = np.array(path)
        x_coords = path_array[:, 0]
        y_coords = path_array[:, 1]
        times = path_array[:, 2]

        print(f"Start: ({x_coords[0]:.2f}, {y_coords[0]:.2f}) at t={times[0]:.2f}")
        print(f"Goal: ({x_coords[-1]:.2f}, {y_coords[-1]:.2f}) at t={times[-1]:.2f}")

        # Visualize at different time slices
        visualize_time_space_path(tsp, path, goal_pos)
    else:
        print("No path found")

def visualize_time_space_path(tsp, path, goal_pos):
    """Visualize the path at different time slices"""
    if path is None:
        return

    path_array = np.array(path)

    # Create subplots for different time slices
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))
    axes = axes.flatten()

    # Different time slices
    time_slices = [0, 3, 6, 9, 12, 15]

    for i, t in enumerate(time_slices):
        ax = axes[i]

        # Plot static elements
        ax.set_xlim(tsp.workspace_bounds[0])
        ax.set_ylim(tsp.workspace_bounds[1])
        ax.set_title(f'Time: {t:.1f}s')
        ax.grid(True)

        # Plot goal
        ax.plot(goal_pos[0], goal_pos[1], 'r*', markersize=15, label='Goal')

        # Plot obstacles at this time
        obs_positions = tsp.get_obstacle_positions_at_time(t)
        for obs_pos in obs_positions:
            circle = plt.Circle((obs_pos[0], obs_pos[1]), 0.2, color='red', alpha=0.7)
            ax.add_patch(circle)

        # Plot path up to this time
        path_t = path_array[path_array[:, 2] <= t]
        if len(path_t) > 0:
            ax.plot(path_t[:, 0], path_t[:, 1], 'b-', linewidth=2, alpha=0.7, label='Path')
            ax.plot(path_t[-1, 0], path_t[-1, 1], 'go', markersize=8, label='Current Pos')

        ax.legend()

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    example_time_space_planning()
```

### Velocity Obstacles (VO) and Reciprocal Velocity Obstacles (RVO)

Velocity obstacles provide a geometric approach to collision avoidance by computing forbidden velocity regions.

```python
import numpy as np
from typing import List, Tuple, Optional
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
import math

class VelocityObstacle:
    def __init__(self, position: np.ndarray, velocity: np.ndarray,
                 radius: float, time_horizon: float = 5.0):
        """
        Represents a moving obstacle for VO/RVO calculations
        Args:
            position: Current position [x, y]
            velocity: Current velocity [vx, vy]
            radius: Radius of circular robot/obstacle
            time_horizon: Time horizon for VO calculation
        """
        self.position = position
        self.velocity = velocity
        self.radius = radius
        self.time_horizon = time_horizon

class VelocityObstaclePlanner:
    def __init__(self, robot_radius: float = 0.3, max_speed: float = 1.5,
                 time_horizon: float = 5.0):
        """
        Velocity obstacle based planner
        Args:
            robot_radius: Radius of the robot
            max_speed: Maximum speed of the robot
            time_horizon: Time horizon for planning
        """
        self.robot_radius = robot_radius
        self.max_speed = max_speed
        self.time_horizon = time_horizon
        self.obstacles: List[VelocityObstacle] = []

    def add_obstacle(self, position: np.ndarray, velocity: np.ndarray,
                    radius: float = 0.2):
        """Add a dynamic obstacle"""
        obs = VelocityObstacle(position, velocity, radius, self.time_horizon)
        self.obstacles.append(obs)

    def compute_velocity_obstacle(self, ego_obs: VelocityObstacle,
                                other_obs: VelocityObstacle) -> Optional[Tuple[np.ndarray, float]]:
        """
        Compute velocity obstacle for ego obstacle relative to other obstacle
        Returns: (apex, angle) of the cone, or None if no collision possible
        """
        # Relative position
        rel_pos = other_obs.position - ego_obs.position

        # Minimum distance needed to avoid collision
        min_dist = ego_obs.radius + other_obs.radius

        # If already colliding or very close, return full velocity space as forbidden
        dist = np.linalg.norm(rel_pos)
        if dist < min_dist:
            return np.array([0.0, 0.0]), 2 * np.pi  # Full circle

        # Time to collision if both continue on current trajectories
        rel_vel = other_obs.velocity - ego_obs.velocity
        rel_vel_mag = np.linalg.norm(rel_vel)

        if rel_vel_mag < 1e-6:  # If relative velocity is very small
            # If on collision course, return full forbidden region
            if dist < min_dist:
                return other_obs.velocity, 2 * np.pi
            else:
                return None  # No collision possible

        # Calculate the angle of the velocity obstacle cone
        closest_dist = abs(np.cross(rel_pos, rel_vel)) / rel_vel_mag

        # If closest approach distance is greater than minimum, no VO needed
        if closest_dist >= min_dist:
            return None

        # Calculate half-angle of the velocity obstacle cone
        sin_half_angle = min_dist / dist
        if sin_half_angle > 1.0:
            sin_half_angle = 1.0
        half_angle = np.arcsin(sin_half_angle)

        # Calculate the direction to the center of the VO
        rel_pos_angle = np.arctan2(rel_pos[1], rel_pos[0])
        center_angle = rel_pos_angle + np.pi  # Opposite direction

        # Apex of the VO in velocity space
        apex = other_obs.velocity

        return apex, half_angle

    def is_velocity_valid(self, velocity: np.ndarray, current_pos: np.ndarray) -> bool:
        """
        Check if a velocity is valid (not in any velocity obstacle)
        """
        # Check speed constraint
        speed = np.linalg.norm(velocity)
        if speed > self.max_speed:
            return False

        # Create a temporary ego obstacle for VO calculations
        ego_obs = VelocityObstacle(current_pos, velocity, self.robot_radius)

        for obs in self.obstacles:
            vo = self.compute_velocity_obstacle(ego_obs, obs)

            if vo is not None:
                apex, half_angle = vo

                # Check if the velocity falls within the forbidden cone
                rel_vel = velocity - apex
                rel_angle = np.arctan2(rel_vel[1], rel_vel[0])

                # Calculate angle relative to cone center
                center_angle = np.arctan2(obs.position[1] - current_pos[1],
                                        obs.position[0] - current_pos[0]) + np.pi

                angle_diff = abs(rel_angle - center_angle)
                if angle_diff > np.pi:
                    angle_diff = 2 * np.pi - angle_diff

                if angle_diff <= half_angle:
                    return False  # Velocity is in forbidden region

        return True

    def plan_velocity(self, current_pos: np.ndarray, desired_velocity: np.ndarray) -> np.ndarray:
        """
        Plan a safe velocity that avoids all velocity obstacles
        """
        # If desired velocity is valid, use it
        if self.is_velocity_valid(desired_velocity, current_pos):
            return desired_velocity

        # Otherwise, search for a valid velocity near the desired one
        # Try velocities in a grid around the desired velocity
        speed = np.linalg.norm(desired_velocity)
        if speed < 1e-6:
            desired_angle = 0
        else:
            desired_angle = np.arctan2(desired_velocity[1], desired_velocity[0])

        # Search in a spiral pattern around the desired direction
        for r in np.linspace(0.1, self.max_speed, 10):
            for angle_offset in np.linspace(0, 2*np.pi, 12):
                angle = desired_angle + angle_offset
                candidate_vel = np.array([r * np.cos(angle), r * np.sin(angle)])

                if self.is_velocity_valid(candidate_vel, current_pos):
                    return candidate_vel

        # If no valid velocity found near desired, return a safe default
        # For example, stop or move away from nearest obstacle
        if self.obstacles:
            # Move away from the nearest obstacle
            nearest_obs = min(self.obstacles,
                            key=lambda obs: np.linalg.norm(obs.position - current_pos))
            away_dir = current_pos - nearest_obs.position
            away_dir = away_dir / np.linalg.norm(away_dir)
            return 0.5 * self.max_speed * away_dir

        # If no obstacles, just return zero velocity
        return np.array([0.0, 0.0])

class ReciprocalVelocityObstaclePlanner(VelocityObstaclePlanner):
    def __init__(self, robot_radius: float = 0.3, max_speed: float = 1.5,
                 time_horizon: float = 5.0, neighbor_dist: float = 3.0):
        """
        Reciprocal Velocity Obstacle planner for multi-agent scenarios
        """
        super().__init__(robot_radius, max_speed, time_horizon)
        self.neighbor_dist = neighbor_dist
        self.agents: List[VelocityObstacle] = []

    def add_agent(self, position: np.ndarray, velocity: np.ndarray,
                  radius: float = 0.3):
        """Add another agent to the simulation"""
        agent = VelocityObstacle(position, velocity, radius, self.time_horizon)
        self.agents.append(agent)

    def compute_reciprocal_velocity_obstacle(self, ego_agent: VelocityObstacle,
                                           other_agent: VelocityObstacle) -> Optional[Tuple[np.ndarray, float]]:
        """
        Compute Reciprocal Velocity Obstacle (RVO)
        """
        # Relative position
        rel_pos = other_agent.position - ego_agent.position
        dist = np.linalg.norm(rel_pos)
        min_dist = ego_agent.radius + other_agent.radius

        if dist < min_dist:
            return np.array([0.0, 0.0]), 2 * np.pi  # Full circle if colliding

        # Calculate the RVO apex and opening angle
        # In RVO, we consider that both agents will change velocity
        rel_vel = other_agent.velocity - ego_agent.velocity
        minkowski_radius = min_dist  # Sum of radii for minkowski sum

        # If the relative velocity is inside the forbidden region,
        # the RVO is the same as the standard VO
        closest_dist = abs(np.cross(rel_pos, rel_vel)) / (np.linalg.norm(rel_vel) + 1e-6)

        if closest_dist >= minkowski_radius:
            return None  # No collision course

        # Calculate RVO parameters
        half_angle = np.arcsin(min_dist / dist) if dist > min_dist else np.pi/2
        center_direction = np.arctan2(rel_pos[1], rel_pos[0])

        # RVO apex is at the average of the two agent velocities
        rvo_apex = 0.5 * (ego_agent.velocity + other_agent.velocity)

        return rvo_apex, half_angle

    def is_velocity_valid_rvo(self, velocity: np.ndarray, current_pos: np.ndarray) -> bool:
        """
        Check if a velocity is valid using RVO
        """
        # Check speed constraint
        speed = np.linalg.norm(velocity)
        if speed > self.max_speed:
            return False

        # Create a temporary agent for RVO calculations
        temp_agent = VelocityObstacle(current_pos, velocity, self.robot_radius)

        # Check against other agents
        for agent in self.agents:
            # Skip if too far away
            if np.linalg.norm(agent.position - current_pos) > self.neighbor_dist:
                continue

            rvo = self.compute_reciprocal_velocity_obstacle(temp_agent, agent)

            if rvo is not None:
                apex, half_angle = rvo

                # Check if the velocity falls within the forbidden cone
                rel_vel = velocity - apex
                rel_angle = np.arctan2(rel_vel[1], rel_vel[0])

                center_angle = np.arctan2(agent.position[1] - current_pos[1],
                                        agent.position[0] - current_pos[0])

                angle_diff = abs(rel_angle - center_angle)
                if angle_diff > np.pi:
                    angle_diff = 2 * np.pi - angle_diff

                if angle_diff <= half_angle:
                    return False  # Velocity is in forbidden region

        return True

    def plan_velocity_rvo(self, current_pos: np.ndarray,
                         desired_velocity: np.ndarray) -> np.ndarray:
        """
        Plan a safe velocity using RVO
        """
        # If desired velocity is valid, use it
        if self.is_velocity_valid_rvo(desired_velocity, current_pos):
            return desired_velocity

        # Otherwise, search for a valid velocity near the desired one
        speed = np.linalg.norm(desired_velocity)
        if speed < 1e-6:
            desired_angle = 0
        else:
            desired_angle = np.arctan2(desired_velocity[1], desired_velocity[0])

        # Search in a spiral pattern around the desired direction
        for r in np.linspace(0.1, min(speed, self.max_speed), 8):
            for angle_offset in np.linspace(0, 2*np.pi, 12):
                angle = desired_angle + angle_offset
                candidate_vel = np.array([r * np.cos(angle), r * np.sin(angle)])

                if self.is_velocity_valid_rvo(candidate_vel, current_pos):
                    return candidate_vel

        # If no valid velocity found, try to move away from nearest agent
        if self.agents:
            nearest_agent = min(self.agents,
                              key=lambda a: np.linalg.norm(a.position - current_pos))
            away_dir = current_pos - nearest_agent.position
            away_dir = away_dir / (np.linalg.norm(away_dir) + 1e-6)
            return 0.3 * self.max_speed * away_dir

        # If no agents nearby, return zero velocity
        return np.array([0.0, 0.0])

# Example usage
def example_velocity_obstacles():
    # Create VO planner
    vo_planner = VelocityObstaclePlanner(robot_radius=0.3, max_speed=1.5)

    # Add some moving obstacles
    vo_planner.add_obstacle(np.array([2.0, 1.0]), np.array([-0.5, 0.2]), radius=0.2)
    vo_planner.add_obstacle(np.array([-1.0, 2.0]), np.array([0.3, -0.4]), radius=0.2)
    vo_planner.add_obstacle(np.array([0.0, -2.0]), np.array([0.1, 0.6]), radius=0.2)

    # Current position and desired velocity
    current_pos = np.array([-3.0, -3.0])
    desired_vel = np.array([0.8, 0.8])  # Want to go to upper right

    # Plan a safe velocity
    safe_vel = vo_planner.plan_velocity(current_pos, desired_vel)

    print(f"Desired velocity: {desired_vel}")
    print(f"Safe velocity: {safe_vel}")
    print(f"Speed: {np.linalg.norm(safe_vel):.2f}")

    # Visualize the scenario
    visualize_velocity_obstacles(vo_planner, current_pos, desired_vel, safe_vel)

def visualize_velocity_obstacles(vo_planner, current_pos, desired_vel, safe_vel):
    """Visualize velocity obstacles and planned velocities"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

    # Plot 1: Spatial view
    ax1.set_xlim(-4, 4)
    ax1.set_ylim(-4, 4)
    ax1.set_aspect('equal')
    ax1.grid(True)
    ax1.set_title('Spatial View')

    # Plot robot
    robot_circle = plt.Circle((current_pos[0], current_pos[1]), vo_planner.robot_radius,
                             color='blue', alpha=0.5, label='Robot')
    ax1.add_patch(robot_circle)
    ax1.arrow(current_pos[0], current_pos[1], desired_vel[0], desired_vel[1],
              head_width=0.1, head_length=0.1, fc='red', ec='red', label='Desired vel')
    ax1.arrow(current_pos[0], current_pos[1], safe_vel[0], safe_vel[1],
              head_width=0.1, head_length=0.1, fc='green', ec='green', label='Safe vel')

    # Plot obstacles
    for obs in vo_planner.obstacles:
        obs_circle = plt.Circle((obs.position[0], obs.position[1]), obs.radius,
                               color='red', alpha=0.5)
        ax1.add_patch(obs_circle)
        # Plot velocity vector
        ax1.arrow(obs.position[0], obs.position[1], obs.velocity[0], obs.velocity[1],
                  head_width=0.1, head_length=0.1, fc='orange', ec='orange')

    ax1.legend()

    # Plot 2: Velocity space
    ax2.set_xlim(-2, 2)
    ax2.set_ylim(-2, 2)
    ax2.set_aspect('equal')
    ax2.grid(True)
    ax2.set_title('Velocity Space')

    # Draw maximum speed circle
    max_speed_circle = plt.Circle((0, 0), vo_planner.max_speed,
                                 color='gray', alpha=0.2, linestyle='--', label='Max speed')
    ax2.add_patch(max_speed_circle)

    # Plot desired and safe velocities
    ax2.arrow(0, 0, desired_vel[0], desired_vel[1],
              head_width=0.05, head_length=0.05, fc='red', ec='red', label='Desired vel')
    ax2.arrow(0, 0, safe_vel[0], safe_vel[1],
              head_width=0.05, head_length=0.05, fc='green', ec='green', label='Safe vel')

    # Draw velocity obstacles
    ego_obs = VelocityObstacle(current_pos, np.array([0.0, 0.0]), vo_planner.robot_radius)
    for obs in vo_planner.obstacles:
        vo = vo_planner.compute_velocity_obstacle(ego_obs, obs)
        if vo is not None:
            apex, half_angle = vo
            # Draw a simple representation of the VO cone
            angles = np.linspace(-half_angle, half_angle, 20)
            points = []
            for angle in angles:
                x = apex[0] + 0.5 * np.cos(angle + np.arctan2(obs.position[1] - current_pos[1],
                                                            obs.position[0] - current_pos[0]) + np.pi)
                y = apex[1] + 0.5 * np.sin(angle + np.arctan2(obs.position[1] - current_pos[1],
                                                            obs.position[0] - current_pos[0]) + np.pi)
                points.append([x, y])
            points.append([apex[0], apex[1]])  # Close the cone
            polygon = Polygon(points, closed=True, color='red', alpha=0.3, label='VO')
            ax2.add_patch(polygon)

    ax2.legend()

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    example_velocity_obstacles()
```

## Temporal Roadmaps

Temporal roadmaps extend traditional roadmaps to include the time dimension, creating a spatio-temporal graph that can be searched for feasible trajectories.

```python
import numpy as np
from typing import List, Tuple, Optional, Dict
import heapq
from scipy.spatial import cKDTree

class TemporalNode:
    def __init__(self, config: np.ndarray, time: float, cost: float = 0.0):
        self.config = config  # Configuration (x, y, theta, ...)
        self.time = time      # Time
        self.cost = cost      # Cost from start
        self.parent: Optional['TemporalNode'] = None

class TemporalRoadmap:
    def __init__(self, max_time_step: float = 1.0, collision_check_resolution: int = 5):
        """
        Temporal roadmap for dynamic motion planning
        Args:
            max_time_step: Maximum time difference between connected nodes
            collision_check_resolution: Number of intermediate points to check for collision
        """
        self.max_time_step = max_time_step
        self.collision_check_resolution = collision_check_resolution

        # Nodes in the temporal roadmap
        self.nodes: List[TemporalNode] = []

        # Edges: node_idx -> list of (connected_node_idx, edge_cost)
        self.edges: Dict[int, List[Tuple[int, float]]] = {}

        # KDTree for spatial queries (ignoring time dimension)
        self.spatial_tree: Optional[cKDTree] = None

        # For dynamic obstacle management
        self.dynamic_obstacles = []

    def add_dynamic_obstacle(self, trajectory_func, appearance_time: float,
                           disappearance_time: float, radius: float = 0.2):
        """
        Add a dynamic obstacle with a trajectory function
        trajectory_func(t) -> [x, y] position at time t
        """
        self.dynamic_obstacles.append({
            'trajectory': trajectory_func,
            'appearance': appearance_time,
            'disappearance': disappearance_time,
            'radius': radius
        })

    def is_collision_free_path(self, start_config: np.ndarray, start_time: float,
                              end_config: np.ndarray, end_time: float) -> bool:
        """
        Check if path between two space-time points is collision-free
        """
        # Check time validity
        if abs(end_time - start_time) > self.max_time_step:
            return False

        # Check for collisions at intermediate points
        num_checks = self.collision_check_resolution
        for i in range(num_checks + 1):
            t_param = i / num_checks
            check_time = start_time + t_param * (end_time - start_time)
            check_config = (1 - t_param) * start_config + t_param * end_config

            if not self.is_collision_free(check_config, check_time):
                return False

        return True

    def is_collision_free(self, config: np.ndarray, time: float) -> bool:
        """
        Check if configuration at given time is collision-free
        """
        # Check against dynamic obstacles
        for obs in self.dynamic_obstacles:
            if obs['appearance'] <= time <= obs['disappearance']:
                obs_pos = obs['trajectory'](time)
                dist = np.linalg.norm(config[:2] - obs_pos[:2])  # Assuming 2D position
                if dist < obs['radius']:
                    return False

        # Here you would also check against static obstacles if needed
        # For this example, we assume no static obstacles

        return True

    def add_node(self, config: np.ndarray, time: float) -> int:
        """Add a node to the temporal roadmap"""
        node = TemporalNode(config, time)
        idx = len(self.nodes)
        self.nodes.append(node)

        # Update spatial tree
        if self.spatial_tree is not None:
            # This is a simplified update; in practice, rebuilding might be needed
            pass

        return idx

    def connect_nearby_nodes(self, new_node_idx: int, max_dist: float = 1.0):
        """
        Connect the new node to nearby nodes in space and time
        """
        new_node = self.nodes[new_node_idx]

        for i, node in enumerate(self.nodes):
            if i == new_node_idx:
                continue

            # Check spatial distance
            spatial_dist = np.linalg.norm(new_node.config - node.config)

            # Check temporal distance
            temporal_dist = abs(new_node.time - node.time)

            # Connect if both spatially and temporally close
            if (spatial_dist <= max_dist and
                temporal_dist <= self.max_time_step and
                temporal_dist > 0):  # Don't connect to itself in time

                # Ensure the connection respects causality (time forward)
                if new_node.time > node.time:
                    # Check if connection is collision-free
                    if self.is_collision_free_path(node.config, node.time,
                                                 new_node.config, new_node.time):
                        edge_cost = spatial_dist + 0.1 * temporal_dist  # Time penalty

                        if i not in self.edges:
                            self.edges[i] = []
                        self.edges[i].append((new_node_idx, edge_cost))

                        # Add reverse edge for bidirectional search
                        if new_node_idx not in self.edges:
                            self.edges[new_node_idx] = []
                        self.edges[new_node_idx].append((i, edge_cost))

    def plan_trajectory(self, start_config: np.ndarray, start_time: float,
                       goal_config: np.ndarray, goal_time: float = None,
                       time_horizon: float = 20.0) -> Optional[List[TemporalNode]]:
        """
        Plan trajectory using temporal roadmap and Dijkstra's algorithm
        """
        if goal_time is None:
            # Estimate goal time based on distance
            dist = np.linalg.norm(goal_config - start_config)
            goal_time = start_time + dist + 5.0  # Add buffer

        # Add start and goal nodes
        start_idx = self.add_node(start_config, start_time)
        goal_idx = self.add_node(goal_config, goal_time)

        # Connect nearby nodes to start and goal
        self.connect_nearby_nodes(start_idx)
        self.connect_nearby_nodes(goal_idx)

        # Use Dijkstra's algorithm to find shortest path
        distances = {i: float('inf') for i in range(len(self.nodes))}
        distances[start_idx] = 0
        previous = {i: None for i in range(len(self.nodes))}

        pq = [(0, start_idx)]
        visited = set()

        while pq:
            current_dist, current_idx = heapq.heappop(pq)

            if current_idx in visited:
                continue

            visited.add(current_idx)

            if current_idx == goal_idx:
                # Reconstruct path
                path = []
                curr = goal_idx
                while curr is not None:
                    path.append(self.nodes[curr])
                    curr = previous[curr]
                return path[::-1]

            # Explore neighbors
            for neighbor_idx, edge_cost in self.edges.get(current_idx, []):
                if neighbor_idx not in visited:
                    new_dist = current_dist + edge_cost
                    if new_dist < distances[neighbor_idx]:
                        distances[neighbor_idx] = new_dist
                        previous[neighbor_idx] = current_idx
                        heapq.heappush(pq, (new_dist, neighbor_idx))

        return None  # No path found

# Example trajectory function for a moving obstacle
def circular_trajectory(center=np.array([0.0, 0.0]), radius=2.0, angular_vel=0.5):
    """
    Return a trajectory function for circular motion
    """
    def trajectory(t):
        angle = angular_vel * t
        return center + np.array([radius * np.cos(angle), radius * np.sin(angle)])
    return trajectory

# Example usage
def example_temporal_roadmap():
    # Create temporal roadmap
    tr = TemporalRoadmap(max_time_step=2.0)

    # Add a moving obstacle in circular motion
    circular_obs_trajectory = circular_trajectory(center=np.array([0.0, 0.0]),
                                                radius=2.0, angular_vel=0.5)
    tr.add_dynamic_obstacle(circular_obs_trajectory, appearance_time=0.0,
                          disappearance_time=30.0, radius=0.3)

    # Define start and goal
    start_config = np.array([-3.0, -3.0])
    goal_config = np.array([3.0, 3.0])

    # Plan trajectory
    path = tr.plan_trajectory(start_config, start_time=0.0,
                             goal_config=goal_config, goal_time=20.0)

    if path:
        print(f"Found trajectory with {len(path)} waypoints")

        # Extract path information
        for i, node in enumerate(path):
            print(f"Step {i}: Pos=({node.config[0]:.2f}, {node.config[1]:.2f}), Time={node.time:.2f}, Cost={node.cost:.2f}")
    else:
        print("No trajectory found")

if __name__ == "__main__":
    example_temporal_roadmap()
```

## Trajectory Tracking and Feedback Control

Dynamic motion planning often requires trajectory tracking with feedback control to handle uncertainties and disturbances.

```python
import numpy as np
from typing import List, Tuple
import matplotlib.pyplot as plt

class PIDController:
    def __init__(self, kp: float, ki: float, kd: float, dt: float = 0.01):
        """
        PID controller for trajectory tracking
        Args:
            kp: Proportional gain
            ki: Integral gain
            kd: Derivative gain
            dt: Time step
        """
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.dt = dt

        self.prev_error = 0.0
        self.integral = 0.0

    def update(self, error: float) -> float:
        """
        Update PID controller and return control output
        """
        self.integral += error * self.dt
        derivative = (error - self.prev_error) / self.dt

        output = (self.kp * error +
                 self.ki * self.integral +
                 self.kd * derivative)

        self.prev_error = error
        return output

class DynamicTrajectoryTracker:
    def __init__(self, max_linear_vel: float = 1.0, max_angular_vel: float = 1.0,
                 pos_gain: float = 2.0, orient_gain: float = 2.0):
        """
        Dynamic trajectory tracker with feedback control
        """
        self.max_linear_vel = max_linear_vel
        self.max_angular_vel = max_angular_vel

        # Gains for position and orientation control
        self.pos_gain = pos_gain
        self.orient_gain = orient_gain

        # PID controllers for different aspects
        self.x_pid = PIDController(2.0, 0.1, 0.05)
        self.y_pid = PIDController(2.0, 0.1, 0.05)
        self.theta_pid = PIDController(2.0, 0.1, 0.05)

    def track_trajectory(self, current_state: np.ndarray,
                        reference_trajectory: List[np.ndarray],
                        current_time: float,
                        dt: float = 0.1) -> Tuple[np.ndarray, float]:
        """
        Track reference trajectory with feedback control
        Args:
            current_state: [x, y, theta, vx, vy, omega]
            reference_trajectory: List of [x, y, theta, time] waypoints
            current_time: Current simulation time
            dt: Time step
        Returns:
            (control_input [v_linear, omega], time_to_next_waypoint)
        """
        x, y, theta, vx, vy, omega = current_state

        # Find the closest reference point in time
        closest_ref_idx = 0
        min_time_diff = float('inf')

        for i, ref_point in enumerate(reference_trajectory):
            ref_x, ref_y, ref_theta, ref_time = ref_point
            time_diff = abs(ref_time - current_time)
            if time_diff < min_time_diff:
                min_time_diff = time_diff
                closest_ref_idx = i

        # Get the reference state
        ref_x, ref_y, ref_theta, ref_time = reference_trajectory[closest_ref_idx]

        # Calculate position errors
        pos_error_x = ref_x - x
        pos_error_y = ref_y - y
        pos_error = np.sqrt(pos_error_x**2 + pos_error_y**2)

        # Calculate orientation error
        orient_error = ref_theta - theta
        # Normalize angle to [-pi, pi]
        while orient_error > np.pi:
            orient_error -= 2 * np.pi
        while orient_error < -np.pi:
            orient_error += 2 * np.pi

        # PID control for position
        v_x_ref = self.x_pid.update(pos_error_x)
        v_y_ref = self.y_pid.update(pos_error_y)

        # Calculate desired linear and angular velocities
        desired_linear_vel = np.sqrt(v_x_ref**2 + v_y_ref**2)
        desired_angular_vel = self.theta_pid.update(orient_error)

        # Apply velocity limits
        desired_linear_vel = np.clip(desired_linear_vel,
                                   -self.max_linear_vel, self.max_linear_vel)
        desired_angular_vel = np.clip(desired_angular_vel,
                                    -self.max_angular_vel, self.max_angular_vel)

        # Calculate time to reach next waypoint (simplified)
        time_to_next = dt

        return np.array([desired_linear_vel, desired_angular_vel]), time_to_next

    def simulate_with_tracking(self, initial_state: np.ndarray,
                             reference_trajectory: List[np.ndarray],
                             simulation_time: float = 20.0,
                             dt: float = 0.1) -> Tuple[List[np.ndarray], List[np.ndarray]]:
        """
        Simulate the system tracking the reference trajectory
        """
        # State: [x, y, theta, vx, vy, omega]
        current_state = initial_state.copy()

        # Store trajectory for visualization
        actual_trajectory = [current_state[:3]]  # Only position and orientation
        control_inputs = []

        time_points = np.arange(0, simulation_time, dt)

        for t in time_points:
            # Get control input
            control_input, _ = self.track_trajectory(current_state,
                                                   reference_trajectory, t, dt)
            v_linear, omega = control_input

            # Apply control to system (simple kinematic model)
            x, y, theta, vx, vy, v_omega = current_state

            # Update state based on control input
            new_theta = theta + omega * dt
            new_x = x + v_linear * np.cos(new_theta) * dt
            new_y = y + v_linear * np.sin(new_theta) * dt

            # Update velocities (simplified)
            new_vx = v_linear * np.cos(new_theta)
            new_vy = v_linear * np.sin(new_theta)
            new_vomega = omega

            current_state = np.array([new_x, new_y, new_theta, new_vx, new_vy, new_vomega])

            actual_trajectory.append(current_state[:3])
            control_inputs.append(control_input.copy())

        return actual_trajectory, control_inputs

# Example usage
def example_trajectory_tracking():
    # Create a reference trajectory (a simple path)
    time_points = np.linspace(0, 20, 100)
    ref_trajectory = []

    # Create a curved path
    for t in time_points:
        x = 2 * np.sin(0.2 * t)  # Oscillating x
        y = 0.5 * t - 5          # Linear y with offset
        theta = np.arctan2(0.5, 0.4 * np.cos(0.2 * t))  # Heading angle
        ref_trajectory.append(np.array([x, y, theta, t]))

    # Initial state [x, y, theta, vx, vy, omega]
    initial_state = np.array([-1.0, -5.0, 0.0, 0.0, 0.0, 0.0])

    # Create tracker
    tracker = DynamicTrajectoryTracker(max_linear_vel=1.5, max_angular_vel=1.0)

    # Simulate tracking
    actual_traj, controls = tracker.simulate_with_tracking(
        initial_state, ref_trajectory, simulation_time=20.0, dt=0.1)

    print(f"Simulated {len(actual_traj)} time steps")

    # Visualize results
    visualize_tracking_results(ref_trajectory, actual_traj, controls)

def visualize_tracking_results(ref_trajectory, actual_traj, controls):
    """Visualize the trajectory tracking results"""
    # Extract x, y coordinates
    ref_array = np.array(ref_trajectory)
    actual_array = np.array(actual_traj)
    control_array = np.array(controls)

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))

    # Plot 1: Trajectory in space
    ax1.plot(ref_array[:, 0], ref_array[:, 1], 'r-', linewidth=2, label='Reference')
    ax1.plot(actual_array[:, 0], actual_array[:, 1], 'b-', linewidth=2, label='Actual')
    ax1.scatter([actual_array[0, 0]], [actual_array[0, 1]], color='green', s=100, label='Start')
    ax1.scatter([actual_array[-1, 0]], [actual_array[-1, 1]], color='red', s=100, label='End')
    ax1.set_xlabel('X Position')
    ax1.set_ylabel('Y Position')
    ax1.set_title('Trajectory Tracking in Space')
    ax1.grid(True)
    ax1.legend()
    ax1.axis('equal')

    # Plot 2: Position errors over time
    time_ref = ref_array[:, 3]  # Time from reference trajectory
    time_actual = np.linspace(0, len(actual_array)-1, len(actual_array)) * 0.1  # Assuming dt=0.1

    # Interpolate reference trajectory to match actual time steps
    from scipy.interpolate import interp1d

    ref_x_interp = interp1d(ref_array[:, 3], ref_array[:, 0], bounds_error=False, fill_value="extrapolate")
    ref_y_interp = interp1d(ref_array[:, 3], ref_array[:, 1], bounds_error=False, fill_value="extrapolate")

    actual_x = actual_array[:, 0]
    actual_y = actual_array[:, 1]

    ref_x_at_actual_times = ref_x_interp(time_actual)
    ref_y_at_actual_times = ref_y_interp(time_actual)

    pos_errors = np.sqrt((actual_x - ref_x_at_actual_times)**2 +
                        (actual_y - ref_y_at_actual_times)**2)

    ax2.plot(time_actual, pos_errors, 'r-', linewidth=2)
    ax2.set_xlabel('Time (s)')
    ax2.set_ylabel('Position Error')
    ax2.set_title('Position Tracking Error Over Time')
    ax2.grid(True)

    # Plot 3: Linear velocity over time
    if len(controls) > 0:
        ax3.plot(time_actual[:-1], control_array[:, 0], 'g-', linewidth=2, label='Linear Velocity')
        ax3.set_xlabel('Time (s)')
        ax3.set_ylabel('Linear Velocity (m/s)')
        ax3.set_title('Control Inputs: Linear Velocity')
        ax3.grid(True)
        ax3.legend()

    # Plot 4: Angular velocity over time
    if len(controls) > 0:
        ax4.plot(time_actual[:-1], control_array[:, 1], 'm-', linewidth=2, label='Angular Velocity')
        ax4.set_xlabel('Time (s)')
        ax4.set_ylabel('Angular Velocity (rad/s)')
        ax4.set_title('Control Inputs: Angular Velocity')
        ax4.grid(True)
        ax4.legend()

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    example_trajectory_tracking()
```

## Applications and Considerations

### Multi-Robot Coordination

Dynamic motion planning becomes significantly more complex when multiple robots must coordinate their movements while avoiding collisions with each other and dynamic obstacles.

### Uncertainty Handling

Real-world dynamic planning must account for uncertainty in:
- Obstacle predictions
- Robot state estimation
- Environmental changes

### Real-time Considerations

For real-time applications, dynamic motion planning algorithms must balance:
- Computational efficiency
- Solution quality
- Replanning frequency

## Conclusion

Dynamic motion planning addresses the critical challenge of navigating in time-varying environments. The approaches covered, from time-space planning to velocity obstacles and trajectory tracking, provide different ways to handle dynamic scenarios. The choice of approach depends on the specific requirements of the application, including real-time constraints, uncertainty levels, and the nature of dynamic elements in the environment. Modern robotics systems often combine multiple approaches, using hierarchical planning where high-level planners generate rough spatiotemporal paths that are refined by low-level trajectory trackers with feedback control.
