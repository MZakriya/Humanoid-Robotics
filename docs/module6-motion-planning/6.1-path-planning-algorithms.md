---
id: module6-motion-planning-6.1-path-planning-algorithms
title: "Path Planning Algorithms"
slug: /module6-motion-planning-6.1-path-planning-algorithms
---

# Path Planning Algorithms

Path planning is a fundamental problem in robotics that involves finding a collision-free path from a start configuration to a goal configuration while optimizing for various criteria such as path length, safety, or energy consumption. This chapter explores classical and modern approaches to path planning, from discrete graph-based algorithms to sampling-based methods that handle high-dimensional configuration spaces.

## Overview of Path Planning

Path planning algorithms can be broadly categorized into several classes:

- **Discrete/Graph-based Methods**: Work on discretized representations of the environment
- **Sampling-based Methods**: Explore the configuration space through random sampling
- **Optimization-based Methods**: Formulate path planning as an optimization problem
- **Learning-based Methods**: Use machine learning to learn effective path planning strategies

The choice of algorithm depends on the robot's configuration space, environment complexity, real-time requirements, and optimality constraints.

## Classical Graph-based Algorithms

### Dijkstra's Algorithm

Dijkstra's algorithm is a classic shortest path algorithm that systematically explores all possible paths from the start node, guaranteeing the optimal solution in terms of path cost. It works by maintaining a priority queue of nodes to visit, always expanding the node with the lowest accumulated cost.

```python
import heapq
from typing import List, Tuple, Dict, Set
import numpy as np

class DijkstraPathPlanner:
    def __init__(self, grid: np.ndarray):
        """
        Initialize Dijkstra path planner with a grid representation
        Args:
            grid: 2D numpy array where 0 = free space, 1 = obstacle
        """
        self.grid = grid
        self.rows, self.cols = grid.shape
        self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1),  # 4-connectivity
                          (-1, -1), (-1, 1), (1, -1), (1, 1)]  # Diagonals

    def euclidean_distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """Calculate Euclidean distance between two positions"""
        return np.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

    def is_valid(self, row: int, col: int) -> bool:
        """Check if position is valid (within bounds and not an obstacle)"""
        return (0 <= row < self.rows and
                0 <= col < self.cols and
                self.grid[row][col] == 0)

    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Plan path using Dijkstra's algorithm
        Args:
            start: Starting position (row, col)
            goal: Goal position (row, col)
        Returns:
            List of positions forming the path, or empty list if no path exists
        """
        # Priority queue: (cost, row, col)
        pq = [(0, start[0], start[1])]

        # Cost dictionary: position -> minimum cost to reach
        costs = {start: 0}

        # Parent dictionary for path reconstruction
        parents = {start: None}

        # Visited set to avoid revisiting nodes
        visited = set()

        while pq:
            current_cost, row, col = heapq.heappop(pq)
            current_pos = (row, col)

            # If we reached the goal, reconstruct path
            if current_pos == goal:
                return self._reconstruct_path(parents, start, goal)

            # Skip if already visited
            if current_pos in visited:
                continue

            visited.add(current_pos)

            # Explore neighbors
            for dr, dc in self.directions:
                neighbor_pos = (row + dr, col + dc)

                if self.is_valid(neighbor_pos[0], neighbor_pos[1]) and neighbor_pos not in visited:
                    # Calculate movement cost (diagonal vs orthogonal)
                    move_cost = np.sqrt(2) if abs(dr) == 1 and abs(dc) == 1 else 1.0
                    new_cost = current_cost + move_cost

                    # If this path is better than any previous path to neighbor
                    if neighbor_pos not in costs or new_cost < costs[neighbor_pos]:
                        costs[neighbor_pos] = new_cost
                        parents[neighbor_pos] = current_pos
                        heapq.heappush(pq, (new_cost, neighbor_pos[0], neighbor_pos[1]))

        # No path found
        return []

    def _reconstruct_path(self, parents: Dict, start: Tuple[int, int],
                         goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """Reconstruct path from parent dictionary"""
        path = []
        current = goal

        while current is not None:
            path.append(current)
            current = parents[current]

        return path[::-1]  # Reverse to get path from start to goal

# Example usage
if __name__ == "__main__":
    # Create a simple grid (0 = free space, 1 = obstacle)
    grid = np.array([
        [0, 0, 0, 0, 1],
        [0, 1, 1, 0, 0],
        [0, 0, 0, 0, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 0, 0]
    ])

    planner = DijkstraPathPlanner(grid)
    start = (0, 0)
    goal = (4, 4)

    path = planner.plan_path(start, goal)
    print(f"Path from {start} to {goal}: {path}")
```

### A* Algorithm

A* is an extension of Dijkstra's algorithm that uses a heuristic function to guide the search toward the goal, making it more efficient. The algorithm minimizes f(n) = g(n) + h(n), where g(n) is the actual cost from start to node n, and h(n) is the estimated cost from n to the goal.

```python
import heapq
from typing import List, Tuple, Dict, Optional
import numpy as np

class AStarPathPlanner:
    def __init__(self, grid: np.ndarray):
        """
        Initialize A* path planner with a grid representation
        Args:
            grid: 2D numpy array where 0 = free space, 1 = obstacle
        """
        self.grid = grid
        self.rows, self.cols = grid.shape
        self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1),  # 4-connectivity
                          (-1, -1), (-1, 1), (1, -1), (1, 1)]  # Diagonals

    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """Calculate heuristic (Manhattan distance with diagonal movement consideration)"""
        dx = abs(pos1[0] - pos2[0])
        dy = abs(pos1[1] - pos2[1])
        # Diagonal distance: min(dx, dy) * sqrt(2) + (max(dx, dy) - min(dx, dy)) * 1
        return min(dx, dy) * np.sqrt(2) + abs(dx - dy)

    def is_valid(self, row: int, col: int) -> bool:
        """Check if position is valid (within bounds and not an obstacle)"""
        return (0 <= row < self.rows and
                0 <= col < self.cols and
                self.grid[row][col] == 0)

    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Plan path using A* algorithm
        Args:
            start: Starting position (row, col)
            goal: Goal position (row, col)
        Returns:
            List of positions forming the path, or empty list if no path exists
        """
        # Priority queue: (f_score, g_score, row, col)
        pq = [(self.heuristic(start, goal), 0, start[0], start[1])]

        # g_score: actual cost from start to node
        g_scores = {start: 0}

        # f_score: estimated total cost (g + h) from start through node to goal
        f_scores = {start: self.heuristic(start, goal)}

        # Parent dictionary for path reconstruction
        parents = {start: None}

        while pq:
            current_f, current_g, row, col = heapq.heappop(pq)
            current_pos = (row, col)

            # If we reached the goal, reconstruct path
            if current_pos == goal:
                return self._reconstruct_path(parents, start, goal)

            # Explore neighbors
            for dr, dc in self.directions:
                neighbor_pos = (row + dr, col + dc)

                if self.is_valid(neighbor_pos[0], neighbor_pos[1]):
                    # Calculate movement cost (diagonal vs orthogonal)
                    move_cost = np.sqrt(2) if abs(dr) == 1 and abs(dc) == 1 else 1.0
                    tentative_g_score = current_g + move_cost

                    # If this path is better than any previous path to neighbor
                    if neighbor_pos not in g_scores or tentative_g_score < g_scores[neighbor_pos]:
                        parents[neighbor_pos] = current_pos
                        g_scores[neighbor_pos] = tentative_g_score
                        f_scores[neighbor_pos] = tentative_g_score + self.heuristic(neighbor_pos, goal)
                        heapq.heappush(pq, (f_scores[neighbor_pos], tentative_g_score,
                                          neighbor_pos[0], neighbor_pos[1]))

        # No path found
        return []

    def _reconstruct_path(self, parents: Dict, start: Tuple[int, int],
                         goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """Reconstruct path from parent dictionary"""
        path = []
        current = goal

        while current is not None:
            path.append(current)
            current = parents[current]

        return path[::-1]  # Reverse to get path from start to goal

# Example usage
if __name__ == "__main__":
    # Create a simple grid (0 = free space, 1 = obstacle)
    grid = np.array([
        [0, 0, 0, 0, 1],
        [0, 1, 1, 0, 0],
        [0, 0, 0, 0, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 0, 0]
    ])

    planner = AStarPathPlanner(grid)
    start = (0, 0)
    goal = (4, 4)

    path = planner.plan_path(start, goal)
    print(f"A* Path from {start} to {goal}: {path}")
```

### Jump Point Search (JPS)

Jump Point Search is an optimization of A* that exploits symmetries in uniform-cost grids to reduce search time. It works by "jumping" over large areas of the search space that would be explored by A*, significantly improving performance on uniform-cost grid maps.

```python
from typing import List, Tuple, Dict, Optional, Set
import heapq
import numpy as np

class JumpPointSearch:
    def __init__(self, grid: np.ndarray):
        """
        Initialize Jump Point Search path planner
        Args:
            grid: 2D numpy array where 0 = free space, 1 = obstacle
        """
        self.grid = grid
        self.rows, self.cols = grid.shape
        # 8 directions: horizontal, vertical, and diagonal
        self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1),
                          (-1, -1), (-1, 1), (1, -1), (1, 1)]

    def is_valid(self, row: int, col: int) -> bool:
        """Check if position is valid (within bounds and not an obstacle)"""
        return (0 <= row < self.rows and
                0 <= col < self.cols and
                self.grid[row][col] == 0)

    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """Calculate heuristic (Manhattan distance with diagonal consideration)"""
        dx = abs(pos1[0] - pos2[0])
        dy = abs(pos1[1] - pos2[1])
        return min(dx, dy) * np.sqrt(2) + abs(dx - dy)

    def has_forced_neighbors(self, pos: Tuple[int, int], direction: Tuple[int, int]) -> bool:
        """Check if a position has forced neighbors in a given direction"""
        px, py = pos
        dx, dy = direction

        if dx != 0 and dy != 0:  # Diagonal movement
            # Check if horizontal or vertical neighbors are blocked
            if not self.is_valid(px - dx, py) and self.is_valid(px, py + dy):
                return True
            if not self.is_valid(px, py - dy) and self.is_valid(px + dx, py):
                return True
        elif dx != 0:  # Horizontal movement
            # Check if diagonal neighbors are blocked
            if (not self.is_valid(px, py - 1) and self.is_valid(px + dx, py - 1)) or \
               (not self.is_valid(px, py + 1) and self.is_valid(px + dx, py + 1)):
                return True
        else:  # Vertical movement
            # Check if diagonal neighbors are blocked
            if (not self.is_valid(px - 1, py) and self.is_valid(px - 1, py + dy)) or \
               (not self.is_valid(px + 1, py) and self.is_valid(px + 1, py + dy)):
                return True

        return False

    def jump(self, pos: Tuple[int, int], direction: Tuple[int, int],
             goal: Tuple[int, int]) -> Optional[Tuple[int, int]]:
        """Jump in the given direction until a jump point is found"""
        px, py = pos
        dx, dy = direction

        # Check if current position is the goal
        if pos == goal:
            return pos

        # Check if current position is blocked
        if not self.is_valid(px, py):
            return None

        # Check for forced neighbors
        if self.has_forced_neighbors(pos, direction):
            return pos

        # Recursive jump
        next_pos = (px + dx, py + dy)
        jump_point = self.jump(next_pos, direction, goal)

        if jump_point is not None:
            return jump_point

        # Check intermediate directions for diagonal movement
        if dx != 0 and dy != 0:
            # Check horizontal and vertical jumps
            h_jump = self.jump((px + dx, py), (dx, 0), goal)
            v_jump = self.jump((px, py + dy), (0, dy), goal)

            if h_jump is not None or v_jump is not None:
                return pos

        return None

    def identify_successors(self, pos: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """Identify successors for a given position"""
        successors = []

        # For the start node, check all directions
        if not hasattr(self, '_start_node') or pos == self._start_node:
            for dx, dy in self.directions:
                jump_point = self.jump((pos[0] + dx, pos[1] + dy), (dx, dy), goal)
                if jump_point is not None:
                    successors.append(jump_point)
        else:
            # For other nodes, determine natural neighbors based on parent
            parent = getattr(self, '_parent', None)
            if parent is not None:
                dx = pos[0] - parent[0]
                dy = pos[1] - parent[1]

                # Pruning: only consider certain directions based on movement from parent
                directions_to_check = []

                # Straight moves
                directions_to_check.append((dx, dy))

                # Diagonal moves from straight moves
                if dx == 0:  # Vertical move from parent
                    directions_to_check.extend([(1, dy), (-1, dy)])
                elif dy == 0:  # Horizontal move from parent
                    directions_to_check.extend([(dx, 1), (dx, -1)])
                else:  # Diagonal move from parent
                    directions_to_check.extend([(dx, 0), (0, dy), (-dx, dy), (dx, -dy)])

                for ddx, ddy in directions_to_check:
                    jump_point = self.jump((pos[0] + ddx, pos[1] + ddy), (ddx, ddy), goal)
                    if jump_point is not None:
                        successors.append(jump_point)

        return successors

    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Plan path using Jump Point Search
        Args:
            start: Starting position (row, col)
            goal: Goal position (row, col)
        Returns:
            List of positions forming the path, or empty list if no path exists
        """
        self._start_node = start

        # Priority queue: (f_score, g_score, row, col)
        pq = [(self.heuristic(start, goal), 0, start[0], start[1])]

        # g_score: actual cost from start to node
        g_scores = {start: 0}

        # f_score: estimated total cost (g + h) from start through node to goal
        f_scores = {start: self.heuristic(start, goal)}

        # Parent dictionary for path reconstruction
        parents = {start: None}

        # Closed set to avoid reprocessing nodes
        closed_set = set()

        while pq:
            current_f, current_g, row, col = heapq.heappop(pq)
            current_pos = (row, col)

            # Skip if already processed
            if current_pos in closed_set:
                continue

            closed_set.add(current_pos)

            # If we reached the goal, reconstruct path
            if current_pos == goal:
                return self._reconstruct_path(parents, start, goal)

            # Identify successors using JPS
            self._parent = parents.get(current_pos)
            successors = self.identify_successors(current_pos, goal)

            for successor in successors:
                if successor in closed_set:
                    continue

                # Calculate tentative g score
                tentative_g = current_g + self.euclidean_distance(current_pos, successor)

                # If this path is better than any previous path to successor
                if successor not in g_scores or tentative_g < g_scores[successor]:
                    parents[successor] = current_pos
                    g_scores[successor] = tentative_g
                    f_scores[successor] = tentative_g + self.heuristic(successor, goal)
                    heapq.heappush(pq, (f_scores[successor], tentative_g,
                                      successor[0], successor[1]))

        # No path found
        return []

    def euclidean_distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """Calculate Euclidean distance between two positions"""
        return np.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

    def _reconstruct_path(self, parents: Dict, start: Tuple[int, int],
                         goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """Reconstruct path from parent dictionary"""
        path = []
        current = goal

        while current is not None:
            path.append(current)
            current = parents[current]

        return path[::-1]  # Reverse to get path from start to goal

# Example usage
if __name__ == "__main__":
    # Create a simple grid (0 = free space, 1 = obstacle)
    grid = np.array([
        [0, 0, 0, 0, 1],
        [0, 1, 1, 0, 0],
        [0, 0, 0, 0, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 0, 0, 0]
    ])

    planner = JumpPointSearch(grid)
    start = (0, 0)
    goal = (4, 4)

    path = planner.plan_path(start, goal)
    print(f"JPS Path from {start} to {goal}: {path}")
```

## Sampling-based Path Planning

### Probabilistic Roadmap (PRM)

The Probabilistic Roadmap (PRM) algorithm precomputes a roadmap of possible paths in the configuration space, then uses graph search to find paths between specific start and goal configurations. PRM is particularly effective for multi-query scenarios where multiple paths need to be planned in the same environment.

```python
import numpy as np
from scipy.spatial import KDTree
from typing import List, Tuple, Optional
import heapq

class PRMPlanner:
    def __init__(self, workspace_bounds: Tuple[Tuple[float, float], Tuple[float, float]],
                 obstacle_func=None, max_samples: int = 1000, k_neighbors: int = 10):
        """
        Initialize Probabilistic Roadmap planner
        Args:
            workspace_bounds: ((min_x, max_x), (min_y, max_y))
            obstacle_func: Function that takes (x, y) and returns True if obstacle
            max_samples: Maximum number of samples to generate
            k_neighbors: Number of nearest neighbors to connect
        """
        self.x_bounds = workspace_bounds[0]
        self.y_bounds = workspace_bounds[1]
        self.obstacle_func = obstacle_func or (lambda x, y: False)
        self.max_samples = max_samples
        self.k_neighbors = k_neighbors
        self.roadmap_vertices = []
        self.roadmap_edges = {}  # vertex -> list of (neighbor, distance)

    def is_collision_free(self, pos1: Tuple[float, float],
                         pos2: Tuple[float, float], num_samples: int = 10) -> bool:
        """Check if path between two points is collision-free"""
        # Sample points along the line segment
        for i in range(num_samples + 1):
            t = i / num_samples
            x = pos1[0] * (1 - t) + pos2[0] * t
            y = pos1[1] * (1 - t) + pos2[1] * t

            if self.obstacle_func(x, y):
                return False
        return True

    def sample_free_space(self) -> Optional[Tuple[float, float]]:
        """Sample a random point in free space"""
        for _ in range(100):  # Try up to 100 times
            x = np.random.uniform(self.x_bounds[0], self.x_bounds[1])
            y = np.random.uniform(self.y_bounds[0], self.y_bounds[1])

            if not self.obstacle_func(x, y):
                return (x, y)

        return None  # Failed to find free space

    def build_roadmap(self):
        """Build the probabilistic roadmap"""
        # Sample random configurations
        for _ in range(self.max_samples):
            config = self.sample_free_space()
            if config:
                self.roadmap_vertices.append(config)

        # Build KD tree for efficient nearest neighbor search
        if len(self.roadmap_vertices) == 0:
            return

        tree = KDTree(self.roadmap_vertices)

        # Connect each vertex to its k nearest neighbors
        for i, vertex in enumerate(self.roadmap_vertices):
            # Find k nearest neighbors
            distances, indices = tree.query(vertex, k=min(self.k_neighbors + 1, len(self.roadmap_vertices)))

            # Connect to neighbors that are collision-free
            self.roadmap_edges[i] = []
            for j, dist in zip(indices, distances):
                if i != j and dist > 0:  # Don't connect to itself
                    if self.is_collision_free(vertex, self.roadmap_vertices[j]):
                        self.roadmap_edges[i].append((j, dist))

    def find_nearest_vertex(self, pos: Tuple[float, float]) -> int:
        """Find the nearest vertex in the roadmap to a given position"""
        if len(self.roadmap_vertices) == 0:
            return -1

        tree = KDTree(self.roadmap_vertices)
        _, nearest_idx = tree.query(pos)
        return nearest_idx

    def connect_to_roadmap(self, pos: Tuple[float, float]) -> int:
        """Connect a new position to the roadmap and return its index"""
        vertex_idx = len(self.roadmap_vertices)
        self.roadmap_vertices.append(pos)
        self.roadmap_edges[vertex_idx] = []

        # Connect to k nearest neighbors in existing roadmap
        tree = KDTree(self.roadmap_vertices[:-1])  # Exclude the new vertex
        distances, indices = tree.query(pos, k=min(self.k_neighbors, len(self.roadmap_vertices) - 1))

        for neighbor_idx, dist in zip(indices, distances):
            if self.is_collision_free(pos, self.roadmap_vertices[neighbor_idx]):
                self.roadmap_edges[vertex_idx].append((neighbor_idx, dist))
                self.roadmap_edges[neighbor_idx].append((vertex_idx, dist))

        return vertex_idx

    def dijkstra_path(self, start_idx: int, goal_idx: int) -> List[int]:
        """Find shortest path using Dijkstra's algorithm on the roadmap"""
        if start_idx not in self.roadmap_edges or goal_idx not in self.roadmap_edges:
            return []

        # Priority queue: (cost, vertex_idx)
        pq = [(0, start_idx)]

        # Cost dictionary
        costs = {start_idx: 0}

        # Parent dictionary for path reconstruction
        parents = {start_idx: None}

        while pq:
            current_cost, current_idx = heapq.heappop(pq)

            if current_idx == goal_idx:
                # Reconstruct path
                path = []
                current = goal_idx
                while current is not None:
                    path.append(current)
                    current = parents[current]
                return path[::-1]

            if current_cost > costs.get(current_idx, float('inf')):
                continue

            # Explore neighbors
            for neighbor_idx, edge_cost in self.roadmap_edges.get(current_idx, []):
                new_cost = current_cost + edge_cost

                if neighbor_idx not in costs or new_cost < costs[neighbor_idx]:
                    costs[neighbor_idx] = new_cost
                    parents[neighbor_idx] = current_idx
                    heapq.heappush(pq, (new_cost, neighbor_idx))

        return []  # No path found

    def plan_path(self, start: Tuple[float, float],
                  goal: Tuple[float, float]) -> List[Tuple[float, float]]:
        """
        Plan path from start to goal using PRM
        Args:
            start: Starting position (x, y)
            goal: Goal position (x, y)
        Returns:
            List of positions forming the path, or empty list if no path exists
        """
        # Check if start and goal are in free space
        if self.obstacle_func(start[0], start[1]) or self.obstacle_func(goal[0], goal[1]):
            return []

        # Build roadmap if not already built
        if len(self.roadmap_vertices) == 0:
            self.build_roadmap()

        # Connect start and goal to roadmap
        start_idx = self.connect_to_roadmap(start)
        goal_idx = self.connect_to_roadmap(goal)

        # Find path using Dijkstra
        path_indices = self.dijkstra_path(start_idx, goal_idx)

        if len(path_indices) == 0:
            return []

        # Convert indices back to positions
        path = [self.roadmap_vertices[idx] for idx in path_indices]

        # Remove the connected start and goal from roadmap (optional cleanup)
        # In practice, you might want to keep them for multiple queries
        self.roadmap_vertices.pop()  # Remove goal
        self.roadmap_vertices.pop()  # Remove start
        del self.roadmap_edges[len(self.roadmap_vertices)]  # Remove goal connections
        del self.roadmap_edges[len(self.roadmap_vertices)]  # Remove start connections

        return path

# Example usage with a simple obstacle function
def simple_obstacle_func(x: float, y: float) -> bool:
    """Simple obstacle function - creates a rectangular obstacle"""
    return (2.0 <= x <= 3.0) and (2.0 <= y <= 4.0)

if __name__ == "__main__":
    # Define workspace bounds
    workspace = ((0, 5), (0, 5))

    # Create PRM planner
    prm = PRMPlanner(workspace, simple_obstacle_func, max_samples=500, k_neighbors=10)

    # Plan path
    start = (0.5, 0.5)
    goal = (4.5, 4.5)

    path = prm.plan_path(start, goal)
    print(f"PRM Path from {start} to {goal} has {len(path)} waypoints")
    if path:
        print(f"First few points: {path[:3]}")
        print(f"Last few points: {path[-3:]}")
```

### Rapidly-exploring Random Trees (RRT)

Rapidly-exploring Random Trees (RRT) is a sampling-based algorithm that incrementally builds a tree of possible paths by randomly sampling the configuration space and extending the tree toward those samples. RRT is particularly effective for high-dimensional configuration spaces and single-query scenarios.

```python
import numpy as np
from typing import List, Tuple, Optional
import math

class RRTNode:
    def __init__(self, position: Tuple[float, float], parent=None):
        self.position = position
        self.parent = parent

class RRTPlanner:
    def __init__(self, workspace_bounds: Tuple[Tuple[float, float], Tuple[float, float]],
                 obstacle_func=None, step_size: float = 0.1, max_iterations: int = 10000):
        """
        Initialize RRT planner
        Args:
            workspace_bounds: ((min_x, max_x), (min_y, max_y))
            obstacle_func: Function that takes (x, y) and returns True if obstacle
            step_size: Maximum distance to extend tree in each iteration
            max_iterations: Maximum number of iterations to run
        """
        self.x_bounds = workspace_bounds[0]
        self.y_bounds = workspace_bounds[1]
        self.obstacle_func = obstacle_func or (lambda x, y: False)
        self.step_size = step_size
        self.max_iterations = max_iterations

    def distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate Euclidean distance between two points"""
        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

    def is_collision_free(self, pos1: Tuple[float, float],
                         pos2: Tuple[float, float], num_samples: int = 10) -> bool:
        """Check if path between two points is collision-free"""
        # Sample points along the line segment
        for i in range(num_samples + 1):
            t = i / num_samples
            x = pos1[0] * (1 - t) + pos2[0] * t
            y = pos1[1] * (1 - t) + pos2[1] * t

            if self.obstacle_func(x, y):
                return False
        return True

    def nearest_node(self, tree: List[RRTNode], target: Tuple[float, float]) -> RRTNode:
        """Find the nearest node in the tree to the target"""
        nearest = tree[0]
        min_dist = self.distance(nearest.position, target)

        for node in tree[1:]:
            dist = self.distance(node.position, target)
            if dist < min_dist:
                min_dist = dist
                nearest = node

        return nearest

    def steer(self, from_pos: Tuple[float, float], to_pos: Tuple[float, float]) -> Tuple[float, float]:
        """Steer from from_pos toward to_pos by step_size"""
        dist = self.distance(from_pos, to_pos)

        if dist <= self.step_size:
            return to_pos

        # Calculate direction vector
        dx = to_pos[0] - from_pos[0]
        dy = to_pos[1] - from_pos[1]

        # Normalize and scale by step_size
        scale = self.step_size / dist
        new_x = from_pos[0] + dx * scale
        new_y = from_pos[1] + dy * scale

        return (new_x, new_y)

    def plan_path(self, start: Tuple[float, float],
                  goal: Tuple[float, float],
                  goal_radius: float = 0.1) -> List[Tuple[float, float]]:
        """
        Plan path from start to goal using RRT
        Args:
            start: Starting position (x, y)
            goal: Goal position (x, y)
            goal_radius: Distance threshold to consider goal reached
        Returns:
            List of positions forming the path, or empty list if no path exists
        """
        # Check if start and goal are in free space
        if self.obstacle_func(start[0], start[1]) or self.obstacle_func(goal[0], goal[1]):
            return []

        # Initialize tree with start node
        start_node = RRTNode(start)
        tree = [start_node]

        for iteration in range(self.max_iterations):
            # Sample random point (bias toward goal occasionally)
            if iteration % 10 == 0:  # Bias toward goal every 10th iteration
                rand_pos = goal
            else:
                rand_pos = (
                    np.random.uniform(self.x_bounds[0], self.x_bounds[1]),
                    np.random.uniform(self.y_bounds[0], self.y_bounds[1])
                )

            # Find nearest node in tree
            nearest = self.nearest_node(tree, rand_pos)

            # Steer toward random point
            new_pos = self.steer(nearest.position, rand_pos)

            # Check if path from nearest to new_pos is collision-free
            if self.is_collision_free(nearest.position, new_pos):
                # Add new node to tree
                new_node = RRTNode(new_pos, nearest)
                tree.append(new_node)

                # Check if we're close enough to goal
                if self.distance(new_pos, goal) <= goal_radius:
                    # Reconstruct path
                    path = []
                    current = new_node
                    while current is not None:
                        path.append(current.position)
                        current = current.parent

                    return path[::-1]  # Reverse to get path from start to goal

        # Failed to find path
        return []

# Example usage
def simple_obstacle_func(x: float, y: float) -> bool:
    """Simple obstacle function - creates a rectangular obstacle"""
    return (2.0 <= x <= 3.0) and (2.0 <= y <= 4.0)

if __name__ == "__main__":
    # Define workspace bounds
    workspace = ((0, 5), (0, 5))

    # Create RRT planner
    rrt = RRTPlanner(workspace, simple_obstacle_func, step_size=0.2, max_iterations=5000)

    # Plan path
    start = (0.5, 0.5)
    goal = (4.5, 4.5)

    path = rrt.plan_path(start, goal, goal_radius=0.2)
    print(f"RRT Path from {start} to {goal} has {len(path)} waypoints")
    if path:
        print(f"First few points: {path[:3]}")
        print(f"Last few points: {path[-3:]}")
```

### RRT*

RRT* is an extension of RRT that provides asymptotic optimality by rewiring the tree to find lower-cost paths. It maintains the exploration properties of RRT while converging to the optimal solution over time.

```python
import numpy as np
from typing import List, Tuple, Optional, Dict
import math
from scipy.spatial import KDTree

class RRTStarNode:
    def __init__(self, position: Tuple[float, float], parent=None, cost: float = 0.0):
        self.position = position
        self.parent = parent
        self.cost = cost  # Cost from start to this node

class RRTStarPlanner:
    def __init__(self, workspace_bounds: Tuple[Tuple[float, float], Tuple[float, float]],
                 obstacle_func=None, step_size: float = 0.1, max_iterations: int = 10000,
                 gamma: float = 1.0):
        """
        Initialize RRT* planner
        Args:
            workspace_bounds: ((min_x, max_x), (min_y, max_y))
            obstacle_func: Function that takes (x, y) and returns True if obstacle
            step_size: Maximum distance to extend tree in each iteration
            max_iterations: Maximum number of iterations to run
            gamma: Parameter for rewiring radius calculation (default 1.0)
        """
        self.x_bounds = workspace_bounds[0]
        self.y_bounds = workspace_bounds[1]
        self.obstacle_func = obstacle_func or (lambda x, y: False)
        self.step_size = step_size
        self.max_iterations = max_iterations
        self.gamma = gamma  # Rewiring parameter

    def distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
        """Calculate Euclidean distance between two points"""
        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

    def is_collision_free(self, pos1: Tuple[float, float],
                         pos2: Tuple[float, float], num_samples: int = 10) -> bool:
        """Check if path between two points is collision-free"""
        # Sample points along the line segment
        for i in range(num_samples + 1):
            t = i / num_samples
            x = pos1[0] * (1 - t) + pos2[0] * t
            y = pos1[1] * (1 - t) + pos2[1] * t

            if self.obstacle_func(x, y):
                return False
        return True

    def nearest_node(self, tree: List[RRTStarNode], target: Tuple[float, float]) -> RRTStarNode:
        """Find the nearest node in the tree to the target"""
        nearest = tree[0]
        min_dist = self.distance(nearest.position, target)

        for node in tree[1:]:
            dist = self.distance(node.position, target)
            if dist < min_dist:
                min_dist = dist
                nearest = node

        return nearest

    def steer(self, from_pos: Tuple[float, float], to_pos: Tuple[float, float]) -> Tuple[float, float]:
        """Steer from from_pos toward to_pos by step_size"""
        dist = self.distance(from_pos, to_pos)

        if dist <= self.step_size:
            return to_pos

        # Calculate direction vector
        dx = to_pos[0] - from_pos[0]
        dy = to_pos[1] - from_pos[1]

        # Normalize and scale by step_size
        scale = self.step_size / dist
        new_x = from_pos[0] + dx * scale
        new_y = from_pos[1] + dy * scale

        return (new_x, new_y)

    def find_near_nodes(self, tree: List[RRTStarNode], new_pos: Tuple[float, float],
                       num_nodes: int) -> List[RRTStarNode]:
        """Find near nodes within a certain radius of new_pos"""
        # Create KDTree for efficient neighbor search
        positions = np.array([node.position for node in tree])
        tree_kdtree = KDTree(positions)

        # Calculate radius based on RRT* theory
        n = len(tree)
        unit_ball_volume = math.pi  # Volume of unit ball in 2D
        dim = 2  # 2D space
        radius = self.gamma * (math.log(n) / n) ** (1.0 / dim)

        # Find all nodes within radius
        indices = tree_kdtree.query_ball_point(new_pos, radius)
        return [tree[i] for i in indices]

    def plan_path(self, start: Tuple[float, float],
                  goal: Tuple[float, float],
                  goal_radius: float = 0.1) -> List[Tuple[float, float]]:
        """
        Plan path from start to goal using RRT*
        Args:
            start: Starting position (x, y)
            goal: Goal position (x, y)
            goal_radius: Distance threshold to consider goal reached
        Returns:
            List of positions forming the path, or empty list if no path exists
        """
        # Check if start and goal are in free space
        if self.obstacle_func(start[0], start[1]) or self.obstacle_func(goal[0], goal[1]):
            return []

        # Initialize tree with start node
        start_node = RRTStarNode(start, None, 0.0)
        tree = [start_node]

        best_goal_node = None
        best_cost = float('inf')

        for iteration in range(self.max_iterations):
            # Sample random point (bias toward goal occasionally)
            if iteration % 10 == 0:  # Bias toward goal every 10th iteration
                rand_pos = goal
            else:
                rand_pos = (
                    np.random.uniform(self.x_bounds[0], self.x_bounds[1]),
                    np.random.uniform(self.y_bounds[0], self.y_bounds[1])
                )

            # Find nearest node in tree
            nearest = self.nearest_node(tree, rand_pos)

            # Steer toward random point
            new_pos = self.steer(nearest.position, rand_pos)

            # Check if path from nearest to new_pos is collision-free
            if self.is_collision_free(nearest.position, new_pos):
                # Find near nodes to potentially connect to
                near_nodes = self.find_near_nodes(tree, new_pos, len(tree))

                # Find best parent among near nodes
                best_parent = nearest
                min_cost = nearest.cost + self.distance(nearest.position, new_pos)

                for near_node in near_nodes:
                    cost_to_new = near_node.cost + self.distance(near_node.position, new_pos)
                    if (cost_to_new < min_cost and
                        self.is_collision_free(near_node.position, new_pos)):
                        min_cost = cost_to_new
                        best_parent = near_node

                # Add new node to tree
                new_node = RRTStarNode(new_pos, best_parent, min_cost)
                tree.append(new_node)

                # Rewire: check if new node provides better path to near nodes
                for near_node in near_nodes:
                    if near_node == best_parent:
                        continue  # Skip the parent

                    cost_via_new = new_node.cost + self.distance(new_node.position, near_node.position)
                    if (cost_via_new < near_node.cost and
                        self.is_collision_free(new_node.position, near_node.position)):
                        # Update parent and cost
                        near_node.parent = new_node
                        near_node.cost = cost_via_new

                # Check if we're close enough to goal and if it's the best path so far
                if self.distance(new_pos, goal) <= goal_radius:
                    if min_cost < best_cost:
                        best_cost = min_cost
                        best_goal_node = new_node

        # If we found a path to goal, reconstruct it
        if best_goal_node is not None:
            path = []
            current = best_goal_node
            while current is not None:
                path.append(current.position)
                current = current.parent

            return path[::-1]  # Reverse to get path from start to goal

        # Failed to find path
        return []

# Example usage
def simple_obstacle_func(x: float, y: float) -> bool:
    """Simple obstacle function - creates a rectangular obstacle"""
    return (2.0 <= x <= 3.0) and (2.0 <= y <= 4.0)

if __name__ == "__main__":
    # Define workspace bounds
    workspace = ((0, 5), (0, 5))

    # Create RRT* planner
    rrt_star = RRTStarPlanner(workspace, simple_obstacle_func, step_size=0.2, max_iterations=5000)

    # Plan path
    start = (0.5, 0.5)
    goal = (4.5, 4.5)

    path = rrt_star.plan_path(start, goal, goal_radius=0.2)
    print(f"RRT* Path from {start} to {goal} has {len(path)} waypoints")
    if path:
        print(f"First few points: {path[:3]}")
        print(f"Last few points: {path[-3:]}")
        print(f"Total path cost: {sum([math.sqrt((path[i][0]-path[i+1][0])**2 + (path[i][1]-path[i+1][1])**2) for i in range(len(path)-1)])}")
```

## Comparison of Path Planning Algorithms

| Algorithm | Completeness | Optimality | Time Complexity | Space Complexity | Best Use Case |
|-----------|--------------|------------|-----------------|------------------|---------------|
| Dijkstra | Complete | Optimal | O(E + V log V) | O(V) | Known graph, single-query |
| A* | Complete* | Optimal* | O(b^d) | O(b^d) | Known graph with good heuristic |
| JPS | Complete* | Optimal* | O(n) best case | O(n) | Uniform-cost grid maps |
| PRM | Probabilistically complete | No | O(knÂ²) | O(kn) | Multi-query, high-dimensional |
| RRT | Probabilistically complete | No | O(n) | O(n) | Single-query, high-dimensional |
| RRT* | Probabilistically complete | Asymptotically optimal | O(n log n) | O(n) | Optimal path in high-dimensional |

*Completeness and optimality depend on heuristic admissibility for A*, and map properties for JPS.

## Implementation Considerations

### Performance Optimization

Path planning algorithms can be computationally expensive, especially in high-dimensional spaces. Several optimization strategies can be employed:

1. **Hierarchical Planning**: Use multiple resolution levels to quickly find coarse paths, then refine them
2. **Anytime Algorithms**: Algorithms that can return valid paths at any time and improve them over time
3. **Parallelization**: Many algorithms can be parallelized, especially sampling-based methods
4. **Caching**: Store and reuse computed paths or roadmap structures

### Real-world Challenges

Real-world path planning faces several challenges not addressed in idealized algorithms:

1. **Dynamic Environments**: Obstacles that move or appear during execution
2. **Uncertainty**: Sensor noise and model inaccuracies
3. **Kinodynamic Constraints**: Robot dynamics that limit feasible motions
4. **Multi-objective Optimization**: Balancing path length, safety, energy, etc.

## Conclusion

Path planning is a fundamental problem in robotics with a rich set of algorithmic solutions. The choice of algorithm depends on the specific requirements of the application, including the dimensionality of the configuration space, the need for optimality, real-time constraints, and environmental characteristics. Classical algorithms like Dijkstra and A* work well for discrete problems, while sampling-based methods like PRM, RRT, and RRT* excel in high-dimensional continuous spaces. Modern robotics applications often combine multiple approaches, using hierarchical planning or hybrid methods to balance efficiency and optimality.
