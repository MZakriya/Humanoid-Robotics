---
id: module6-motion-planning-6.6-multi-robot
title: "Multi-Robot Planning"
slug: /module6-motion-planning-6.6-multi-robot
---

# Multi-Robot Motion Planning

Multi-robot motion planning addresses the challenge of coordinating the motion of multiple robots to achieve common or individual goals while avoiding collisions with each other and obstacles in the environment. This field combines elements of single-robot motion planning with multi-agent coordination and distributed systems.

## Overview and Challenges

Multi-robot motion planning involves coordinating the trajectories of multiple robots in shared environments. Key challenges include:

1. **Scalability**: Solution complexity grows exponentially with the number of robots
2. **Communication**: Coordination protocols and information sharing
3. **Decentralization**: Distributed decision-making vs centralized planning
4. **Collision avoidance**: Preventing robot-robot and robot-obstacle collisions
5. **Optimization**: Optimizing global objectives while respecting individual constraints
6. **Uncertainty**: Handling sensing and actuation uncertainties across all robots

The configuration space for N robots is the Cartesian product of individual configuration spaces: C_total = C₁ × C₂ × ... × C_N. This results in an exponentially growing search space.

## Centralized Approaches

### Joint Configuration Space (JCS) Planning

In JCS planning, all robots' configurations are considered simultaneously in a high-dimensional joint configuration space.

```python
import numpy as np
from typing import List, Tuple, Optional
import heapq
from scipy.spatial import cKDTree

class MultiRobotState:
    def __init__(self, robot_configs: List[np.ndarray], cost: float = 0.0):
        """
        Represents a multi-robot state in joint configuration space
        Args:
            robot_configs: List of individual robot configurations
            cost: Cost from start state
        """
        self.robot_configs = robot_configs
        self.cost = cost
        self.parent: Optional['MultiRobotState'] = None

class JointConfigurationSpacePlanner:
    def __init__(self, num_robots: int, robot_limits: List[Tuple[float, float]],
                 robot_radii: List[float], workspace_obstacles: List[np.ndarray] = None):
        """
        Plan in joint configuration space for multiple robots
        Args:
            num_robots: Number of robots to plan for
            robot_limits: List of (min, max) limits for each robot's configuration space
            robot_radii: Radius of each robot for collision checking
            workspace_obstacles: List of static obstacles in the workspace
        """
        self.num_robots = num_robots
        self.robot_limits = robot_limits
        self.robot_radii = robot_radii
        self.workspace_obstacles = workspace_obstacles or []

        # Planning parameters
        self.step_size = 0.2
        self.collision_resolution = 5

    def is_collision_free(self, multi_state: MultiRobotState) -> bool:
        """
        Check if multi-robot state is collision-free
        """
        configs = multi_state.robot_configs

        # Check each robot against workspace obstacles
        for i, config in enumerate(configs):
            for obs in self.workspace_obstacles:
                # Assuming circular obstacles for simplicity
                if len(obs) == 3:  # [x, y, radius]
                    obs_x, obs_y, obs_radius = obs
                    robot_x, robot_y = config[0], config[1]
                    dist = np.sqrt((robot_x - obs_x)**2 + (robot_y - obs_y)**2)
                    if dist < (self.robot_radii[i] + obs_radius):
                        return False

        # Check robot-robot collisions
        for i in range(self.num_robots):
            for j in range(i + 1, self.num_robots):
                dist = np.linalg.norm(configs[i] - configs[j])
                min_dist = self.robot_radii[i] + self.robot_radii[j]
                if dist < min_dist:
                    return False

        return True

    def get_neighbors(self, state: MultiRobotState) -> List[MultiRobotState]:
        """
        Get neighboring states by perturbing each robot's configuration
        """
        neighbors = []

        for robot_idx in range(self.num_robots):
            # Generate perturbations for the selected robot
            for dx in [-self.step_size, 0, self.step_size]:
                for dy in [-self.step_size, 0, self.step_size]:
                    if dx == 0 and dy == 0:
                        continue  # Skip no movement

                    # Create new configuration for the robot
                    new_config = state.robot_configs[robot_idx].copy()
                    new_config[0] += dx
                    new_config[1] += dy

                    # Check bounds
                    min_x, max_x = self.robot_limits[robot_idx][0], self.robot_limits[robot_idx][1]
                    min_y, max_y = self.robot_limits[robot_idx][2], self.robot_limits[robot_idx][3]

                    if not (min_x <= new_config[0] <= max_x and min_y <= new_config[1] <= max_y):
                        continue

                    # Create new multi-robot state
                    new_configs = state.robot_configs.copy()
                    new_configs[robot_idx] = new_config

                    neighbor_state = MultiRobotState(new_configs)
                    neighbor_state.cost = state.cost + np.sqrt(dx**2 + dy**2)
                    neighbor_state.parent = state

                    if self.is_collision_free(neighbor_state):
                        neighbors.append(neighbor_state)

        return neighbors

    def plan(self, start_configs: List[np.ndarray],
             goal_configs: List[np.ndarray],
             max_iterations: int = 10000) -> Optional[List[MultiRobotState]]:
        """
        Plan coordinated motion for multiple robots using A* in joint configuration space
        """
        start_state = MultiRobotState(start_configs, 0.0)
        goal_state = MultiRobotState(goal_configs)

        if not self.is_collision_free(start_state) or not self.is_collision_free(goal_state):
            return None  # Invalid start or goal

        # Heuristic function: sum of distances to goals
        def heuristic(state: MultiRobotState) -> float:
            total_dist = 0.0
            for i in range(self.num_robots):
                dist = np.linalg.norm(state.robot_configs[i] - goal_configs[i])
                total_dist += dist
            return total_dist

        # Priority queue: (f_score, g_score, state_id, state)
        open_set = [(heuristic(start_state), 0.0, 0, start_state)]
        closed_set = set()
        state_id_counter = 1

        while open_set and len(closed_set) < max_iterations:
            _, g_score, _, current = heapq.heappop(open_set)

            # Create a hashable representation of the state for the closed set
            state_hash = tuple(tuple(config.round(3)) for config in current.robot_configs)

            if state_hash in closed_set:
                continue

            closed_set.add(state_hash)

            # Check if we're close enough to the goal
            goal_reached = True
            for i in range(self.num_robots):
                dist = np.linalg.norm(current.robot_configs[i] - goal_configs[i])
                if dist > 0.2:  # Goal region radius
                    goal_reached = False
                    break

            if goal_reached:
                # Reconstruct path
                path = []
                curr = current
                while curr is not None:
                    path.append(curr)
                    curr = curr.parent
                return path[::-1]

            # Explore neighbors
            neighbors = self.get_neighbors(current)
            for neighbor in neighbors:
                neighbor_hash = tuple(tuple(config.round(3)) for config in neighbor.robot_configs)
                if neighbor_hash not in closed_set:
                    f_score = g_score + 1 + heuristic(neighbor)  # Simplified heuristic
                    heapq.heappush(open_set, (f_score, g_score + 1, state_id_counter, neighbor))
                    state_id_counter += 1

        return None  # No path found

# Example usage
def example_jcs_planning():
    # Define robot parameters
    num_robots = 2
    robot_limits = [(-5, 5, -5, 5), (-5, 5, -5, 5)]  # (min_x, max_x, min_y, max_y) for each robot
    robot_radii = [0.3, 0.3]

    # Define workspace obstacles
    workspace_obstacles = [
        [0, 0, 0.5],  # Circular obstacle at (0,0) with radius 0.5
        [2, 2, 0.3],  # Circular obstacle at (2,2) with radius 0.3
    ]

    # Create planner
    planner = JointConfigurationSpacePlanner(
        num_robots, robot_limits, robot_radii, workspace_obstacles
    )

    # Define start and goal configurations for each robot
    start_configs = [
        np.array([-4.0, -4.0]),  # Robot 1 start
        np.array([4.0, 4.0])     # Robot 2 start
    ]

    goal_configs = [
        np.array([4.0, 4.0]),   # Robot 1 goal
        np.array([-4.0, -4.0])  # Robot 2 goal
    ]

    # Plan coordinated motion
    path = planner.plan(start_configs, goal_configs)

    if path:
        print(f"Found coordinated path with {len(path)} steps")

        # Print final configurations
        final_state = path[-1]
        for i, config in enumerate(final_state.robot_configs):
            goal_dist = np.linalg.norm(config - goal_configs[i])
            print(f"Robot {i+1} final position: ({config[0]:.2f}, {config[1]:.2f}), "
                  f"distance to goal: {goal_dist:.2f}")
    else:
        print("No coordinated path found")

if __name__ == "__main__":
    example_jcs_planning()
```

### Decoupled Planning

Decoupled planning methods plan for each robot separately and resolve conflicts when they arise.

```python
import numpy as np
from typing import List, Tuple, Optional
import matplotlib.pyplot as plt

class SingleRobotPlanner:
    """Simple single robot planner for use in decoupled planning"""
    def __init__(self, workspace_bounds: Tuple[float, float, float, float],
                 robot_radius: float, obstacles: List[np.ndarray] = None):
        self.bounds = workspace_bounds  # (min_x, max_x, min_y, max_y)
        self.robot_radius = robot_radius
        self.obstacles = obstacles or []
        self.grid_resolution = 0.2

    def plan_path(self, start: np.ndarray, goal: np.ndarray) -> Optional[List[np.ndarray]]:
        """Plan a path for a single robot using a simple grid-based approach"""
        # This is a simplified implementation
        # In practice, you would use A*, RRT, or another path planning algorithm

        # For demonstration, return a straight line path with intermediate points
        steps = 20
        path = []
        for i in range(steps + 1):
            t = i / steps
            pos = (1 - t) * start + t * goal
            path.append(pos)

        # Verify path is collision-free
        for pos in path:
            if not self._is_collision_free(pos):
                return None  # Path is in collision

        return path

    def _is_collision_free(self, pos: np.ndarray) -> bool:
        """Check if position is collision-free"""
        x, y = pos[0], pos[1]
        min_x, max_x, min_y, max_y = self.bounds

        # Check workspace bounds
        if not (min_x <= x <= max_x and min_y <= y <= max_y):
            return False

        # Check obstacles
        for obs in self.obstacles:
            if len(obs) == 3:  # Circular obstacle [x, y, radius]
                obs_x, obs_y, obs_radius = obs
                dist = np.sqrt((x - obs_x)**2 + (y - obs_y)**2)
                if dist < (self.robot_radius + obs_radius):
                    return False

        return True

class DecoupledPlanner:
    def __init__(self, workspace_bounds: Tuple[float, float, float, float],
                 robot_radii: List[float], obstacles: List[np.ndarray] = None):
        """
        Decoupled multi-robot planner that plans for each robot separately
        and resolves conflicts using prioritization
        """
        self.workspace_bounds = workspace_bounds
        self.robot_radii = robot_radii
        self.obstacles = obstacles or []
        self.num_robots = len(robot_radii)

    def plan(self, starts: List[np.ndarray], goals: List[np.ndarray],
             max_retries: int = 5) -> Optional[List[List[np.ndarray]]]:
        """
        Plan paths for multiple robots using decoupled approach with prioritization
        """
        # Plan for each robot separately
        paths = [None] * self.num_robots
        robot_planners = []

        for i in range(self.num_robots):
            planner = SingleRobotPlanner(self.workspace_bounds,
                                       self.robot_radii[i],
                                       self.obstacles)
            robot_planners.append(planner)

        # Plan with prioritization (try different priority orders)
        for priority_order in self._get_priority_orders():
            paths = [None] * self.num_robots
            success = True

            for robot_idx in priority_order:
                # Plan for current robot considering positions of higher-priority robots
                temp_obstacles = self.obstacles.copy()

                # Add other robots as temporary obstacles
                for other_idx in range(self.num_robots):
                    if other_idx != robot_idx and paths[other_idx] is not None:
                        # Use the path of higher-priority robots as obstacles
                        for config in paths[other_idx]:
                            temp_obstacles.append([config[0], config[1], self.robot_radii[other_idx]])

                # Create temporary planner with additional obstacles
                temp_planner = SingleRobotPlanner(self.workspace_bounds,
                                                self.robot_radii[robot_idx],
                                                temp_obstacles)

                path = temp_planner.plan_path(starts[robot_idx], goals[robot_idx])

                if path is None:
                    success = False
                    break  # Could not plan for this robot

                paths[robot_idx] = path

            if success:
                return paths

        return None  # Could not find valid paths

    def _get_priority_orders(self):
        """Generate different priority orders for robots"""
        # For simplicity, return a few different priority orders
        # In practice, you might use more sophisticated methods
        import itertools
        return [list(range(self.num_robots)),
                list(range(self.num_robots-1, -1, -1))]

class ConflictBasedSearchNode:
    def __init__(self, paths: List[Optional[List[np.ndarray]]],
                 constraints: List[dict], cost: float = 0.0):
        """
        Node in the CBS (Conflict-Based Search) tree
        """
        self.paths = paths
        self.constraints = constraints  # List of constraints for each robot
        self.cost = cost
        self.parent = None

class ConflictBasedSearchPlanner:
    def __init__(self, workspace_bounds: Tuple[float, float, float, float],
                 robot_radii: List[float], obstacles: List[np.ndarray] = None):
        """
        Conflict-Based Search planner for multi-robot path planning
        """
        self.workspace_bounds = workspace_bounds
        self.robot_radii = robot_radii
        self.obstacles = obstacles or []
        self.num_robots = len(robot_radii)

    def find_first_conflict(self, paths: List[List[np.ndarray]]) -> Optional[Tuple[int, int, int, np.ndarray]]:
        """
        Find the first space-time conflict between robot paths
        Returns: (robot1_idx, robot2_idx, timestep, position) or None
        """
        if not paths or any(path is None for path in paths):
            return None

        max_time = max(len(path) for path in paths if path is not None)

        for t in range(max_time):
            robot_positions = {}
            for robot_idx, path in enumerate(paths):
                if path is not None and t < len(path):
                    pos = tuple(path[t].round(3))  # Round for comparison
                    if pos in robot_positions:
                        # Found a conflict
                        other_robot_idx = robot_positions[pos]
                        return (robot_idx, other_robot_idx, t, path[t])
                    robot_positions[pos] = robot_idx

        return None

    def add_constraint(self, robot_idx: int, constraint: dict) -> List[dict]:
        """
        Add a constraint to a robot's constraint list
        """
        # This is a simplified constraint handling
        # In practice, you would have more sophisticated constraint management
        return [constraint]

    def plan(self, starts: List[np.ndarray], goals: List[np.ndarray],
             max_iterations: int = 1000) -> Optional[List[List[np.ndarray]]]:
        """
        Plan using Conflict-Based Search
        """
        # Initialize with individual paths (ignoring other robots)
        initial_paths = []
        for i in range(self.num_robots):
            planner = SingleRobotPlanner(self.workspace_bounds,
                                       self.robot_radii[i],
                                       self.obstacles)
            path = planner.plan_path(starts[i], goals[i])
            initial_paths.append(path)

        # Check for conflicts
        conflict = self.find_first_conflict(initial_paths)
        if conflict is None:
            return initial_paths  # No conflicts found

        # For this simplified implementation, we'll return the initial paths
        # A full CBS implementation would involve building a CBS tree
        # and resolving conflicts systematically
        return initial_paths

# Example usage
def example_decoupled_planning():
    # Define workspace and robot parameters
    workspace_bounds = (-5, 5, -5, 5)
    robot_radii = [0.3, 0.3, 0.3]

    # Define obstacles
    obstacles = [
        [0, 0, 0.5],   # Circular obstacle at origin
        [2, 2, 0.3],   # Circular obstacle at (2,2)
    ]

    # Define start and goal positions for 3 robots
    starts = [
        np.array([-4.0, -4.0]),  # Robot 1
        np.array([4.0, 4.0]),    # Robot 2
        np.array([-4.0, 4.0])    # Robot 3
    ]

    goals = [
        np.array([4.0, 4.0]),    # Robot 1
        np.array([-4.0, -4.0]), # Robot 2
        np.array([4.0, -4.0])    # Robot 3
    ]

    # Create and run decoupled planner
    decoupled_planner = DecoupledPlanner(workspace_bounds, robot_radii, obstacles)
    paths = decoupled_planner.plan(starts, goals)

    if paths:
        print(f"Found paths for {len([p for p in paths if p is not None])} robots")

        # Visualize the results
        visualize_multi_robot_paths(paths, starts, goals)
    else:
        print("No valid paths found")

def visualize_multi_robot_paths(paths, starts, goals):
    """Visualize multi-robot paths"""
    fig, ax = plt.subplots(figsize=(10, 10))

    # Plot paths
    colors = ['blue', 'red', 'green', 'orange', 'purple']
    for i, path in enumerate(paths):
        if path is not None:
            path_array = np.array(path)
            ax.plot(path_array[:, 0], path_array[:, 1],
                   color=colors[i % len(colors)], linewidth=2,
                   label=f'Robot {i+1}', alpha=0.7)

            # Plot start and goal
            ax.plot(starts[i][0], starts[i][1],
                   'o', color=colors[i % len(colors)], markersize=10,
                   markeredgecolor='black')
            ax.plot(goals[i][0], goals[i][1],
                   's', color=colors[i % len(colors)], markersize=10,
                   markeredgecolor='black')

    # Add labels for start and goal
    for i, (start, goal) in enumerate(zip(starts, goals)):
        ax.text(start[0], start[1], f'S{i+1}', fontsize=10,
                ha='right', va='bottom')
        ax.text(goal[0], goal[1], f'G{i+1}', fontsize=10,
                ha='left', va='top')

    ax.set_xlim(-6, 6)
    ax.set_ylim(-6, 6)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_title('Multi-Robot Path Planning')
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_aspect('equal')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    example_decoupled_planning()
```

## Decentralized Approaches

### Priority-Based Planning

In priority-based planning, robots are assigned priorities and higher-priority robots plan first while lower-priority robots plan around them.

```python
import numpy as np
from typing import List, Tuple, Optional
import heapq

class PriorityBasedPlanner:
    def __init__(self, workspace_bounds: Tuple[float, float, float, float],
                 robot_radius: float, obstacles: List[np.ndarray] = None):
        """
        Single robot planner that can incorporate other robots as temporary obstacles
        """
        self.workspace_bounds = workspace_bounds
        self.robot_radius = robot_radius
        self.obstacles = obstacles or []

    def plan_with_constraints(self, start: np.ndarray, goal: np.ndarray,
                            other_robot_positions: List[np.ndarray],
                            time_horizon: int = 20) -> Optional[List[np.ndarray]]:
        """
        Plan path considering positions of other robots at different time steps
        """
        # For simplicity, we'll use a grid-based approach with dynamic obstacles
        # that represent other robots at different time steps

        # Create temporary obstacles based on other robots' positions
        temp_obstacles = self.obstacles.copy()
        for pos in other_robot_positions:
            temp_obstacles.append([pos[0], pos[1], self.robot_radius])

        # Plan path using a simple grid-based approach
        # In practice, you would use a more sophisticated path planning algorithm
        # that can handle dynamic constraints

        # For this example, we'll return a straight line path
        # (in a real implementation, this would be the result of a path planning algorithm)
        steps = 10
        path = []
        for i in range(steps + 1):
            t = i / steps
            pos = (1 - t) * start + t * goal
            path.append(pos)

        # Verify path is collision-free with respect to current constraints
        for pos in path:
            if not self._is_collision_free(pos, temp_obstacles):
                return None

        return path

    def _is_collision_free(self, pos: np.ndarray, obstacles: List[np.ndarray]) -> bool:
        """Check if position is collision-free with respect to given obstacles"""
        x, y = pos[0], pos[1]
        min_x, max_x, min_y, max_y = self.workspace_bounds

        # Check workspace bounds
        if not (min_x <= x <= max_x and min_y <= y <= max_y):
            return False

        # Check obstacles
        for obs in obstacles:
            if len(obs) == 3:  # Circular obstacle [x, y, radius]
                obs_x, obs_y, obs_radius = obs
                dist = np.sqrt((x - obs_x)**2 + (y - obs_y)**2)
                if dist < (self.robot_radius + obs_radius):
                    return False

        return True

class DistributedPriorityPlanner:
    def __init__(self, workspace_bounds: Tuple[float, float, float, float],
                 robot_radii: List[float], obstacles: List[np.ndarray] = None):
        """
        Distributed multi-robot planner using priority-based approach
        """
        self.workspace_bounds = workspace_bounds
        self.robot_radii = robot_radii
        self.obstacles = obstacles or []
        self.num_robots = len(robot_radii)

    def plan(self, starts: List[np.ndarray], goals: List[np.ndarray],
             priorities: List[int] = None) -> Optional[List[List[np.ndarray]]]:
        """
        Plan paths using priority-based approach
        """
        if priorities is None:
            # Default priority: index order
            priorities = list(range(self.num_robots))

        # Sort robots by priority (lower number = higher priority)
        priority_order = sorted(range(self.num_robots), key=lambda x: priorities[x])

        paths = [None] * self.num_robots
        robot_planners = []

        # Create planners for each robot
        for i in range(self.num_robots):
            planner = PriorityBasedPlanner(self.workspace_bounds,
                                        self.robot_radii[i],
                                        self.obstacles)
            robot_planners.append(planner)

        # Plan for each robot in priority order
        for robot_idx in priority_order:
            # Get positions of higher-priority robots (those already planned)
            other_robot_positions = []
            for other_idx in range(self.num_robots):
                if other_idx in priority_order[:priority_order.index(robot_idx)]:
                    if paths[other_idx] is not None and len(paths[other_idx]) > 0:
                        # Use the first position of other robots as temporary obstacles
                        other_robot_positions.append(paths[other_idx][0])

            # Plan for current robot considering higher-priority robots
            path = robot_planners[robot_idx].plan_with_constraints(
                starts[robot_idx], goals[robot_idx], other_robot_positions
            )

            if path is None:
                # Could not find path for this robot, try to replan others
                return self._resolve_conflict(robot_idx, starts, goals, paths, robot_planners)

            paths[robot_idx] = path

        return paths

    def _resolve_conflict(self, failed_robot: int, starts: List[np.ndarray],
                         goals: List[np.ndarray], existing_paths: List[List[np.ndarray]],
                         planners: List[PriorityBasedPlanner]) -> Optional[List[List[np.ndarray]]]:
        """
        Attempt to resolve conflicts by replanning
        """
        # For simplicity, return None indicating failure
        # In a more sophisticated implementation, this would involve
        # various conflict resolution strategies
        return None

# Example usage
def example_priority_based_planning():
    # Define workspace and robot parameters
    workspace_bounds = (-5, 5, -5, 5)
    robot_radii = [0.3, 0.3, 0.3]

    # Define static obstacles
    obstacles = [
        [0, 0, 0.5],   # Obstacle at center
    ]

    # Define start and goal positions
    starts = [
        np.array([-4.0, -4.0]),  # Robot 1
        np.array([4.0, 4.0]),    # Robot 2
        np.array([0.0, -4.0])    # Robot 3
    ]

    goals = [
        np.array([4.0, 4.0]),    # Robot 1
        np.array([-4.0, -4.0]), # Robot 2
        np.array([0.0, 4.0])     # Robot 3
    ]

    # Define priorities (lower number = higher priority)
    priorities = [0, 1, 2]  # Robot 1 has highest priority

    # Create and run priority-based planner
    planner = DistributedPriorityPlanner(workspace_bounds, robot_radii, obstacles)
    paths = planner.plan(starts, goals, priorities)

    if paths:
        print(f"Successfully planned for {len([p for p in paths if p is not None])} robots")

        # Calculate total path length for each robot
        for i, path in enumerate(paths):
            if path:
                total_length = sum(np.linalg.norm(path[j] - path[j-1])
                                 for j in range(1, len(path)))
                print(f"Robot {i+1} path length: {total_length:.2f}")
    else:
        print("Could not find valid paths for all robots")

if __name__ == "__main__":
    example_priority_based_planning()
```

### Velocity-Based Planning (e.g., ORCA)

Optimal Reciprocal Collision Avoidance (ORCA) is a velocity-based method for multi-robot collision avoidance.

```python
import numpy as np
from typing import List, Tuple, Optional
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

class ORCAPlanner:
    def __init__(self, robot_radius: float = 0.2, time_horizon: float = 10.0,
                 max_speed: float = 1.0):
        """
        Optimal Reciprocal Collision Avoidance planner
        """
        self.robot_radius = robot_radius
        self.time_horizon = time_horizon
        self.max_speed = max_speed

    def compute_orca_line(self, pos_i: np.ndarray, vel_i: np.ndarray,
                         pos_j: np.ndarray, vel_j: np.ndarray) -> Tuple[np.ndarray, float]:
        """
        Compute ORCA line for robot i with respect to robot j
        Returns: (normal_vector, offset) representing the half-plane
        """
        # Relative position
        pos_rel = pos_j - pos_i
        dist = np.linalg.norm(pos_rel)

        # Minimum distance to avoid collision
        min_dist = 2 * self.robot_radius

        if dist < min_dist:
            # Robots are colliding, use opposite direction
            if dist > 0:
                n = pos_rel / dist
            else:
                # If at same position, choose arbitrary direction
                n = np.array([1.0, 0.0])
        else:
            # Normal to the velocity obstacle
            n = pos_rel / dist

        # Relative velocity
        vel_rel = vel_j - vel_i

        # Collision time
        dvel = np.dot(vel_rel, n)
        if dvel > 0:
            # Moving away, no collision constraint needed
            return n, np.dot(vel_i, n)

        # Collision point in relative velocity space
        p_col = -pos_rel / self.time_horizon

        # ORCA line is perpendicular to the line from current relative velocity
        # to the closest point on the collision course
        vel_rel_to_col = p_col - vel_rel
        if np.linalg.norm(vel_rel_to_col) > 0:
            orca_normal = vel_rel_to_col / np.linalg.norm(vel_rel_to_col)
        else:
            # If zero vector, use position-based normal
            orca_normal = n

        # Calculate offset
        orca_offset = np.dot(vel_i, orca_normal) + 0.5 * np.dot(vel_rel, orca_normal)

        return orca_normal, orca_offset

    def plan_velocity(self, current_pos: np.ndarray, current_vel: np.ndarray,
                     desired_vel: np.ndarray, other_positions: List[np.ndarray],
                     other_velocities: List[np.ndarray]) -> np.ndarray:
        """
        Plan safe velocity using ORCA
        """
        # Start with desired velocity
        new_vel = desired_vel.copy()

        # Limit to maximum speed
        speed = np.linalg.norm(new_vel)
        if speed > self.max_speed:
            new_vel = (new_vel / speed) * self.max_speed

        # Apply ORCA constraints
        for other_pos, other_vel in zip(other_positions, other_velocities):
            if np.array_equal(other_pos, current_pos):
                continue  # Skip self

            # Compute ORCA line
            normal, offset = self.compute_orca_line(current_pos, new_vel,
                                                  other_pos, other_vel)

            # Check if current velocity violates the constraint
            if np.dot(new_vel, normal) < offset:
                # Project velocity onto the valid half-plane
                projection = np.dot(new_vel, normal)
                if projection < offset:
                    # Adjust velocity to satisfy constraint
                    adjustment = (offset - projection) * normal
                    new_vel += adjustment

        # Limit to maximum speed again after adjustments
        speed = np.linalg.norm(new_vel)
        if speed > self.max_speed:
            new_vel = (new_vel / speed) * self.max_speed

        return new_vel

class MultiRobotORCA:
    def __init__(self, num_robots: int, robot_radius: float = 0.2,
                 time_horizon: float = 10.0, max_speed: float = 1.0):
        """
        Multi-robot system using ORCA for collision avoidance
        """
        self.num_robots = num_robots
        self.planner = ORCAPlanner(robot_radius, time_horizon, max_speed)

        # Robot states: [positions, velocities]
        self.positions = np.zeros((num_robots, 2))
        self.velocities = np.zeros((num_robots, 2))
        self.goals = np.zeros((num_robots, 2))

    def set_robot_state(self, robot_idx: int, position: np.ndarray,
                       velocity: np.ndarray, goal: np.ndarray):
        """Set state for a specific robot"""
        self.positions[robot_idx] = position
        self.velocities[robot_idx] = velocity
        self.goals[robot_idx] = goal

    def update_velocities(self):
        """Update velocities for all robots using ORCA"""
        new_velocities = np.zeros_like(self.velocities)

        for i in range(self.num_robots):
            # Calculate desired velocity toward goal
            to_goal = self.goals[i] - self.positions[i]
            desired_vel = to_goal / (np.linalg.norm(to_goal) + 1e-6) * self.planner.max_speed

            # Get other robots' positions and velocities
            other_positions = [self.positions[j] for j in range(self.num_robots) if j != i]
            other_velocities = [self.velocities[j] for j in range(self.num_robots) if j != i]

            # Plan safe velocity using ORCA
            safe_vel = self.planner.plan_velocity(
                self.positions[i], self.velocities[i], desired_vel,
                other_positions, other_velocities
            )

            new_velocities[i] = safe_vel

        self.velocities = new_velocities

    def step(self, dt: float = 0.1):
        """Update robot positions based on current velocities"""
        self.positions += self.velocities * dt

    def simulate(self, num_steps: int = 100, dt: float = 0.1) -> List[np.ndarray]:
        """Run simulation and return trajectory for each robot"""
        trajectories = [[] for _ in range(self.num_robots)]

        for step in range(num_steps):
            # Record current positions
            for i in range(self.num_robots):
                trajectories[i].append(self.positions[i].copy())

            # Update velocities based on ORCA
            self.update_velocities()

            # Update positions
            self.step(dt)

        return trajectories

# Example usage
def example_orca_planning():
    # Create multi-robot system
    num_robots = 4
    system = MultiRobotORCA(num_robots, robot_radius=0.3, max_speed=0.8)

    # Set up a scenario where robots cross paths
    starts = [
        np.array([-4.0, -1.0]),  # Robot 0: left to right
        np.array([4.0, 1.0]),    # Robot 1: right to left
        np.array([-1.0, -4.0]), # Robot 2: bottom to top
        np.array([1.0, 4.0])     # Robot 3: top to bottom
    ]

    goals = [
        np.array([4.0, -1.0]),   # Robot 0 goal
        np.array([-4.0, 1.0]),  # Robot 1 goal
        np.array([-1.0, 4.0]),  # Robot 2 goal
        np.array([1.0, -4.0])    # Robot 3 goal
    ]

    # Initialize robot states
    for i in range(num_robots):
        system.set_robot_state(i, starts[i], np.array([0.0, 0.0]), goals[i])

    # Run simulation
    trajectories = system.simulate(num_steps=200, dt=0.1)

    print(f"Simulated {len(trajectories)} robots for {len(trajectories[0])} time steps")

    # Check if all robots reached their goals (approximately)
    for i in range(num_robots):
        final_pos = trajectories[i][-1]
        goal_dist = np.linalg.norm(final_pos - goals[i])
        print(f"Robot {i+1} final distance to goal: {goal_dist:.2f}")

    # Visualize the results
    visualize_orca_trajectories(trajectories, starts, goals)

def visualize_orca_trajectories(trajectories, starts, goals):
    """Visualize ORCA-based multi-robot trajectories"""
    fig, ax = plt.subplots(figsize=(12, 10))

    # Plot trajectories
    colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown']
    for i, traj in enumerate(trajectories):
        if traj:
            traj_array = np.array(traj)
            ax.plot(traj_array[:, 0], traj_array[:, 1],
                   color=colors[i % len(colors)], linewidth=2,
                   label=f'Robot {i+1}', alpha=0.7)

            # Plot start and goal positions
            ax.plot(starts[i][0], starts[i][1],
                   'o', color=colors[i % len(colors)], markersize=10,
                   markeredgecolor='black', markeredgewidth=2)
            ax.plot(goals[i][0], goals[i][1],
                   's', color=colors[i % len(colors)], markersize=10,
                   markeredgecolor='black', markeredgewidth=2)

    # Add labels
    for i, (start, goal) in enumerate(zip(starts, goals)):
        ax.text(start[0]-0.3, start[1]+0.3, f'S{i+1}', fontsize=9,
                ha='center', va='center',
                bbox=dict(boxstyle='round,pad=0.2', facecolor=colors[i % len(colors)], alpha=0.7))
        ax.text(goal[0]-0.3, goal[1]+0.3, f'G{i+1}', fontsize=9,
                ha='center', va='center',
                bbox=dict(boxstyle='round,pad=0.2', facecolor=colors[i % len(colors)], alpha=0.7))

    ax.set_xlim(-5, 5)
    ax.set_ylim(-5, 5)
    ax.set_xlabel('X Position')
    ax.set_ylabel('Y Position')
    ax.set_title('Multi-Robot Trajectory Planning with ORCA')
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_aspect('equal')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    example_orca_planning()
```

## Coordination Mechanisms

### Communication-Based Coordination

Robots can coordinate through explicit communication protocols.

```python
import numpy as np
from typing import List, Dict, Any
import heapq
import json

class RobotMessage:
    """Message exchanged between robots for coordination"""
    def __init__(self, sender_id: int, msg_type: str, content: Dict[str, Any]):
        self.sender_id = sender_id
        self.msg_type = msg_type  # 'intent', 'path', 'request', 'acknowledge', etc.
        self.content = content
        self.timestamp = 0  # Simulation time

class CommunicationNetwork:
    """Simulated communication network for multi-robot coordination"""
    def __init__(self, max_range: float = 5.0, drop_rate: float = 0.1):
        self.max_range = max_range
        self.drop_rate = drop_rate
        self.messages = []  # Queue of pending messages

    def broadcast(self, sender_pos: np.ndarray, message: RobotMessage,
                  robot_positions: List[np.ndarray]) -> List[int]:
        """Broadcast message to robots within communication range"""
        recipients = []
        for i, pos in enumerate(robot_positions):
            if i != message.sender_id:  # Don't send to self
                dist = np.linalg.norm(sender_pos - pos)
                if dist <= self.max_range:
                    # Simulate message drop
                    if np.random.random() > self.drop_rate:
                        self.messages.append((i, message))  # (recipient_id, message)
                        recipients.append(i)

        return recipients

    def get_messages_for_robot(self, robot_id: int) -> List[RobotMessage]:
        """Get pending messages for a specific robot"""
        robot_msgs = []
        remaining_msgs = []

        for recipient_id, msg in self.messages:
            if recipient_id == robot_id:
                robot_msgs.append(msg)
            else:
                remaining_msgs.append((recipient_id, msg))

        self.messages = remaining_msgs
        return robot_msgs

class CommunicativeRobot:
    """Robot that uses communication for coordination"""
    def __init__(self, robot_id: int, start_pos: np.ndarray, goal_pos: np.ndarray,
                 comm_network: CommunicationNetwork):
        self.robot_id = robot_id
        self.position = start_pos
        self.goal = goal_pos
        self.comm_network = comm_network

        # Planning components
        self.current_path = []
        self.path_index = 0
        self.velocity = np.array([0.0, 0.0])

        # Communication components
        self.known_robot_intents = {}  # robot_id -> intent
        self.reservation_table = {}    # time -> position (for path reservation)

    def broadcast_intent(self):
        """Broadcast current intended path to other robots"""
        if len(self.current_path) > self.path_index:
            intent = {
                'path': [p.tolist() for p in self.current_path[self.path_index:]],
                'current_pos': self.position.tolist(),
                'goal': self.goal.tolist()
            }

            msg = RobotMessage(self.robot_id, 'intent', intent)
            # In a real system, we would have access to robot positions
            # For simulation, we'll broadcast to all other robots
            return msg
        return None

    def process_messages(self, robot_positions: List[np.ndarray]):
        """Process received messages and update coordination data"""
        messages = self.comm_network.get_messages_for_robot(self.robot_id)

        for msg in messages:
            if msg.msg_type == 'intent':
                self.known_robot_intents[msg.sender_id] = msg.content

    def plan_with_coordination(self, all_positions: List[np.ndarray]):
        """Plan path considering other robots' intentions"""
        # For simplicity, this is a basic implementation
        # In a real system, this would involve more sophisticated
        # coordination algorithms like token passing, auction-based methods, etc.

        # Calculate desired direction to goal
        to_goal = self.goal - self.position
        desired_vel = to_goal / (np.linalg.norm(to_goal) + 1e-6)

        # Simple collision avoidance with other robots
        avoidance_force = np.array([0.0, 0.0])

        for i, pos in enumerate(all_positions):
            if i == self.robot_id:
                continue

            # Calculate avoidance force from other robots
            diff = self.position - pos
            dist = np.linalg.norm(diff)
            if dist < 1.0:  # Within avoidance range
                if dist > 0:
                    repulsion = diff / dist  # Away from other robot
                    strength = (1.0 - dist) * 2.0  # Stronger when closer
                    avoidance_force += repulsion * strength

        # Combine desired direction with avoidance
        combined_vel = desired_vel + avoidance_force
        speed = np.linalg.norm(combined_vel)
        if speed > 0:
            self.velocity = (combined_vel / speed) * min(speed, 1.0)
        else:
            self.velocity = np.array([0.0, 0.0])

    def update(self, dt: float = 0.1):
        """Update robot state"""
        self.position += self.velocity * dt
        self.path_index += 1

class CommunicationBasedCoordinator:
    """Coordinates multiple robots using communication"""
    def __init__(self, comm_range: float = 5.0, drop_rate: float = 0.05):
        self.comm_network = CommunicationNetwork(comm_range, drop_rate)
        self.robots = []

    def add_robot(self, robot_id: int, start_pos: np.ndarray, goal_pos: np.ndarray):
        """Add a robot to the coordination system"""
        robot = CommunicativeRobot(robot_id, start_pos, goal_pos, self.comm_network)
        self.robots.append(robot)
        return robot

    def step(self, dt: float = 0.1):
        """Execute one coordination step"""
        # Get all current positions
        positions = [robot.position for robot in self.robots]

        # Each robot broadcasts its intent
        for robot in self.robots:
            intent_msg = robot.broadcast_intent()
            if intent_msg:
                self.comm_network.broadcast(robot.position, intent_msg, positions)

        # Each robot processes messages and updates its plan
        for robot in self.robots:
            robot.process_messages(positions)
            robot.plan_with_coordination(positions)
            robot.update(dt)

    def simulate(self, num_steps: int = 100, dt: float = 0.1) -> List[List[np.ndarray]]:
        """Run coordination simulation"""
        trajectories = [[] for _ in range(len(self.robots))]

        for step in range(num_steps):
            # Record positions
            for i, robot in enumerate(self.robots):
                trajectories[i].append(robot.position.copy())

            # Execute coordination step
            self.step(dt)

        return trajectories

# Example usage
def example_communication_based():
    # Create coordinator
    coordinator = CommunicationBasedCoordinator(comm_range=6.0, drop_rate=0.05)

    # Add robots with crossing paths
    starts = [
        np.array([-4.0, -1.0]),
        np.array([4.0, 1.0]),
        np.array([-1.0, -4.0]),
        np.array([1.0, 4.0])
    ]

    goals = [
        np.array([4.0, -1.0]),
        np.array([-4.0, 1.0]),
        np.array([-1.0, 4.0]),
        np.array([1.0, -4.0])
    ]

    for i, (start, goal) in enumerate(zip(starts, goals)):
        coordinator.add_robot(i, start, goal)

    # Run simulation
    trajectories = coordinator.simulate(num_steps=200, dt=0.1)

    print(f"Simulated {len(trajectories)} communicating robots")

    # Visualize results
    visualize_communication_trajectories(trajectories, starts, goals)

def visualize_communication_trajectories(trajectories, starts, goals):
    """Visualize communication-based coordination results"""
    fig, ax = plt.subplots(figsize=(12, 10))

    # Plot trajectories
    colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown']
    for i, traj in enumerate(trajectories):
        if traj:
            traj_array = np.array(traj)
            ax.plot(traj_array[:, 0], traj_array[:, 1],
                   color=colors[i % len(colors)], linewidth=2,
                   label=f'Robot {i+1}', alpha=0.7)

            # Plot start and goal positions
            ax.plot(starts[i][0], starts[i][1],
                   'o', color=colors[i % len(colors)], markersize=10,
                   markeredgecolor='black', markeredgewidth=2)
            ax.plot(goals[i][0], goals[i][1],
                   's', color=colors[i % len(colors)], markersize=10,
                   markeredgecolor='black', markeredgewidth=2)

    ax.set_xlim(-5, 5)
    ax.set_ylim(-5, 5)
    ax.set_xlabel('X Position')
    ax.set_ylabel('Y Position')
    ax.set_title('Multi-Robot Coordination with Communication')
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_aspect('equal')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    example_communication_based()
```

## Applications and Considerations

### Swarm Robotics

Multi-robot planning is essential for swarm robotics applications where large numbers of simple robots work together.

### Formation Control

Maintaining geometric formations while navigating requires specialized multi-robot planning approaches.

### Task Allocation

Distributing tasks among robots and coordinating their execution is a key challenge in multi-robot systems.

### Real-time Considerations

For real-time applications, multi-robot planning algorithms must balance:
- Computational efficiency
- Solution quality
- Communication overhead
- Robustness to failures

## Performance Metrics

When evaluating multi-robot planning algorithms, important metrics include:
- **Makespan**: Total time to complete all tasks
- **Flowtime**: Average time for individual robots to reach goals
- **Total path length**: Sum of all robot paths
- **Success rate**: Percentage of runs that find valid solutions
- **Communication cost**: Number of messages exchanged
- **Computation time**: Time required for planning

## Conclusion

Multi-robot motion planning is a complex field that combines single-robot planning techniques with coordination mechanisms. The choice of approach depends on the specific requirements of the application, including the number of robots, environment characteristics, real-time constraints, and communication capabilities. Centralized approaches provide optimal solutions but don't scale well, while decentralized approaches scale better but may sacrifice optimality. Modern multi-robot systems often combine multiple approaches, using hierarchical planning where high-level coordination determines rough plans that are refined by low-level collision avoidance mechanisms.
