# 2.4 Package Management

## Overview

ROS 2 package management is the foundation for organizing, building, and distributing ROS 2 software. A package is the basic unit of code organization in ROS 2, containing nodes, libraries, configuration files, and other resources. Effective package management ensures modularity, reusability, and maintainability of robotic software systems.

## Key Concepts

- **Package**: The basic unit of organization in ROS 2 containing code, data, and configuration
- **ament**: The build system used by ROS 2 for package compilation and dependency management
- **colcon**: The meta-build system that orchestrates building multiple packages in a workspace
- **package.xml**: Manifest file containing package metadata and dependencies
- **CMakeLists.txt**: Build configuration file for CMake-based packages
- **setup.py**: Build configuration for Python packages using setuptools
- **Workspace**: Directory containing multiple related packages

## Package Structure

A typical ROS 2 package follows this structure:

```
my_robot_package/
├── CMakeLists.txt          # Build configuration
├── package.xml            # Package manifest
├── src/                   # Source code files
├── include/               # Header files
├── scripts/               # Executable scripts
├── launch/                # Launch files
├── config/                # Configuration files
├── test/                  # Test files
├── msg/                   # Custom message definitions
├── srv/                   # Custom service definitions
├── action/                # Custom action definitions
└── README.md              # Package documentation
```

## Package Manifest (package.xml)

The package.xml file contains metadata about the package and its dependencies:

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>my_robot_package</name>
  <version>0.1.0</version>
  <description>Package for my robot functionality</description>
  <maintainer email="maintainer@example.com">Maintainer Name</maintainer>
  <license>Apache License 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

## Build System Configuration

### CMakeLists.txt for C++ Packages

```cmake
cmake_minimum_required(VERSION 3.8)
project(my_robot_package)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)

# Create executable
add_executable(my_node src/my_node.cpp)
ament_target_dependencies(my_node
  rclcpp
  std_msgs
  geometry_msgs
)

# Install targets
install(TARGETS
  my_node
  DESTINATION lib/${PROJECT_NAME}
)

# Install other files
install(DIRECTORY
  launch config
  DESTINATION share/${PROJECT_NAME}
)

# Export dependencies
ament_package()
```

### setup.py for Python Packages

```python
from setuptools import setup
from glob import glob
import os

package_name = 'my_robot_package'

setup(
    name=package_name,
    version='0.1.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Maintainer Name',
    maintainer_email='maintainer@example.com',
    description='Package for my robot functionality',
    license='Apache License 2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'my_node = my_robot_package.my_node:main',
        ],
    },
)
```

## Creating New Packages

### Using ros2 pkg create

```bash
# Create a new C++ package
ros2 pkg create --build-type ament_cmake --dependencies rclcpp std_msgs my_new_package

# Create a new Python package
ros2 pkg create --build-type ament_python --dependencies rclpy std_msgs my_python_package
```

### Package Creation Options

- `--build-type`: Specify build system (ament_cmake, ament_python, cmake)
- `--dependencies`: List package dependencies
- `--maintainer-email`: Set maintainer email
- `--maintainer-name`: Set maintainer name
- `--description`: Set package description
- `--license`: Set license type

## Building Packages

### Using colcon build

```bash
# Build all packages in workspace
colcon build

# Build specific package
colcon build --packages-select my_robot_package

# Build with specific options
colcon build --packages-select my_robot_package --cmake-args -DCMAKE_BUILD_TYPE=Release

# Build and run tests
colcon build --packages-select my_robot_package --event-handlers console_direct+
```

### Workspace Structure

```
ros2_workspace/
├── src/
│   ├── package1/
│   ├── package2/
│   └── my_robot_package/
├── build/                 # Build artifacts
├── install/               # Installation directory
└── log/                   # Build logs
```

## Dependency Management

### Package Dependencies

Dependencies are categorized as:
- **buildtool_depend**: Build system dependencies (e.g., ament_cmake)
- **build_depend**: Dependencies needed for building
- **exec_depend**: Dependencies needed at runtime
- **test_depend**: Dependencies needed for testing
- **depend**: Shorthand for build_depend, exec_depend, and test_depend

### System Dependencies

For system-level dependencies:

```xml
<buildtool_depend>ament_cmake</buildtool_depend>
<depend>rclcpp</depend>
<depend>std_msgs</depend>
<exec_depend>ros2launch</exec_depend>
<test_depend>ament_lint_auto</test_depend>
```

## Launch Files

Launch files define how to start multiple nodes with specific configurations:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    config = os.path.join(
        get_package_share_directory('my_robot_package'),
        'config',
        'params.yaml'
    )

    return LaunchDescription([
        Node(
            package='my_robot_package',
            executable='my_node',
            name='my_node',
            parameters=[config],
            output='screen'
        )
    ])
```

## Configuration Files

YAML configuration files provide parameter management:

```yaml
/**:
  ros__parameters:
    use_sim_time: false
    frequency: 10.0
    debug_mode: false

my_node:
  ros__parameters:
    sensor_topic: "/sensors/laser_scan"
    threshold: 0.5
    frame_id: "base_link"
```

## Testing and Quality Assurance

### Unit Testing

```cpp
#include <gtest/gtest.h>
#include "my_robot_package/my_library.hpp"

TEST(MyRobotTest, TestFunctionality) {
    MyLibrary lib;
    EXPECT_EQ(lib.process(5), 10);
}
```

### Linting

```bash
# Run code quality checks
ament_copyright
ament_flake8
ament_pep257
ament_cppcheck
```

## Package Distribution

### Creating Debian Packages

```bash
# Create source package
bloom-generate rosdebian --rosdistro humble

# Build Debian package
dpkg-buildpackage -us -uc
```

### Using rosdep

```bash
# Install system dependencies
rosdep install --from-paths src --ignore-src -r -y
```

## Best Practices

1. **Single Responsibility**: Each package should have a clear, focused purpose
2. **Dependency Management**: Declare all dependencies explicitly in package.xml
3. **Consistent Naming**: Use descriptive, consistent naming conventions
4. **Documentation**: Include comprehensive README files and API documentation
5. **Testing**: Include unit tests and integration tests
6. **Versioning**: Follow semantic versioning practices
7. **Clean Build**: Ensure packages build cleanly without warnings
8. **Parameter Configuration**: Use parameter files for configuration management

## Advanced Topics

### Custom Message Types

Create custom messages in msg/ directory:

```bash
# Create custom message
echo "string name
int32 id
float64[] values" > msg/CustomMessage.msg
```

### Package Reusability

- Design packages for reuse across different robots
- Use parameters instead of hardcoding values
- Provide clear APIs and interfaces
- Include example launch files and configurations

Effective package management is crucial for developing maintainable and reusable robotic software systems in ROS 2.