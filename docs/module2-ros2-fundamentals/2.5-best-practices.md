# 2.5 Best Practices

## Overview

ROS 2 best practices encompass coding standards, architectural patterns, and development workflows that ensure robust, maintainable, and efficient robotic systems. These practices are derived from years of experience in robotics development and are essential for creating professional-grade applications.

## Code Organization and Structure

### Package Design Principles

- **Single Responsibility**: Each package should have one clear purpose
- **Modularity**: Design packages to be independently testable and reusable
- **Cohesion**: Group related functionality within the same package
- **Loose Coupling**: Minimize dependencies between packages

### Directory Structure Standards

Follow the conventional ROS 2 package structure:

```
my_robot_package/
├── CMakeLists.txt          # Build configuration
├── package.xml            # Package manifest
├── include/my_robot_package/  # Header files
├── src/                   # Source files
├── scripts/               # Python scripts
├── launch/                # Launch files
├── config/                # Configuration files
├── test/                  # Unit tests
├── doc/                   # Documentation
└── README.md              # Package overview
```

## Naming Conventions

### Node Naming

- Use descriptive, lowercase names with underscores
- Follow the pattern: `robot_function_component`
- Examples: `navigation_controller`, `arm_controller`, `sensor_processor`

### Topic and Service Naming

- Use hierarchical naming with forward slashes
- Be descriptive but concise
- Examples: `/robot/arm/joint_states`, `/navigation/goal`, `/sensors/laser_scan`

### Parameter Naming

- Use lowercase with underscores
- Group related parameters with common prefixes
- Examples: `sensor_frequency`, `navigation.planner_type`, `controller.kp_gain`

## Node Development Best Practices

### C++ Node Structure

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class BestPracticeNode : public rclcpp::Node
{
public:
    BestPracticeNode()
    : Node("best_practice_node")
    {
        // Initialize parameters with defaults
        this->declare_parameter("frequency", 10.0);

        // Create publishers/subscribers
        publisher_ = this->create_publisher<std_msgs::msg::String>(
            "topic_name", 10);

        // Create timer
        auto timer_callback = [this]() -> void {
            auto message = std_msgs::msg::String();
            message.data = "Hello World";
            RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
            publisher_->publish(message);
        };

        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(100), timer_callback);
    }

private:
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<BestPracticeNode>());
    rclcpp::shutdown();
    return 0;
}
```

### Python Node Structure

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class BestPracticeNode(Node):
    def __init__(self):
        super().__init__('best_practice_node')

        # Declare parameters with defaults
        self.declare_parameter('frequency', 10.0)

        # Get parameter value
        self.frequency = self.get_parameter('frequency').value

        # Create publisher
        self.publisher_ = self.create_publisher(String, 'topic_name', 10)

        # Create timer
        timer_period = 1.0 / self.frequency
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    node = BestPracticeNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Communication Pattern Guidelines

### Topic Best Practices

1. **Message Frequency**: Balance between responsiveness and resource usage
2. **Message Size**: Keep messages compact to reduce bandwidth
3. **QoS Settings**: Match QoS profiles between publishers and subscribers
4. **Topic Names**: Use descriptive, consistent naming conventions

### Service Best Practices

1. **Response Time**: Keep service calls brief (under 1-2 seconds)
2. **Error Handling**: Provide meaningful error responses
3. **Timeout Management**: Always set appropriate timeouts
4. **Use Cases**: Reserve for operations with clear start/end

### Action Best Practices

1. **Long-Running Tasks**: Use for operations taking seconds to minutes
2. **Feedback**: Provide meaningful progress updates
3. **Goal Management**: Handle preemption and cancellation
4. **Result Quality**: Ensure results are meaningful even on cancellation

## Parameter Management

### Parameter Declaration

```cpp
// C++ parameter declaration
this->declare_parameter("robot_name", "default_robot");
this->declare_parameter("control_frequency", 50.0);
this->declare_parameter("safety_limits", std::vector<double>{1.0, 2.0, 3.0});
```

```python
# Python parameter declaration
self.declare_parameter('robot_name', 'default_robot')
self.declare_parameter('control_frequency', 50.0)
self.declare_parameter('safety_limits', [1.0, 2.0, 3.0])
```

### Parameter Validation

```cpp
// Validate parameters after declaration
double freq = this->get_parameter("control_frequency").as_double();
if (freq <= 0 || freq > 1000) {
    RCLCPP_ERROR(this->get_logger(), "Invalid frequency: %f", freq);
    rclcpp::shutdown();
}
```

## Error Handling and Logging

### Logging Best Practices

```cpp
// Use appropriate log levels
RCLCPP_DEBUG(this->get_logger(), "Debug information: %s", details);
RCLCPP_INFO(this->get_logger(), "Normal operation: %s", info);
RCLCPP_WARN(this->get_logger(), "Warning: %s", warning_msg);
RCLCPP_ERROR(this->get_logger(), "Error: %s", error_msg);
RCLCPP_FATAL(this->get_logger(), "Fatal error: %s", fatal_msg);
```

### Exception Handling

```cpp
try {
    // ROS operations that might fail
    auto result = service_client_->async_send_request(request);
} catch (const std::exception& e) {
    RCLCPP_ERROR(this->get_logger(), "Service call failed: %s", e.what());
}
```

## Testing Strategies

### Unit Testing Structure

```cpp
#include <gtest/gtest.h>
#include "my_robot_package/my_library.hpp"

class MyLibraryTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup code
    }

    void TearDown() override {
        // Cleanup code
    }

    MyLibrary lib_;
};

TEST_F(MyLibraryTest, TestNormalOperation) {
    EXPECT_EQ(lib_.process(5), 10);
}

TEST_F(MyLibraryTest, TestEdgeCases) {
    EXPECT_EQ(lib_.process(0), 0);
    EXPECT_GT(lib_.process(-1), 0);  // Handle negative inputs appropriately
}
```

### Integration Testing

```python
import unittest
import rclpy
from rclpy.executors import SingleThreadedExecutor
from std_msgs.msg import String

class TestNodeIntegration(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.node = TestNode()
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)

    def tearDown(self):
        self.node.destroy_node()
        rclpy.shutdown()

    def test_message_flow(self):
        # Test complete message flow
        received_msg = None

        def callback(msg):
            nonlocal received_msg
            received_msg = msg

        sub = self.node.create_subscription(
            String, 'test_topic', callback, 10)

        # Publish and verify
        pub = self.node.create_publisher(String, 'test_topic', 10)
        test_msg = String()
        test_msg.data = 'test'
        pub.publish(test_msg)

        self.executor.spin_once(timeout_sec=1.0)
        self.assertIsNotNone(received_msg)
        self.assertEqual(received_msg.data, 'test')
```

## Performance Optimization

### Memory Management

- Use smart pointers (`std::shared_ptr`, `std::unique_ptr`) for automatic memory management
- Avoid unnecessary message copies in callbacks
- Consider memory pools for frequently allocated objects

### Threading and Concurrency

```cpp
// Use appropriate executors
rclcpp::executors::MultiThreadedExecutor executor;
executor.add_node(node);
executor.spin();
```

### Computational Efficiency

- Optimize algorithms and data structures
- Use efficient message types (avoid strings for numeric data)
- Consider message compression for large data

## Security Considerations

### Authentication and Authorization

- Use ROS 2 security features when available
- Validate all incoming data
- Implement access controls for sensitive services

### Data Protection

- Encrypt sensitive data in transit
- Secure parameter servers
- Implement proper error handling to avoid information disclosure

## Documentation Standards

### Code Documentation

```cpp
/**
 * @brief Controller for robot arm movement
 *
 * This class provides position and velocity control for a 6-DOF robotic arm.
 * It handles trajectory planning, safety checks, and communication with
 * hardware interfaces.
 *
 * @param[in] joint_names Names of the joints to control
 * @param[in] control_frequency Frequency of control loop in Hz
 * @param[out] joint_states Current joint positions, velocities, and efforts
 */
class ArmController : public rclcpp::Node
{
    // Implementation
};
```

### Launch File Documentation

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.substitutions import TextSubstitution
from launch.actions import DeclareLaunchArgument

def generate_launch_description():
    """Launch file for arm controller with configurable parameters."""

    return LaunchDescription([
        DeclareLaunchArgument(
            'control_frequency',
            default_value='50.0',
            description='Frequency of control loop in Hz'),

        Node(
            package='my_robot_package',
            executable='arm_controller',
            name='arm_controller',
            parameters=[{
                'control_frequency': LaunchConfiguration('control_frequency')
            }]
        )
    ])
```

## Version Control and CI/CD

### Git Practices

- Use feature branches for development
- Write descriptive commit messages
- Include package version updates in commits
- Maintain CHANGELOG.rst files

### Continuous Integration

```yaml
# .github/workflows/ci.yml
name: ROS 2 CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: ros-tooling/setup-ros@v0.2
    - uses: ros-tooling/action-ros-ci@v0.2
      with:
        package-name: my_robot_package
```

## Common Anti-Patterns to Avoid

1. **Hardcoded Values**: Use parameters instead of magic numbers
2. **Blocking Operations**: Avoid blocking calls in callbacks
3. **Global State**: Minimize global variables and shared state
4. **Inconsistent APIs**: Maintain consistent interfaces across packages
5. **Insufficient Testing**: Test all critical paths and edge cases

Following these best practices ensures robust, maintainable, and professional ROS 2 applications that can scale from research prototypes to production systems.