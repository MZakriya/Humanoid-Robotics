# 2.6 ROS 2 Examples

## Overview

This chapter provides practical examples of ROS 2 concepts in action, demonstrating real-world applications of the communication patterns, package structures, and best practices discussed in previous chapters. These examples range from simple "Hello World" implementations to complex multi-node systems that showcase the power of ROS 2.

## Simple Publisher-Subscriber Example

### Python Implementation

Let's create a complete example with a publisher and subscriber:

**Publisher Node (publisher_member_function.py):**

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Subscriber Node (subscriber_member_function.py):**

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, message):
        self.get_logger().info(f'I heard: "{message.data}"')

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Running the Example:**

```bash
# Terminal 1: Run the publisher
ros2 run my_package publisher_member_function

# Terminal 2: Run the subscriber
ros2 run my_package subscriber_member_function
```

## C++ Publisher-Subscriber Example

### Publisher Node (minimal_publisher.cpp):

```cpp
#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace std::chrono_literals;

class MinimalPublisher : public rclcpp::Node
{
public:
    MinimalPublisher()
    : Node("minimal_publisher"), count_(0)
    {
        publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
        timer_ = this->create_wall_timer(
            500ms, std::bind(&MinimalPublisher::timer_callback, this));
    }

private:
    void timer_callback()
    {
        auto message = std_msgs::msg::String();
        message.data = "Hello World: " + std::to_string(count_++);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
        publisher_->publish(message);
    }
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    size_t count_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<MinimalPublisher>());
    rclcpp::shutdown();
    return 0;
}
```

### Subscriber Node (minimal_subscriber.cpp):

```cpp
#include <memory>
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class MinimalSubscriber : public rclcpp::Node
{
public:
    MinimalSubscriber()
    : Node("minimal_subscriber")
    {
        subscription_ = this->create_subscription<std_msgs::msg::String>(
            "topic", 10,
            [this](const std_msgs::msg::String::SharedPtr msg) {
                RCLCPP_INFO(this->get_logger(), "I heard: '%s'", msg->data.c_str());
            });
    }

private:
    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<MinimalSubscriber>());
    rclcpp::shutdown();
    return 0;
}
```

## Service Example

### Service Server (add_two_ints_server.cpp):

```cpp
#include "rclcpp/rclcpp.hpp"
#include "example_interfaces/srv/add_two_ints.hpp"

class AddTwoIntsServer : public rclcpp::Node
{
public:
    AddTwoIntsServer()
    : Node("add_two_ints_server")
    {
        service_ = this->create_service<example_interfaces::srv::AddTwoInts>(
            "add_two_ints",
            std::bind(&AddTwoIntsServer::add, this,
                     std::placeholders::_1, std::placeholders::_2));
    }

private:
    void add(const example_interfaces::srv::AddTwoInts::Request::SharedPtr request,
             const example_interfaces::srv::AddTwoInts::Response::SharedPtr response)
    {
        response->sum = request->a + request->b;
        RCLCPP_INFO(this->get_logger(), "Incoming request\na: %ld, b: %ld",
                    request->a, request->b);
        RCLCPP_INFO(this->get_logger(), "Sending back response: [%ld]", response->sum);
    }
    rclcpp::Service<example_interfaces::srv::AddTwoInts>::SharedPtr service_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<AddTwoIntsServer>());
    rclcpp::shutdown();
    return 0;
}
```

### Service Client (add_two_ints_client.cpp):

```cpp
#include <chrono>
#include <cstdlib>
#include <memory>
#include "rclcpp/rclcpp.hpp"
#include "example_interfaces/srv/add_two_ints.hpp"

using namespace std::chrono_literals;

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);

    if (argc != 3) {
        RCLCPP_INFO(rclcpp::get_logger("rclcpp"),
                    "usage: add_two_ints_client X Y");
        return 1;
    }

    std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared("add_two_ints_client");
    rclcpp::Client<example_interfaces::srv::AddTwoInts>::SharedPtr client =
        node->create_client<example_interfaces::srv::AddTwoInts>("add_two_ints");

    auto request = std::make_shared<example_interfaces::srv::AddTwoInts::Request>();
    request->a = atoll(argv[1]);
    request->b = atoll(argv[2]);

    while (!client->wait_for_service(1s)) {
        if (!rclcpp::ok()) {
            RCLCPP_ERROR(rclcpp::get_logger("rclcpp"),
                        "Interrupted while waiting for the service. Exiting.");
            return 0;
        }
        RCLCPP_INFO(rclcpp::get_logger("rclcpp"),
                    "Service not available, waiting again...");
    }

    auto result = client->async_send_request(request);
    // Wait for the result.
    if (rclcpp::spin_until_future_complete(node, result) ==
        rclcpp::FutureReturnCode::SUCCESS)
    {
        RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "Sum: %ld",
                    result.get()->sum);
    } else {
        RCLCPP_ERROR(rclcpp::get_logger("rclcpp"),
                    "Failed to call service add_two_ints");
    }

    rclcpp::shutdown();
    return 0;
}
```

## Action Example

### Action Server (fibonacci_action_server.py):

```python
#!/usr/bin/env python3

import time
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])

            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(1)

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info(f'Result: {result.sequence}')

        return result

def main(args=None):
    rclpy.init(args=args)
    fibonacci_action_server = FibonacciActionServer()
    rclpy.spin(fibonacci_action_server)
    fibonacci_action_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Action Client (fibonacci_action_client.py):

```python
#!/usr/bin/env python3

import time
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionClient(Node):
    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(
            self,
            Fibonacci,
            'fibonacci')

    def send_goal(self, order=10):
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        self._action_client.wait_for_server()

        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Received feedback: {feedback.sequence}')

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Result: {result.sequence}')
        rclpy.shutdown()

def main(args=None):
    rclpy.init(args=args)
    action_client = FibonacciActionClient()
    action_client.send_goal(10)
    rclpy.spin(action_client)

if __name__ == '__main__':
    main()
```

## Complex Multi-Node Example: TurtleSim Controller

Let's create a more complex example that demonstrates multiple concepts:

**turtle_controller.py:**

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
from std_msgs.msg import String
import math

class TurtleController(Node):
    def __init__(self):
        super().__init__('turtle_controller')

        # Declare parameters
        self.declare_parameter('target_x', 5.0)
        self.declare_parameter('target_y', 5.0)
        self.declare_parameter('linear_speed', 1.0)
        self.declare_parameter('angular_speed', 1.0)

        # Get parameters
        self.target_x = self.get_parameter('target_x').value
        self.target_y = self.get_parameter('target_y').value
        self.linear_speed = self.get_parameter('linear_speed').value
        self.angular_speed = self.get_parameter('angular_speed').value

        # Create publishers and subscribers
        self.cmd_vel_pub = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)
        self.pose_sub = self.create_subscription(Pose, '/turtle1/pose', self.pose_callback, 10)
        self.status_pub = self.create_publisher(String, '/turtle1/status', 10)

        # Create timer
        self.timer = self.create_timer(0.1, self.control_loop)

        # Initialize variables
        self.current_pose = None
        self.reached_target = False

    def pose_callback(self, msg):
        self.current_pose = msg

    def control_loop(self):
        if self.current_pose is None:
            return

        if self.reached_target:
            # Stop the turtle when target is reached
            cmd = Twist()
            self.cmd_vel_pub.publish(cmd)
            return

        # Calculate distance to target
        dx = self.target_x - self.current_pose.x
        dy = self.target_y - self.current_pose.y
        distance = math.sqrt(dx*dx + dy*dy)

        # Check if we've reached the target
        if distance < 0.1:
            self.reached_target = True
            status_msg = String()
            status_msg.data = f"Target reached at ({self.target_x}, {self.target_y})"
            self.status_pub.publish(status_msg)
            cmd = Twist()
            self.cmd_vel_pub.publish(cmd)
            return

        # Calculate angle to target
        target_angle = math.atan2(dy, dx)
        angle_error = target_angle - self.current_pose.theta

        # Normalize angle error to [-pi, pi]
        while angle_error > math.pi:
            angle_error -= 2 * math.pi
        while angle_error < -math.pi:
            angle_error += 2 * math.pi

        # Create twist message
        cmd = Twist()

        # Proportional control for angular velocity
        cmd.angular.z = self.angular_speed * angle_error

        # Move forward if roughly aligned with target
        if abs(angle_error) < 0.1:
            cmd.linear.x = min(self.linear_speed, distance)
        else:
            cmd.linear.x = 0.0

        self.cmd_vel_pub.publish(cmd)

def main(args=None):
    rclpy.init(args=args)
    controller = TurtleController()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Launch File Example

**turtle_control_launch.py:**

```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        # Declare launch arguments
        DeclareLaunchArgument(
            'target_x',
            default_value='5.0',
            description='Target X coordinate'),
        DeclareLaunchArgument(
            'target_y',
            default_value='5.0',
            description='Target Y coordinate'),
        DeclareLaunchArgument(
            'linear_speed',
            default_value='1.0',
            description='Linear speed'),
        DeclareLaunchArgument(
            'angular_speed',
            default_value='1.0',
            description='Angular speed'),

        # Launch turtle controller
        Node(
            package='turtlesim',
            executable='turtlesim_node',
            name='turtlesim',
            output='screen'
        ),

        Node(
            package='my_robot_package',
            executable='turtle_controller',
            name='turtle_controller',
            parameters=[
                {'target_x': LaunchConfiguration('target_x')},
                {'target_y': LaunchConfiguration('target_y')},
                {'linear_speed': LaunchConfiguration('linear_speed')},
                {'angular_speed': LaunchConfiguration('angular_speed')}
            ],
            output='screen'
        )
    ])
```

## Parameter Configuration Example

**config/turtle_params.yaml:**

```yaml
/**:
  ros__parameters:
    use_sim_time: false

turtle_controller:
  ros__parameters:
    target_x: 8.0
    target_y: 8.0
    linear_speed: 2.0
    angular_speed: 2.0
    tolerance: 0.1
```

## Testing Example

**test/test_turtle_controller.py:**

```python
import unittest
import rclpy
from rclpy.executors import SingleThreadedExecutor
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
from std_msgs.msg import String

class TestTurtleController(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.node = rclpy.create_node('test_turtle_controller')
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)

    def tearDown(self):
        self.node.destroy_node()
        rclpy.shutdown()

    def test_publish_command(self):
        # Test that the controller publishes velocity commands
        publisher = self.node.create_publisher(Twist, '/turtle1/cmd_vel', 10)

        # Create and publish a test command
        cmd = Twist()
        cmd.linear.x = 1.0
        cmd.angular.z = 0.5

        publisher.publish(cmd)

        # Verify the message was published (this is a basic check)
        self.assertIsNotNone(cmd)

    def test_parameter_validation(self):
        # Test parameter validation
        self.node.declare_parameter('target_x', 5.0)
        self.node.declare_parameter('target_y', 5.0)

        target_x = self.node.get_parameter('target_x').value
        target_y = self.node.get_parameter('target_y').value

        self.assertIsInstance(target_x, float)
        self.assertIsInstance(target_y, float)
        self.assertGreaterEqual(target_x, 0.0)
        self.assertGreaterEqual(target_y, 0.0)

if __name__ == '__main__':
    unittest.main()
```

## CMake Configuration Example

**CMakeLists.txt:**

```cmake
cmake_minimum_required(VERSION 3.8)
project(my_robot_examples)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(example_interfaces REQUIRED)

# Create executables
add_executable(minimal_publisher src/minimal_publisher.cpp)
add_executable(minimal_subscriber src/minimal_subscriber.cpp)
add_executable(add_two_ints_server src/add_two_ints_server.cpp)
add_executable(add_two_ints_client src/add_two_ints_client.cpp)

# Link libraries
ament_target_dependencies(minimal_publisher
  rclcpp
  std_msgs
)

ament_target_dependencies(minimal_subscriber
  rclcpp
  std_msgs
)

ament_target_dependencies(add_two_ints_server
  rclcpp
  example_interfaces
)

ament_target_dependencies(add_two_ints_client
  rclcpp
  example_interfaces
)

# Install executables
install(TARGETS
  minimal_publisher
  minimal_subscriber
  add_two_ints_server
  add_two_ints_client
  DESTINATION lib/${PROJECT_NAME}
)

# Install Python scripts
install(PROGRAMS
  scripts/turtle_controller.py
  scripts/fibonacci_action_client.py
  scripts/fibonacci_action_server.py
  DESTINATION lib/${PROJECT_NAME}
)

# Install launch files
install(DIRECTORY
  launch
  config
  DESTINATION share/${PROJECT_NAME}
)

# Install test files
if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()
```

## Running Examples

### Build the Package

```bash
# Navigate to workspace
cd ~/ros2_ws

# Build the package
colcon build --packages-select my_robot_examples

# Source the workspace
source install/setup.bash
```

### Run Examples

```bash
# Run publisher and subscriber
ros2 run my_robot_examples minimal_publisher
ros2 run my_robot_examples minimal_subscriber

# Run service example
ros2 run my_robot_examples add_two_ints_server
ros2 run my_robot_examples add_two_ints_client 2 3

# Run action example
ros2 run my_robot_examples fibonacci_action_server
ros2 run my_robot_examples fibonacci_action_client

# Run launch file
ros2 launch my_robot_examples turtle_control_launch.py
```

These examples demonstrate the practical application of ROS 2 concepts and provide a foundation for building more complex robotic systems. Each example showcases different aspects of ROS 2 programming and can be extended to meet specific application requirements.