# 2.2 Nodes and Topics

## Overview

Nodes and Topics form the fundamental communication architecture of ROS 2. A node is an executable process that performs computation, while topics are named buses over which nodes exchange messages. This publisher-subscriber communication model enables loose coupling between different components of a robotic system, allowing for modular and scalable architectures.

## Key Concepts

- **Node**: A process that performs computation; the basic unit of executable code in ROS 2
- **Topic**: A named channel for passing messages between nodes (publisher-subscriber pattern)
- **Publisher**: A node that sends messages to a topic
- **Subscriber**: A node that receives messages from a topic
- **Message**: A data structure that flows between nodes through topics
- **DDS**: Data Distribution Service layer that provides the underlying communication infrastructure

## ROS 2 Node Architecture

ROS 2 nodes are implemented using client libraries that provide language-specific APIs. The most common is `rclcpp` for C++ and `rclpy` for Python. Each node:

1. Initializes the ROS 2 client library
2. Creates a node instance with a unique name
3. Creates publishers and/or subscribers for specific topics
4. Spins to process callbacks and send/receive messages
5. Cleans up resources when shutting down

## Topic Communication Patterns

Topics in ROS 2 implement a one-to-many communication pattern where multiple publishers can write to a topic and multiple subscribers can read from it. The communication is:

- **Asynchronous**: Publishers and subscribers don't need to be synchronized
- **Typed**: Messages must match a predefined message type
- **Named**: Topics use a hierarchical namespace (e.g., `/sensor/laser_scan`)
- **QoS-aware**: Quality of Service policies can be configured for reliability and performance

## Quality of Service (QoS) Settings

ROS 2 provides QoS settings to control message delivery characteristics:

```cpp
// Example C++ QoS configuration
rclcpp::QoS qos_profile(10);  // history depth of 10
qos_profile.reliability(RMW_QOS_POLICY_RELIABILITY_RELIABLE);
qos_profile.durability(RMW_QOS_POLICY_DURABILITY_VOLATILE);
```

Key QoS policies include:
- **Reliability**: Best effort vs reliable delivery
- **Durability**: Volatile vs transient local (keep last message for late joiners)
- **History**: Keep last N messages vs keep all messages
- **Deadline**: Maximum time between messages

## Implementation Example

### Python Implementation

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class TalkerNode(Node):
    def __init__(self):
        super().__init__('talker')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

class ListenerNode(Node):
    def __init__(self):
        super().__init__('listener')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    talker = TalkerNode()
    listener = ListenerNode()

    executor = rclpy.executors.MultiThreadedExecutor()
    executor.add_node(talker)
    executor.add_node(listener)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        executor.shutdown()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### C++ Implementation

```cpp
#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace std::chrono_literals;

class MinimalPublisher : public rclcpp::Node
{
public:
    MinimalPublisher()
    : Node("minimal_publisher"), count_(0)
    {
        publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
        timer_ = this->create_wall_timer(
            500ms, std::bind(&MinimalPublisher::timer_callback, this));
    }

private:
    void timer_callback()
    {
        auto message = std_msgs::msg::String();
        message.data = "Hello, world! " + std::to_string(count_++);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
        publisher_->publish(message);
    }
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    size_t count_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclpy::spin(std::make_shared<MinimalPublisher>());
    rclcpp::shutdown();
    return 0;
}
```

## Best Practices

1. **Node Naming**: Use descriptive names that reflect the node's function
2. **Topic Names**: Follow ROS naming conventions (lowercase, underscores)
3. **Message Types**: Use appropriate built-in message types or create custom ones
4. **QoS Configuration**: Match QoS settings between publishers and subscribers
5. **Resource Management**: Properly clean up publishers and subscribers
6. **Error Handling**: Implement robust error handling for communication failures

## Advanced Topics

### Namespacing

Nodes can be placed in namespaces for better organization:

```bash
# Launch node with namespace
ros2 run my_package my_node --ros-args --remap __ns:=/robot1
```

### Topic Remapping

Topics can be remapped at runtime:

```bash
# Remap topic at runtime
ros2 run my_package my_node --ros-args --remap /original_topic:=/new_topic
```

### Monitoring Tools

Use ROS 2 command-line tools to monitor topic communication:

```bash
# List all topics
ros2 topic list

# Echo messages on a topic
ros2 topic echo /chatter std_msgs/msg/String

# Get information about a topic
ros2 topic info /chatter
```

## Common Pitfalls

1. **Topic Mismatch**: Publishers and subscribers must use the same topic name and message type
2. **QoS Incompatibility**: Incompatible QoS settings can prevent communication
3. **Node Conflicts**: Multiple nodes with the same name can cause issues
4. **Resource Leaks**: Failing to properly clean up publishers/subscribers
5. **Timing Issues**: Subscribers may miss initial messages if they start after publishers

This architecture enables robust, distributed robotic systems where components can be developed, tested, and deployed independently while maintaining seamless communication through the ROS 2 topic system.