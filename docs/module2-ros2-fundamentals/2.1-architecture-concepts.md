# 2.1 ROS 2 Architecture and Concepts

## Overview
This section introduces the fundamental architecture of ROS 2 and its core concepts, providing the foundation for understanding how ROS 2 systems are structured and operate.

## Key Architectural Components

### DDS (Data Distribution Service)
- Middleware layer that enables communication between ROS 2 nodes
- Provides publish-subscribe and request-reply communication patterns
- Handles data serialization and network transport

### Nodes
- Independent processes that perform specific functions
- Communicate with other nodes through topics, services, and actions
- Managed by the ROS 2 runtime system

### Topics
- Communication channels for streaming data between publishers and subscribers
- Enable asynchronous, one-way data flow
- Support for multiple publishers and subscribers on the same topic

### Services
- Synchronous request-response communication pattern
- Used for operations that require immediate responses
- Support for complex data structures in requests and responses

## Client Library Architecture

### rclcpp and rclpy
- C++ and Python client libraries for ROS 2
- Provide high-level APIs for node development
- Handle low-level communication details

### rcl (ROS Client Library)
- Common C-based interface for all client libraries
- Provides consistent functionality across languages
- Abstracts DDS implementation details

## Quality of Service (QoS) Settings

### Reliability Policy
- Reliable: All messages are delivered (default for services)
- Best Effort: Messages may be lost (default for topics)

### Durability Policy
- Transient Local: Late-joining subscribers receive last known value
- Volatile: No historical data provided to new subscribers

### History Policy
- Keep Last: Maintain a fixed number of most recent messages
- Keep All: Maintain all messages (limited by memory)

## Implementation Example

```cpp
// Example C++ ROS 2 Node
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class MinimalPublisher : public rclcpp::Node
{
public:
    MinimalPublisher()
    : Node("minimal_publisher"), count_(0)
    {
        publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
        timer_ = this->create_wall_timer(
            500ms, std::bind(&MinimalPublisher::timer_callback, this));
    }

private:
    void timer_callback()
    {
        auto message = std_msgs::msg::String();
        message.data = "Hello, world! " + std::to_string(count_++);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
        publisher_->publish(message);
    }
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    size_t count_;
};
```

## ROS 2 vs. Traditional Software Architecture

| Aspect | Traditional Software | ROS 2 Architecture |
|--------|---------------------|-------------------|
| Communication | Function calls, shared memory | Topics, services, actions |
| Process Management | Manual process management | Node lifecycle management |
| Data Types | Custom data structures | Standardized message types |
| Network Communication | Custom protocols | DDS-based communication |
| System Composition | Static linking | Dynamic node composition |

## Best Practices for Architecture Design

### Modularity
- Design nodes to perform single, well-defined functions
- Use composition to combine simple nodes into complex systems
- Minimize inter-node dependencies

### Communication Design
- Choose appropriate communication patterns (topic vs. service vs. action)
- Design efficient message structures
- Consider QoS settings for different use cases

### Resource Management
- Properly manage node lifecycle
- Handle cleanup and resource deallocation
- Implement graceful shutdown procedures
